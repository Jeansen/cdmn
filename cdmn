#! perl -T

# cdmn is an extension written for the rxvt terminal emulator that shows
# utilizations of different system resoureces like cpu, disk i/o, ram,
# network (and more).

# Copyright (C) 2016-2017 Marcel Lautenbach
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use 5.10.1;
use strict;
use warnings FATAL => 'all';
use autodie;

use utf8;
use autodie;

use Filesys::Df;
binmode STDOUT, ":encoding(UTF-8)";

package cdmn::utils {

    sub cut_set {
        my @cut = ();
        my %n   = ();

        for my $e ( @{ $_[0] }, @{ $_[1] } ) { $n{$e}++ }
        for my $e ( @{ $_[0] } ) { push @{ \@cut }, $e if $n{$e} > 1 }

        return \@cut;
    }
}

package cdmn::constants {
    use constant {
        ACTION_SHOW             => 'cdmn:show',
        ACTION_SHOW_LABELS      => 'cdmn:show-labels',
        ACTION_SHOW_SIDEBAR     => 'cdmn:show-sidebar',
        ACTION_SHOW_TRANSPARENT => 'cdmn:action-show-transparent',
        ACTION_NEXT_PANE        => 'cdmn:action-next-pane',
        ACTION_PREV_PANE        => 'cdmn:action-prev-pane',
    };

    use constant {
        ALIGN_COL => 'col',
        ALIGN_ROW => 'row',
    };

    use constant {
        STYLE_LED => 'led',
        STYLE_BAR => 'bar',
    };

    use constant REND => urxvt::SET_COLOR urxvt::OVERLAY_RSTYLE, 255, 1;
}

package cdmn::proc {
    use List::Util qw(sum max min);
    use Params::Validate qw(:all);

    use constant {
        PARTITIONS => '/proc/partitions',
        MOUNTS     => '/proc/mounts',
        STAT       => '/proc/stat',
        DISKSTATS  => '/proc/diskstats',
        MEMINFO    => '/proc/meminfo',
        NET_ROUTE  => '/proc/net/route',
    };

    use constant {
        SPEED     => 'speed',
        OPERSTATE => 'operstate',
        TX        => 'tx_bytes',
        RX        => 'rx_bytes',
        BAT_FULL  => 'full',
        BAT_NOW   => 'now',
    };

    use constant {
        CPU_PRESENT => '/sys/devices/system/cpu/present',
        HWMON       => '/sys/class/hwmon/',
        SYSFS_NET   => '/sys/class/net/',
        SYSFS_BAT   => '/sys/class/power_supply/',
        SYSFS_BLOCK => '/sys/block/',
    };

    use constant {
        POSTFIX_TX    => '_tx',
        POSTFIX_RX    => '_rx',
        POSTFIX_READ  => '_read',
        POSTFIX_WRITE => '_write',
    };

    #TODO sometimes no results are given - check
    sub cpu_temp_usages {
        my %results;
        if ( -e HWMON ) {
            opendir( my $dh, HWMON );
            my @dir = readdir $dh;
            for (@dir) {
                next if $_ =~ /\A\.\.?\z/;
                my $p = HWMON . $_;
                open( my $f, '<', $p . "/name" ) || last;
                chomp( my $state = <$f> );
                if ( $state eq 'coretemp' ) {
                    opendir( $dh, $p );
                    @dir = readdir $dh;
                    my %cores = map { /(temp\d)/ ? ( ( $_ =~ /(temp\d)/ ), "" ) : () } @dir;
                    for ( keys %cores ) {
                        open( $f, '<', $p . "/" . $_ . "_input" );
                        chomp( my $cv = <$f> );
                        open( $f, '<', $p . "/" . $_ . "_crit" );
                        chomp( my $mv = <$f> );
                        open( $f, '<', $p . "/" . $_ . "_label" );
                        chomp( my $l = <$f> );
                        last if $l !~ /\ACore/;
                        $results{$l} = $cv / $mv * 100;
                    }
                    last;
                }
            }
            closedir $dh;
        }
        return \%results;
    }

    sub cores {
        my @results;
        opendir( my $dh, HWMON );
        my @dir = readdir $dh;
        for (@dir) {
            next if $_ =~ /\A\.\.?\z/;
            my $p = HWMON . $_;
            open( my $f, '<', $p . "/name" );
            chomp( my $state = <$f> );
            if ( $state eq 'coretemp' ) {
                opendir( $dh, $p );
                @dir = readdir $dh;
                my %cores = map { /(temp\d)/ ? ( ( $_ =~ /(temp\d)/ ), "" ) : () } @dir;
                for ( keys %cores ) {
                    open( $f, '<', $p . "/" . $_ . "_label" );
                    chomp( my $l = <$f> );
                    push @results, $l if $l =~ /\ACore/;
                }
                last;
            }
        }
        closedir $dh;
        return \@results;
    }

    sub sysfs_net {
        my $path = SYSFS_NET . "/$_[0]";
        return $path . "/statistics/$_[1]" if $_[1] && ( $_[1] eq TX        || $_[1] eq RX );
        return $path . "/$_[1]"            if $_[1] && ( $_[1] eq OPERSTATE || $_[1] eq SPEED );
        $path;
    }

    sub ac_online {
        opendir( my $dh, SYSFS_BAT );
        my @dir = readdir $dh;
        for (@dir) {
            if (/AC/) {
                open( my $f, '<', SYSFS_BAT . $_ . "/online" );
                chomp( my $state = <$f> );
                closedir $dh;
                return $state;
            }
        }
        closedir $dh;
        0;
    }

    sub has_wifi {
        opendir( my $dh, sysfs_net(shift) );
        my @dir = readdir $dh;
        for (@dir) { return 1 if (/wireless/); }
        closedir $dh;
        0;
    }

    sub network_down {
        open( my $f, '<', sysfs_net( shift, OPERSTATE ) );
        chomp( my $state = <$f> );

        # RFC2863 operational states: unknown notpresent down up lowerlayerdown testing dormant
        return 1 if $state =~ 'down|unknown';
        0;
    }

    sub network_list {
        my @ifs;
        opendir( my $dh, SYSFS_NET );
        my @dir = readdir $dh;
        for (@dir) {
            my $if = $_;
            next if (/\A\.\.?$|\Aveth/);
            if ( !has_wifi($if) ) {
                open( my $f, '<', sysfs_net( $if, SPEED ) );
                chomp( my @lines = <$f> );
                next if scalar @lines eq 0;
            }
            next if network_down($if);
            push @ifs, $if;
        }
        closedir $dh;
        return \@ifs;
    }

    sub mounts {
        open( my $f, '<', MOUNTS );
        my @mounts;
        my %mounts;
        for (<$f>) {
            push @mounts, /(\A\/dev\S*)\s+([a-zA-Z0-9-_.\/]+)/;    #TODO this regex is too simple
            %mounts = (@mounts);
        }
        return \%mounts;
    }

    sub battery_usages {
        local *sysfs_bat = sub {
            my $path = SYSFS_BAT . "/$_[0]";
            opendir( my $dh, $path );
            if ( $_[1] ) {
                my @dir = readdir $dh;
                for (@dir) {
                    $path .= "/" . $_ if /\Aenergy_full$|\Acharge_full$/ && $_[1] eq BAT_FULL;
                    $path .= "/" . $_ if /\Aenergy_now$|\Acharge_now$/   && $_[1] eq BAT_NOW;
                }
            }
            closedir $dh;
            $path;
        };

        my %results;
        my @bats = @{ batteries() };
        for (@bats) {
            my $bat = $_;
            open( my $f, '<', sysfs_bat( $bat, BAT_FULL ) );
            chomp( my $full = <$f> );
            open( $f, '<', sysfs_bat( $bat, BAT_NOW ) );
            chomp( my $now = <$f> );

            $results{$bat} = $now / $full * 100;
        }
        return \%results;
    }

    sub batteries {
        my @bats;
        opendir( my $dh, SYSFS_BAT );
        my @dir = readdir $dh;
        for (@dir) {
            my $bat = $_;
            next if (/\A\.\.?\z/);
            next if (/\AAC/);
            push @bats, $bat;
        }
        closedir $dh;
        return \@bats;
    }

    sub disks {
        opendir( my $dh, SYSFS_BLOCK );
        my @disks;
        my @dir = readdir $dh;
        for (@dir) {
            my $block = $_;
            next if (/\A\.\.?$|dm-|\Aloop|\Asr/);
            push @disks, $block;
        }
        closedir $dh;
        return \@disks;
    }

    sub dm_disks {
        opendir( my $dh, SYSFS_BLOCK );
        my %block;
        my @dir = readdir $dh;
        for (@dir) {
            my $block = $_;
            next if !(/\Adm-/);
            open( my $f, '<', SYSFS_BLOCK . "$block/dm/name" );
            chomp( my $d = <$f> );

            opendir( my $dh2, SYSFS_BLOCK . "$block/slaves" );
            $block{$d} = [ map {/(sd[a-z]|nvme\dn|mmcblk)/} readdir $dh2 ];
        }
        closedir $dh;
        return \%block;
    }

    sub disk_mounts {
        my @mounts = keys %{ mounts() };
        my @disks  = ( map { $_, 0 } @{ disks() } );
        my %dm     = %{ dm_disks() };
        my %disks  = @disks;

        for my $m (@mounts) {
            for my $k ( keys %disks ) {
                $disks{$k} = 1 if $m =~ /$k/;
            }
            while ( my ( $k, $v ) = each %dm ) {
                if ( $m =~ $k ) {
                    $disks{$_} = 1 for @$v;
                }
            }
        }

        @disks = ();
        while ( my ( $k, $v ) = each %disks ) {
            push @disks, $k if $v;
        }
        return \@disks;
    }

    sub cpu_usages {
        state %cpus;
        my $diff_usage = 0;
        my %results;

        open( my $f, '<', STAT );
        for (<$f>) {
            next if ( !/\Acpu[0-9]*\s+[0-9]+/ );

            my @cpu = split /\s+/;
            my $cpu = shift @cpu;

            if ( !exists $cpus{$cpu} ) {
                $cpus{$cpu}{$_} = 0 for qw/prev_idle prev_total diff_total/;
            }

            my $idle  = $cpu[3];
            my $total = sum(@cpu);

            my $diff_idle = $idle - $cpus{$cpu}{prev_idle};
            if ( $total != $cpus{$cpu}{prev_total} ) {
                $cpus{$cpu}{diff_total} = $total - $cpus{$cpu}{prev_total};
            }
            $diff_usage = 100 * ( $cpus{$cpu}{diff_total} - $diff_idle ) / $cpus{$cpu}{diff_total};

            $cpus{$cpu}{prev_idle}  = $idle;
            $cpus{$cpu}{prev_total} = $total;

            $results{$cpu} = $diff_usage;
        }
        return \%results;
    }

    sub cpu_count {
        open( my $f, '<', CPU_PRESENT );
        {
            local $/;
            my $cpus = <$f>;
            $cpus =~ /-([0-9]+)/;
            return $1 + 1;
        }
    }

    sub disk_usages {
        my %diff_usage;
        state( %results, $n_stat, $o_stat );
        state $t = urxvt::NOW- 1;
        my $ct      = urxvt::NOW;
        my $refresh = $ct - $t;
        $t = $ct;

        open( my $f, '<', DISKSTATS );
        for (<$f>) {
            if ( !/\bsd(a|b|c)|nvme\dn\d\b|mmcblk\d\b/ ) {
                next;
            }
            my @sda = split /\s+/, $_;
            shift @sda for 1 .. 3;

            my $name = shift @sda;
            my $stats;

            @$stats{qw/r_ios r_merged r_sectors r_time w_ios w_merged w_sectors w_time in_progress io_time weighted/} = (@sda);
            $o_stat->{$name} //= $stats;
            $n_stat->{$name} //= $stats;

            $o_stat->{$name} = $n_stat->{$name};
            $n_stat->{$name} = $stats;

            $diff_usage{$_} = $n_stat->{$name}->{$_} - $o_stat->{$name}->{$_} for ( keys %$stats );

            $diff_usage{io_time} = $diff_usage{io_time} / ( 1000 * $refresh ) * 100;
            $diff_usage{io_time} = 100 if $diff_usage{io_time} > 100;

            my $w = 0;
            $w = $diff_usage{'w_ios'} / $diff_usage{'r_ios'} if $diff_usage{'r_ios'} > 0;
            my $r = $w < 1 ? 1 - $w : 1 - 1 / $w;

            $r *= $diff_usage{io_time};
            $w *= $diff_usage{io_time};

            $results{$name}                   = $diff_usage{io_time};
            $results{ $name . POSTFIX_READ }  = $r;
            $results{ $name . POSTFIX_WRITE } = $w;
        }
        return \%results;
    }

    sub memory_usages {
        my @sda;
        my $total     = 0;
        my $available = 0;
        my %results;

        open( my $f, '<', MEMINFO );
        for (<$f>) {
            if (/\AMemTotal:\s+[0-9]+/) {
                @sda = split /\s+/, $_;
                $total = $sda[1];
            }
            if (/\AMemAvailable:\s+[0-9]+/) {
                @sda = split /\s+/, $_;
                $available = $sda[1];
            }
        }

        $results{ $sda[0] } = 100 - ( 100 * $available / $total );
        return \%results;
    }

    sub network_usages {
        my %results;
        my $bytes = 0;
        state %nics;
        state $t = urxvt::NOW- 1;
        my $ct      = urxvt::NOW;
        my $refresh = $ct - $t;
        $t = $ct;

        local *_set = sub {
            my $nic       = shift;
            my $direction = shift;
            open( my $f, '<', sysfs_net( $nic, $direction ) );
            {
                local $/;
                $bytes = <$f>;
            }

            my $diff_rx = $bytes - $nics{$nic}{$direction};
            $nics{$nic}{$direction} = $bytes;
            my $diff_usage = $diff_rx / ( network_speed($nic) * $refresh ) * 100;
            $results{ $nic . ( $direction eq RX ? POSTFIX_RX : POSTFIX_TX ) } = $diff_usage;
        };

        for ( @{ network_list() } ) {
            my $nic = $_;
            if ( !exists $nics{$nic} ) {
                $nics{$nic}{$_} = 0 for ( RX, TX );
            }
            _set( $nic, RX );
            _set( $nic, TX );

        }
        return \%results;
    }

    sub network_default {
        open( my $fh, '<', NET_ROUTE );

        my $if = <$fh>;
        $if = <$fh>;

        my @wif = split /\s+/, $if;
        $wif[0];
    }

    sub network_speed {
        my $if = shift;
        my $speed;
        state $refresh = 4;
        state $wifispeed;
        if ( has_wifi($if) ) {
            if ( $refresh >= 4 ) {
                $refresh = 0;
                my $c = qx/sudo iwconfig $if/;
                ($wifispeed) = $c =~ /Bit Rate.(\d*\.{0,1}\d*)/;
                $speed = $wifispeed;
            }
            else {
                $refresh++;
                $speed = $wifispeed;
            }
        }
        else {
            open( my $fh, '<', sysfs_net( $if, SPEED ) );
            $speed = <$fh>;
        }
        $speed *= 1000000 / 8;
        return $speed;
    }

    sub needs_refresh {
        my $r = shift;
        state $t = 0;
        my $ct = urxvt::NOW;

        return 0 if ( $ct - $t ) < $r;
        $t = $ct;
        1;
    }
}

package cdmn::resources::single {
    use Params::Validate qw(:all);
    use fields qw( name padding bg fg colors label length gauges style visual simple );

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        (%$s) = validate(
            @_,
            {   name    => 1,
                padding => 1,
                fg      => 1,
                bg      => 1,
                colors  => 1,
                label   => 1,
                length  => 1,
                gauges  => 1,
                simple  => 1,
                visual  => 1,
            }
        );

        return $s;
    }
}

package cdmn::resources {
    use Scalar::Util qw(looks_like_number);

    my %notset;
    use fields qw(
        x y padding showing showing_labels visual_alignment caption_bg actions graphs_length graphs configs
        label_network label_disk label_cpu label_memory label_battery label_battery_AC label_cpu_temp
        label_bg label_fg label_position label_padding
        gauges gauges_order gauges_bg gauges_colors gauges_invert
        gauges_batteries gauges_cpu_temps gauges_networks gauges_disks gauges_cpus gauges_memory
        network_tx network_rx disks_read disks_write disks
        cpu cpu_temp battery disk_mounts refresh sensitivity visual_style
        colors_network colors_disk colors_cpu colors_cpu_temp colors_memory colors_battery
        sidebar_header_fg sidebar_header_bg sidebar_fg sidebar_bg sidebar_boarder_fg sidebar_boarder_bg
    );

    use constant {
        POSTFIX_TX    => '_tx',
        POSTFIX_RX    => '_rx',
        POSTFIX_READ  => '_read',
        POSTFIX_WRITE => '_write',
    };

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        return $s;
    }

    sub init {
        my $s = shift;
        my $t = shift;

        local *_set_list = sub {
            my $r = $t->x_resource("$_[0]");
                  $r    ? [ split( /[,[:space:]]/, $r ) ]
                : $_[1] ? [ split( /[,[:space:]]/, $_[1] ) ]
                :         [ () ];
        };

        local *_set_number = sub {
            my $n = $t->x_resource("$_[0]");
            looks_like_number($n) ? $n : $_[1];
        };

        $s->{label_network}  = $t->x_resource('%.label.network')  // 'NET';
        $s->{label_disk}     = $t->x_resource('%.label.disk')     // 'DISK';
        $s->{label_cpu}      = $t->x_resource('%.label.cpu')      // 'CPU';
        $s->{label_cpu_temp} = $t->x_resource('%.label.cpu.temp') // 'TEMP';
        $s->{label_memory}   = $t->x_resource('%.label.memory')   // 'MEM';
        $s->{label_battery}  = $t->x_resource('%.label.battery')  // 'BAT';
        $s->{label_battery_AC} = $s->{label_battery} . "(⌁)";
        $s->{label_fg}         = _set_number( '%.label.fg', 0 );
        $s->{label_bg}         = _set_number( '%.label.bg', 1 );
        $s->{label_position}   = $t->x_resource('%.label.position') || 'left';
        $s->{label_padding}    = _set_number( '%.label.padding', 0 );

        $s->{showing}        = _set_number( '%.showing',        1 );
        $s->{showing_labels} = _set_number( '%.showing.labels', 1 );

        $s->{visual_alignment} = $t->x_resource('%.visual.alignment') // 'row';    #row | col
        $s->{caption_bg} = _set_number( '%.caption.bg', 1 );                       # 0/1 map onto terminal fg/bg color

        $s->{cpu}      = $t->x_resource('%.cpu')      // 'simple';                 #simple | detail
        $s->{cpu_temp} = $t->x_resource('%.cpu.temp') // 'simple';                 #simple | detail
        $s->{battery}  = $t->x_resource('%.battery')  // 'simple';                 #simple | detail
        $s->{padding}     = _set_number( '%.padding',     2 );                     #Padding between visuals
        $s->{x}           = _set_number( '%.x',           -1 );                    #positive from left, negativ from right
        $s->{y}           = _set_number( '%.y',           0 );                     #positive from top, negativ from bottom
        $s->{disk_mounts} = _set_number( '%.disk.mounts', 1 );                     #TODO rename
        $s->{refresh}     = _set_number( '%.refresh',     1 );
        $s->{sensitivity} = _set_number( '%.sensitivity', 1 );                     #percentage
        $s->{visual_style} = $t->x_resource('%.visual.style') // 'bar';            #bar | led | graph

        $s->{gauges_order}     = _set_list('%.gauges.order');
        $s->{disks}            = _set_list('%.gauges.disks');
        $s->{disks_read}       = _set_list('%.gauges.disks.read');
        $s->{disks_write}      = _set_list('%.gauges.disks.write');
        $s->{gauges_batteries} = _set_list('%.gauges.batteries');
        $s->{gauges_cpu_temps} = _set_list('%.gauges.cores');
        $s->{network_rx}       = _set_list('%.network.rx');
        $s->{network_tx}       = _set_list('%.network.tx');
        $s->{gauges_invert}    = _set_list( '%.gauges.invert', 'BAT' );
        $s->{gauges_memory}    = ["MemAvailable:"];

        $s->{graphs} = _set_list('%.graphs');
        $s->{graphs_length} = _set_number( '%.graphs.width', 0 );

        $s->{gauges_colors} = _set_list( '%.gauges.colors', '-1,-2' );
        $s->{"colors_$_"} = _set_list("%.colors.$_") for (qw/network disk cpu cpu_temp memory battery/);

        $s->{sidebar_header_fg}  = _set_number( '%.sidebar.header.fg',  -2 );
        $s->{sidebar_header_bg}  = _set_number( '%.sidebar.header.bg',  -1 );
        $s->{sidebar_fg}         = _set_number( '%.sidebar.fg',         -2 );
        $s->{sidebar_bg}         = _set_number( '%.sidebar.bg',         -1 );
        $s->{sidebar_boarder_fg} = _set_number( '%.sidebar.boarder.fg', -2 );
        $s->{sidebar_boarder_bg} = _set_number( '%.sidebar.boarder.bg', -1 );

        $notset{disks}            = scalar @{ $s->{disks} }            ? 0 : 1;
        $notset{network_rx}       = scalar @{ $s->{network_rx} }       ? 0 : 1;
        $notset{network_tx}       = scalar @{ $s->{network_tx} }       ? 0 : 1;
        $notset{gauges_cpu_temps} = scalar @{ $s->{gauges_cpu_temps} } ? 0 : 1;

        $s->set_disks;
        $s->set_batteries;
        $s->set_cores;
        $s->set_nics;
        $s->set_order;
        $s->set_invert;
        $s->set_colors;
        $s->set_graphs;

        for (qw/network disk cpu cpu_temp memory battery/) {
            ( my $t = $_ ) =~ s/y$/ie/;
            $s->{configs}{$_} = cdmn::resources::single->new(
                name    => $_,
                padding => 1,
                fg      => $s->{label_fg},
                bg      => $s->{label_bg},
                colors  => $s->{"colors_$_"},
                label   => $s->{"label_$_"},
                length  => $s->{graphs}{$_} ? $s->{graphs_length} : 0,
                gauges  => $_ eq 'memory' ? $s->{"gauges_${_}"} : $s->{"gauges_${t}s"},
                simple  => exists $s->{$_} ? $s->{$_} eq 'simple' : 0,
                visual  => $s->{visual_style},
            );
        }
    }

    sub configs {
        my ( $s, $t ) = @_;
        $s->{configs}{$t}{label} = cdmn::proc::ac_online() ? $s->{label_battery_AC} : $s->{label_battery}, $s->colors($_) if $t eq 'battery';
        return $s->{configs}{$t};
    }

    sub colors {
        my $s = shift;
        return $s->{ "colors_" . (shift) };
    }

    my $validate = sub {
        my $s             = shift;
        my @order_default = map { $s->{$_} } (qw/ label_cpu label_cpu_temp label_disk label_memory label_network label_battery /);
        my %gauges        = map { $_ => 0 } @order_default;
        $gauges{$_} = 1 for $_[0];

        return \@order_default if scalar @{ $_[0] } eq 0;
        return cdmn::utils::cut_set( $_[0], \@order_default );
    };

    sub set_cores {
        my $s    = shift;
        my $cpus = cdmn::proc::cpu_count() - 1;
        $s->{gauges_cpus} = [ map "cpu" . $_, 0 .. $cpus ];
    }

    sub set_order {
        my $s = shift;
        $s->{gauges_order} = $validate->( $s, $s->{gauges_order} );
        $s->{gauges_order} = $s->remap( $s->{gauges_order} );
        1;
    }

    sub set_graphs {
        my $s = shift;
        $s->{graphs} = $validate->( $s, $s->{graphs} );
        $s->{graphs} = { map { $_ => 1 } @{ $s->remap( $s->{graphs} ) } };
        1;
    }

    sub remap {
        my $s = shift;
        my @remap;
        my %l = (
            $s->{label_cpu}      => 'cpu',
            $s->{label_disk}     => 'disk',
            $s->{label_memory}   => 'memory',
            $s->{label_network}  => 'network',
            $s->{label_cpu_temp} => 'cpu_temp',
            $s->{label_battery}  => 'battery',
        );
        push @remap, $l{$_} for ( @{ +shift } );
        return \@remap;
    }

    sub set_invert {
        my $s = shift;
        $s->{gauges_invert} = $validate->( $s, $s->{gauges_invert} );
        1;
    }

    sub set_nics {
        my $s           = shift;
        my $nics_active = cdmn::proc->network_list;
        my $ov          = $s->{gauges_networks} ? scalar @{ $s->{gauges_networks} } : 0;

        my $rx_tx = cdmn::utils::cut_set( $s->{network_tx}, $nics_active );
        my @tx = map { $_ . POSTFIX_TX } @$rx_tx;

        $rx_tx = cdmn::utils::cut_set( $s->{network_rx}, $nics_active );
        my @rx = map { $_ . POSTFIX_RX } @$rx_tx;

        if ( ( scalar @tx eq 0 and scalar @rx eq 0 ) || ( $notset{network_rx} && $notset{network_tx} ) ) {
            $s->{gauges_networks} = [ map { $_ . POSTFIX_RX, $_ . POSTFIX_TX } @$nics_active ];
        }
        else { $s->{gauges_networks} = [ @rx, @tx ]; }
        $ov != scalar @{ $s->{gauges_networks} } ? 1 : 0;
    }

    sub set_disks {
        my $s = shift;
        my $ov = $s->{gauges_disks} ? scalar @{ $s->{gauges_disks} } : 0;

        $s->{gauges_disks}
            = $s->{disk_mounts}
            ? cdmn::utils::cut_set( cdmn::proc::disk_mounts, $s->{disks} )
            : cdmn::utils::cut_set( cdmn::proc::disks,       $s->{disks} );

        my $rw
            = $s->{disk_mounts}
            ? cdmn::utils::cut_set( cdmn::proc::disk_mounts, $s->{disks_read} )
            : cdmn::utils::cut_set( cdmn::proc::disks,       $s->{disks_read} );

        my @r = map { $_ . POSTFIX_READ } @$rw;

        $rw
            = $s->{disk_mounts}
            ? cdmn::utils::cut_set( cdmn::proc::disk_mounts, $s->{disks_write} )
            : cdmn::utils::cut_set( cdmn::proc::disks,       $s->{disks_write} );

        my @w = map { $_ . POSTFIX_WRITE } @$rw;

        $s->{gauges_disks} = $s->{disk_mounts} ? cdmn::proc::disk_mounts : cdmn::proc::disks
            if $notset{disks} && scalar @r eq 0 && scalar @w eq 0;

        push @{ $s->{gauges_disks} }, ( @r, @w );

        $ov != scalar @{ $s->{gauges_disks} } ? 1 : 0;
    }

    sub set_colors {
        my $s = shift;
        for my $h (qw(network disk cpu cpu_temp memory battery)) {
            $s->{"colors_$h"}
                = [ map { $_ + 2 } grep ( looks_like_number($_), ( @{ $s->{"colors_$h"} } ? @{ $s->{"colors_$h"} } : @{ $s->{gauges_colors} } ) ) ];
        }
        1;
    }

    for my $h (qw(batteries cpu_temps)) {
        ## no critic
        eval qq{
            sub set_$h {
                my \$s = shift;
                my \$ov = \$s->{gauges_$h} ? scalar \@{\$s->{gauges_$h}} : 0;
                \$s->{gauges_$h} = cdmn::utils::cut_set(cdmn::proc::$h, \$s->{gauges_$h});
                \$s->{gauges_$h} = cdmn::proc::$h if scalar \@{\$s->{gauges_$h}} eq 0 || \$notset{gauges_$h};
                \$ov != scalar \@{\$s->{gauges_$h}} ? 1 : 0;
            }
        }
    }
}

package cdmn::sidebar {
    use Params::Validate qw(:all);
    use POSIX qw(ceil floor);

    use constant { REND => cdmn::constants::REND, };

    use fields qw(term width panes data active_pane visible order bg fg bg_header fg_header bg_boarder fg_boarder);

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        (%$s) = validate(
            @_,
            {   term       => 1,
                width      => { default => 32 },
                visible    => { default => 0 },
                bg         => 1,
                fg         => 1,
                bg_header  => 1,
                fg_header  => 1,
                bg_boarder => 1,
                fg_boarder => 1,
            }
        );
        $s->{data}  = ();
        $s->{order} = ();

        return $s;
    }

    sub hide {
        my $s = shift;
        ($s)->{term}->hide;
        $s->{visible} = 0;
    }

    sub show {
        my $s = shift;
        $s->{term}->show;
        $s->{visible} = 1;
    }

    sub hide_cursor {
        (shift)->{term}->hide_cursor;
    }

    sub toggle {
        my $s = shift;
        $s->{visible} = !$s->{visible};
        $s->{term}->toggle;
        $s->show_pane( $s->{order}[ $s->{active_pane} ] );
    }

    sub bounds {
        (shift)->{term}->bounds(@_);
    }

    sub show_pane {
        my ( $s, $title ) = (@_);
        return if !$s->{visible};
        my $data = $s->{panes}{$title};
        for ( my $j = 0; $j < @$data; $j++ ) {
            $$data[$j]->show if $$data[$j]->{y} < $s->{term}->nrow;
        }
    }

    sub hide_pane {
        my ( $s, $title ) = (@_);
        return if !$s->{visible};
        my $data = $s->{panes}{$title};

        for ( my $j = 0; $j < @$data; $j++ ) {
            $$data[$j]->hide;
        }
    }

    sub set_pane {
        my ( $s, $title, $args ) = (@_);
        $s->{panes}{$title} = $s->create_pane( $title, $args );
        $s->{data}{$title} = $args;
        $s->show_pane($title) if $title eq $s->{order}[ $s->{active_pane} ];
        1;
    }

    sub next_pane {
        my $s = shift;
        my $i = $s->{active_pane};
        $s->hide_pane( $s->{order}[$i] );
        $i++;
        $i = 0 if $i ge scalar @{ $s->{order} };
        $s->{active_pane} = $i;
        $s->show_pane( $s->{order}[$i] );
    }

    sub prev_pane {
        my $s = shift;
        my $i = $s->{active_pane};
        $s->hide_pane( $s->{order}[$i] );
        $i--;
        $i = scalar @{ $s->{order} } - 1 if $i lt 0;
        $s->{active_pane} = $i;
        $s->show_pane( $s->{order}[$i] );
    }

    sub add_pane {
        my ( $s, $title, $args ) = (@_);
        $s->{panes}{$title} = $s->create_pane( $title, $args );
        $s->{data}{$title} = $args;
        push @{ $s->{order} }, $title;
        1;
    }

    sub create_pane {
        my @data;
        my $s     = shift;
        my $title = shift;
        my $args  = shift;
        my $r     = urxvt::SET_FGCOLOR REND, $s->{fg_boarder};

        #border
        $data[0] = cdmn::visuals::overlay->new(
            term      => $s->{term},
            x         => 0,
            y         => 0,
            width     => 1,
            height    => $s->{term}->nrow,
            rendition => $r,
            text      => "│"
        );

        $r = urxvt::SET_FGCOLOR REND, $s->{fg_header};
        $r = $r | urxvt::RS_Uline;

        my $i = 1;

        #title
        push @data,
            cdmn::visuals::overlay->new(
            term      => $s->{term},
            x         => -1,
            y         => $i++,
            width     => $s->{width},
            height    => 1,
            rendition => $r,
            text      => $title
            );

        $r = urxvt::SET_FGCOLOR REND, $s->{fg};
        for ( sort keys %$args ) {
            $i++;
            push @data,
                cdmn::visuals::overlay->new(
                term      => $s->{term},
                x         => -1,
                y         => $i++,
                width     => $s->{width},
                height    => 1,
                rendition => $r,
                text      => $_
                );
            my $c = ceil( 25 * $args->{$_} / 100 );
            my $f = $c <= 25 ? 25 - $c : 0;    #should only be necessary on startup
            push @data,
                cdmn::visuals::overlay->new(
                term      => $s->{term},
                x         => -1,
                y         => $i++,
                width     => $s->{width},
                height    => 1,
                rendition => $r,
                text      => "■" x $c . "□" x $f . " " . ceil( $args->{$_} ) . "%"
                );
        }
        for ( my $j = 0; $j < @data; $j++ ) {
            $data[$j]->create();
        }
        return \@data;
    }
}

package cdmn::term {
    use Params::Validate qw(:all);

    use fields qw(x y w h term parent bg_color content is_root resource maximized);

    use constant {
        REND                    => cdmn::constants::REND,
        ACTION_SHOW             => cdmn::constants::ACTION_SHOW,
        ACTION_SHOW_SIDEBAR     => cdmn::constants::ACTION_SHOW_SIDEBAR,
        ACTION_SHOW_TRANSPARENT => cdmn::constants::ACTION_SHOW_TRANSPARENT,
        ACTION_SHOW_LABELS      => cdmn::constants::ACTION_SHOW_LABELS,
        ACTION_NEXT_PANE        => cdmn::constants::ACTION_NEXT_PANE,
        ACTION_PREV_PANE        => cdmn::constants::ACTION_PREV_PANE,
    };

    my @terminals;
    my $root;

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        (%$s) = validate(
            @_,
            {   parent   => 1,
                resource => 1,
                bg_color => 1,
                is_root  => 1,
                x        => { default => 1 },
                y        => { default => 1 },
                w        => { default => 1 },
                h        => { default => 1 }
            }
        );

        #(%$s) = @_;
        #@$s{qw/x y w h/} // 1;

        push @urxvt::TERM_INIT, sub {
            my ($term) = @_;
            $term->{termclass} = $s;
            $term->{parent} = $s->{parent} if $s->{is_root};
            $term->resource( perl_ext_2 => "-cdmn" );    #TODO remove magic name
        };

        push @urxvt::TERM_EXT, __PACKAGE__;

        my $environ = $s->{parent}->env;
        $environ->{SHELL} = 'sh' if !$s->{is_root};

        #$s->{term} = new urxvt::term( $environ, $urxvt::RXVTNAME, -embed => $s->{parent}->parent, -depth => 32, -bg =>6 );
        $s->{term} = new urxvt::term( $environ, $urxvt::RXVTNAME, -embed => $s->{parent}->parent, -depth => 32 );
        $s->bounds( @$s{qw/x y w h/} );
        $s->{is_root} ? $root = $s : push( @terminals, $s );

        $s;
    }

    sub on_user_command {
        (shift)->{term}{termclass}{parent}->user_command(@_);
        1;
    }

    sub on_init {
        my $s = shift;
        $s->bind_action( 'M-h', 'perl:' . ACTION_SHOW );
        $s->bind_action( 'M-p', 'perl:' . ACTION_SHOW_SIDEBAR );
        $s->bind_action( 'M-o', 'perl:' . ACTION_SHOW_TRANSPARENT );
        $s->bind_action( 'M-l', 'perl:' . ACTION_SHOW_LABELS );
        $s->bind_action( 'M-k', 'perl:' . ACTION_NEXT_PANE );
        $s->bind_action( 'M-j', 'perl:' . ACTION_PREV_PANE );
        ();
    }

    sub on_tt_write {
        if ( !(shift)->{term}{parent} ) {
            $root->{term}->tt_write(shift);
            1;
        }
        ();
    }

    sub on_refresh_begin {
        my $s = shift;
        if ( !$s->{term}{parent} ) {
            my $str = $s->{term}->locale_encode("\e[0;0H\e[K");
            $s->{term}->cmd_parse($str);    #do not show the cursor!
            1;
        }
        ();
    }

    sub bounds {
        my $s = shift;
        @$s{qw/x y w h/} = validate_pos( @_, 1, 1, 1, 1 );
        $s->{term}->XMoveResizeWindow( $s->{term}->parent, @_ );
    }

    sub on_destroy {
        exit;
        1;
    }

    sub hide_cursor {
        (shift)->{term}->cmd_parse("\033[?25l");
    }

    sub hide {
        my $s = shift;
        $s->{term}->XUnmapWindow( $s->{term}->parent );
    }

    sub show {
        my $s = shift;
        $s->{term}->XMapWindow( $s->{term}->parent );
    }

    sub toggle {
        my $s = shift;
        $s->{term}->mapped ? $s->hide : $s->show;
    }
}

package cdmn::visuals::container {
    use fields qw( term rendition padding align even_gauges x y bg_color label_pos graph_data graph  );
    use fields qw( gauges visible bg bg_visible label_visible simple_gauges width height );
    use Params::Validate qw(:all);

    use constant {
        TRUE      => 1,
        FALSE     => 0,
        ALIGN_ROW => cdmn::constants::ALIGN_ROW,
        ALIGN_COL => cdmn::constants::ALIGN_COL,
        REND      => cdmn::constants::REND,
    };

    my ( $xOff, $yOff, $m ) = ( 0, 0, 0 );

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        (%$s) = validate(
            @_,
            {   term        => 1,
                rendition   => 1,
                x           => 1,
                y           => 1,
                padding     => 1,
                align       => 1,
                even_gauges => 1,
                visible     => 1,
                bg_color    => 1,
                label_pos   => 1,
            }
        );

        ( $xOff, $yOff ) = ( 0, $s->{y} );
        $s;
    }

    sub add {
        my $s = shift;
        my (%arg) = validate(
            @_,
            {   label         => 1,
                padding       => 1,
                gauges        => 1,
                label_bg      => 1,
                label_fg      => 1,
                gauges_colors => 1,
                gauges_bg     => 1,
                visual_style  => 1,
                sensitivity   => 1,
                name          => 1,
                simple        => 1,
                graph         => { default => 0 },
            }
        );

        my $visual = cdmn::visuals::visual->new(
            term          => $s->{term},
            rendition     => $s->{rendition},
            x             => $xOff,
            y             => $yOff,
            label         => $arg{label},
            gauges        => $arg{graph} ? [ 0 .. $arg{graph} * ( scalar @{ $arg{gauges} } ) - 1 ] : $arg{gauges},
            label_bg      => $arg{label_bg},
            label_fg      => $arg{label_fg},
            gauges_colors => $arg{gauges_colors},
            gauges_bg     => $arg{gauges_bg},
            visual_style  => $arg{visual_style},
            sensitivity   => $arg{sensitivity},
            label_pos     => $s->{label_pos},
            padding       => $arg{padding},
        );

        $s->{simple_gauges}{ $arg{name} } = $arg{simple};
        $s->{graph}{ $arg{name} }         = $arg{graph};

        local *_pad = sub {
            for ( values %{ $s->{gauges} } ) {
                my $c = scalar @{ $_->{gauges} };
                return if $c <= $m;
                $m = $c;
                $_->even_gauges($c);
                $xOff += $visual->{width} if $s->{align} eq ALIGN_ROW;
            }
        };

        if ( $s->{even_gauges} ) {
            _pad( length $arg{label} ) if $s->{label_pos} eq 'right';
            _pad( scalar @{ $arg{gauges} } ) if $s->{label_pos} eq 'left';
        }

        $visual->even_gauges($m) if $s->{even_gauges};
        $xOff += $visual->{width} + $s->{padding}  if $s->{align} eq ALIGN_ROW;
        $yOff += $visual->{height} + $s->{padding} if $s->{align} eq ALIGN_COL;
        $s->{gauges}{ $arg{name} } = $visual;
    }

    sub create {
        my $s = shift;
        my $l = 0;

        for ( values %{ $s->{gauges} } ) {
            $l = $_->{width} if $l < $_->{width};
        }

        for ( values %{ $s->{gauges} } ) {
            if ( $s->{x} < 0 ) {
                $_->{x} = $s->{term}->ncol - $xOff + $_->{x} + $s->{x} + $s->{padding} + 1 if ( $s->{align} eq ALIGN_ROW );
                $_->{x} = $s->{term}->ncol - $_->{x} - $_->{width} if ( $s->{align} eq ALIGN_COL );
            }
            else {
                $_->{x} += $s->{x} if $s->{align} eq ALIGN_ROW;
                $_->{x} = $l - $_->{width} if ( $s->{align} eq ALIGN_COL );
            }
            if ( $s->{y} < 0 ) {
                $_->{y} = $s->{term}->nrow - $yOff + $_->{y} + $s->{y} + $s->{padding} + 1 if ( $s->{align} eq ALIGN_COL );
            }
        }

        $_->create for values %{ $s->{gauges} };

        $s->{width} = $s->{align} eq ALIGN_ROW ? $xOff - $s->{padding} : $l;
        $s->{height} = $s->{align} eq ALIGN_ROW ? 1 : $yOff - $s->{padding} + 1;

        #Background
        $s->{bg} = cdmn::visuals::overlay->new(
            term   => $s->{term},
            x      => $s->{x},
            y      => $s->{y},
            width  => $s->{width},
            height => $s->{height},

            #rendition => urxvt::SET_BGCOLOR REND, 4,
            rendition => urxvt::SET_BGCOLOR REND,
            $s->{bg_color},
        );

        $s->{bg}->create("show");
        $s->{bg_visible} = 1;

        my $w = 0;
        for ( values %{ $s->{gauges} } ) { $w = $_->{width} if $_->{width} > $w; }
        $s->{width} = $w * $s->{term}->fwidth;
        $s->{height} = $yOff + ( $s->{padding} * ( $yOff - 1 ) * $s->{term}->fheight );
    }

    sub set {
        my ( $s, $name, $usage, $invert ) = validate_pos( @_, 1, 1, 1, 1 );
        my $total = 0;

        if ( $s->{graph}{$name} ) {
            my $graph_count = $s->{graph}{$name};

            for ( keys %$usage ) {
                $s->{graph_data}{$name}{$_} = [ (0) x $graph_count ] if !$s->{graph_data}{$name}{$_};
                shift @{ $s->{graph_data}{$name}{$_} };
                push( @{ $s->{graph_data}{$name}{$_} }, $usage->{$_} );
                $total += $usage->{$_};
            }
            $total /= scalar keys %$usage;

            $s->{graph_data}{$name}{'simple'} = [ (0) x $graph_count ] if !$s->{graph_data}{$name}{'simple'};
            shift @{ $s->{graph_data}{$name}{'simple'} };
            push @{ $s->{graph_data}{$name}{'simple'} }, $total;

            my %t;
            my $key = 0;
            for ( sort keys %{ $s->{graph_data}{$name} } ) {
                for ( @{ $s->{graph_data}{$name}{ $s->{simple_gauges}{$name} ? 'simple' : $_ } } ) {
                    $t{ $key++ } = $_;
                }
            }
            $usage = \%t;
        }

        if ( $s->{visible} && $s->{gauges}{$name} ) {
            if ( $s->{simple_gauges}{$name} and !$s->{graph}{$name} ) {
                $total += $_ for values %$usage;
                $total /= scalar keys %$usage;
                $s->{gauges}{$name}->set( 'simple', $total, $invert );
            }
            else {
                while ( my ( $key, $value ) = each %$usage ) {
                    $s->{gauges}{$name}->set( $key, $value, $invert );
                }
            }
        }

        $s->refresh_bg;
    }

    sub show {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        $visible ? $_->show : $_->hide for values %{ $s->{gauges} };
        $visible ? $s->show_labels : $s->hide_labels;

        $visible ? $s->show_bg : $s->hide_bg;
        $s->{visible} = $visible;
    }

    sub hide { (shift)->show(FALSE); }

    sub toggle {
        my $s = shift;
        $s->{visible} ? $s->hide : $s->show;
    }

    sub show_labels {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        for ( values %{ $s->{gauges} } ) {
            $visible ? $_->show_label : $_->hide_label;
        }

        $s->refresh_bg;
        $s->{label_visible} = $visible;
    }

    sub hide_labels { (shift)->show_labels(FALSE); }

    sub show_bg {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        $visible ? $s->{bg}->show : $s->{bg}->hide;
        $s->{bg_visible} = $visible;
    }

    sub refresh_bg {
        my $s = shift;
        if ( $s->{bg_visible} ) {
            $s->hide_bg;
            $s->show_bg;
        }
    }

    sub hide_bg { (shift)->show_bg(FALSE); }
}

package cdmn::visuals::visual {
    use List::Util qw(max);
    use Params::Validate qw(:all);

    use fields qw( term rendition x y label gauges label_bg label_fg gauges_colors gauges_bg visual_style sensitivity label_pos padding);
    use fields qw( count width height width_add);

    use constant BLOCKS => [qw/_ ▁ ▂ ▃ ▄ ▅ ▆ ▇ █/];

    #use constant LED => '⬛';
    use constant LED => '■';
    use constant { TRUE => 1, FALSE => 0 };
    use constant {
        ALIGN_ROW => cdmn::constants::ALIGN_ROW,
        STYLE_BAR => cdmn::constants::STYLE_BAR,
        STYLE_LED => cdmn::constants::STYLE_LED,
    };

    my $m = 0;

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        (%$s) = validate(
            @_,
            {   term          => 1,
                rendition     => 1,
                x             => 1,
                y             => 1,
                label         => 1,
                gauges        => 1,
                label_bg      => 1,
                label_fg      => 1,
                gauges_colors => 1,
                gauges_bg     => 1,
                visual_style  => 1,
                sensitivity   => 1,
                label_pos     => 1,
                padding       => 1,
            }
        );

        $s->{width} = ( length $s->{label} ) + $s->{padding} + @{ $s->{gauges} };

        $s->{height}    = 1;
        $s->{width_add} = 0;
        return $s;
    }

    sub even_gauges {
        my ( $s, $max ) = @_;
        my $l = length $s->{label};

        $s->{width} -= $s->{width_add};
        $s->{width_add} = $max - @{ $s->{gauges} } if $s->{label_pos} eq 'left';
        $s->{width_add} = $l > 0 ? $max - $l : 0 if $s->{label_pos} eq 'right';
        $s->{width} += $s->{width_add};
    }

    sub create {
        my $s      = shift;
        my $w      = ( length $s->{label} );
        my @gauges = @{ $s->{gauges} };

        $s->{gauges} = {};
        $s->{x} = -( $w + $m ) if $s->{x} < 0;
        my $x = $s->{x};

        local *_label = sub {
            $s->{rendition} = urxvt::SET_COLOR $s->{rendition}, $s->{label_fg}, $s->{label_bg};
            my $labelObj = cdmn::visuals::overlay->new(
                term      => $s->{term},
                x         => $x,
                y         => $s->{y},
                width     => $w,
                height    => $s->{height},
                rendition => $s->{rendition},
                text      => $s->{label}
            );
            $labelObj->create("show");
            $s->{label} = $labelObj;
        };

        local *_gauges = sub {
            $s->{rendition} = urxvt::SET_BGCOLOR $s->{rendition}, $s->{gauges_bg};
            for my $i (@gauges) {
                for ( @{ $s->{gauges_colors} } ) {
                    $s->{rendition} = urxvt::SET_FGCOLOR $s->{rendition}, $_;
                    my $pictorial = cdmn::visuals::overlay->new(
                        term      => $s->{term},
                        x         => $x,
                        y         => $s->{y},
                        width     => 1,
                        height    => 1,
                        rendition => $s->{rendition},
                        text      => BLOCKS->[0],
                    );
                    $pictorial->create;
                    $s->{gauges}{"$i"}{"$_"} = $pictorial;
                }
                $x++;
            }
        };

        if ( $s->{label_pos} eq 'right' ) { _gauges(); $x++; _label(); }
        else                              { _label(); $x += $w + $s->{padding}; _gauges(); }
    }

    sub show {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        for ( values %{ $s->{gauges} } ) {
            for ( values %{$_} ) {
                $visible ? $_->show : $_->hide;
            }
        }
    }

    sub hide { (shift)->show(FALSE); }

    sub show_label {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        $visible ? $s->{label}->show : $s->{label}->hide;
    }

    sub hide_label {
        (shift)->show_label(FALSE);
    }

    sub set {
        my ( $s, $i, $usage, $invert ) = validate_pos( @_, 1, 1, 1, 1 );
        return if !$s->{gauges}{"$i"};

        my $size = scalar @{&BLOCKS};
        my $bar_i = ( $usage > 100 ? 100 : $usage ) / 100 * ($size);
        $usage = 100 - $usage if $invert;
        $bar_i -= 1 if $bar_i >= $size;
        $size = scalar @{ $s->{gauges_colors} };
        my $clr_i = ( $usage > 100 ? 100 : $usage ) / 100 * ( $size - 1 ) + 1;
        $clr_i -= 1 if $clr_i >= $size;
        my $color = $usage < $s->{sensitivity} ? $s->{gauges_colors}[1] : $s->{gauges_colors}[$clr_i];
        for ( values %{ $s->{gauges}{"$i"} } ) {
            $_->hide;
        }

        $s->{gauges}{"$i"}{"$color"}->set( BLOCKS->[$bar_i] ) if $s->{visual_style} eq STYLE_BAR;
        $s->{gauges}{"$i"}{"$color"}->set(LED) if $s->{visual_style} eq STYLE_LED;
        $s->{gauges}{"$i"}{"$color"}->show;
    }
}

package cdmn::visuals::overlay {
    use fields qw( term x y width height rendition text );
    use fields qw( overlay );

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        (%$s) = @_;
        $s;
    }

    sub create {
        my ( $s, $show ) = ( shift, shift );
        my ( $x, $y, $w, $h, $r, $c ) = ( $s->{x}, $s->{y}, $s->{width}, $s->{height}, $s->{rendition}, $s->{text} );

        $s->{overlay} = $s->{term}->overlay( $x, $y, $w, $h, $r, 0 );

        $s->set($c) if defined $c;
        $s->hide if !$show;
    }

    sub set {
        my $s = shift;
        $s->{text} = shift;
        $s->{overlay}->set( 0, 0, $s->{text} );
        for ( 0 .. $s->{height} ) {
            $s->{overlay}->set( 0, $_, $s->{text} ) if $s->{height} > 1;
        }
    }

    for my $h (qw(hide show)) {
        eval qq{ sub $h { my \$s = shift; \$s->{overlay}->$h; } };    ## no critic
    }
}

use constant XR => cdmn::resources->new();

my $SHOWING;
my $LABELS_SHOWING;

use constant {
    ACTION_SHOW             => cdmn::constants::ACTION_SHOW,
    ACTION_SHOW_LABELS      => cdmn::constants::ACTION_SHOW_LABELS,
    ACTION_SHOW_SIDEBAR     => cdmn::constants::ACTION_SHOW_SIDEBAR,
    ACTION_SHOW_TRANSPARENT => cdmn::constants::ACTION_SHOW_TRANSPARENT,
    ACTION_NEXT_PANE        => cdmn::constants::ACTION_NEXT_PANE,
    ACTION_PREV_PANE        => cdmn::constants::ACTION_PREV_PANE,
    ALIGN_COL               => cdmn::constants::ALIGN_COL,
    ALIGN_ROW               => cdmn::constants::ALIGN_ROW,
    REND                    => cdmn::constants::REND,
};

#-----------------------------------------------------------------------------------------------------------------------
#   HELPERS
#-----------------------------------------------------------------------------------------------------------------------

sub redraw {
    my ( $s, $showLabels ) = @_;
    my @visible = map { $$_->{visible} } @{ ( $s->{caption} ) };

    $s->{visuals_updater}->stop;
    $s->{caption}[0] = create_captions( $s->{xterms}{main}{term}, $showLabels );
    $s->{caption}[1] = create_captions( $s, $showLabels );

    while ( my ( $key, $item ) = each @{ ( $s->{caption} ) } ) {
        ${$item}->create;
        $visible[$key] ? ${$item}->show : ${$item}->hide;
    }

    #$s->{sidebar}->refresh_pane if $s->{sidebar}{visible};
    $s->{visuals_updater}->start;
}

sub calc_bounds {
    my ( $s, $t ) = @_;
    my ( $h, $w, $x, $y ) = ( 0, 0, $s->{x}, $s->{y} );

    if ( $t eq ALIGN_ROW ) {
        $h = $s->fheight * ( $s->nrow - 1 );
        $w = $s->width;
        $y = XR->{y} >= 0 ? $s->fheight : -1;
    }
    if ( $t eq ALIGN_COL ) {
        $h = $s->fheight * ( $s->nrow );
        $w = $s->width - ${ $s->{caption}[0] }->{width};
        $y = 0;
    }
    $x = 0;
    ( $h, $w, $x, $y );
}

#TODO why add 4 to w and h
sub refresh_bounds {
    my ( $s, $t ) = @_;
    my ( $h, $w, $x, $y ) = calc_bounds( $s, $t );

    if ( $s->{xterms}{main}{maximized} ) {
        $s->{xterms}{main}->bounds( 0, 0, $s->width + 4, $s->height + 4 );
    }
    else {
        $s->{xterms}{main}->bounds( $x, $y + 1, $w + 4, $h );
        $s->{xterms}{main}->bounds( XR->{x} >= 0 ? $s->width - $w : 0, 0, $w + 4, $h + 4 ) if XR->{visual_alignment} eq ALIGN_COL;

    }
    $s->{sidebar}->bounds( $s->width - $s->fwidth * 35 + 4, 0, $s->fwidth * 35, $s->height + 4 );

    #$s->{sidebar}->refresh_pane if $s->{sidebar}{visible};

}

sub create_captions {
    my ( $s, $showLabels ) = (@_);
    my $caption;

    local *_create = sub {
        my (%arg) = @_;

        local *_add = sub {
            my $c      = shift;
            my @colors = @{ $c->{colors} };
            $caption->add(
                label => $showLabels ? $c->{label} : '',
                padding       => XR->{label_padding},
                gauges        => $arg{ $c->{name} },
                label_bg      => XR->{label_bg},
                gauges_bg     => scalar @colors > 1 ? shift @colors : XR->{gauges_colors}->[0],
                label_fg      => XR->{label_fg},
                gauges_colors => $c->{colors},
                visual_style  => XR->{visual_style},
                sensitivity   => XR->{sensitivity},
                name          => $c->{name},
                simple        => $c->{simple},
                graph         => $c->{length},
            );
        };

        for ( @{ XR->{gauges_order} } ) {
            _add( XR->configs($_) ) if $arg{$_};
        }
    };

    for ( XR->{visual_alignment} ) {
        $caption = do {
            if ( $_ eq ALIGN_ROW ) {
                cdmn::visuals::container->new(
                    term        => $s,
                    rendition   => REND,
                    x           => XR->{x},
                    y           => XR->{y},
                    padding     => XR->{padding},
                    align       => $_,
                    even_gauges => 0,
                    visible     => XR->{showing},
                    bg_color    => XR->{caption_bg},
                    label_pos   => XR->{label_position},
                );
            }
            elsif ( $_ eq ALIGN_COL ) {
                cdmn::visuals::container->new(
                    term        => $s,
                    rendition   => REND,
                    x           => XR->{x},
                    y           => XR->{y},
                    padding     => XR->{padding},
                    align       => $_,
                    even_gauges => 1,
                    visible     => XR->{showing},
                    bg_color    => XR->{caption_bg},
                    label_pos   => XR->{label_position},
                );
            }
        };
    }

    my %args;
    $args{cpu_temp} = ( XR->{cpu_temp} eq 'simple' ? ["simple"] : XR->{gauges_cpu_temps} ) if @{ XR->{gauges_cpu_temps} } > 0;
    $args{cpu} = XR->{cpu} eq 'simple' ? ["simple"] : XR->{gauges_cpus};
    $args{disk}    = XR->{gauges_disks} if @{ XR->{gauges_disks} } > 0 || @{ XR->{disks_write} } > 0 || @{ XR->{disks_read} } > 0;
    $args{memory}  = XR->{gauges_memory};
    $args{network} = XR->{gauges_networks} if @{ XR->{gauges_networks} } > 0;
    $args{battery} = ( XR->{battery} eq 'simple' ? ["simple"] : XR->{gauges_batteries} ) if XR->{gauges_batteries} > 0;

    _create( (%args) );

    return \$caption;
}

#-----------------------------------------------------------------------------------------------------------------------
#   ACTIONS
#-----------------------------------------------------------------------------------------------------------------------

my %user_command;

#TODO why add 4 to w and h
$user_command{&ACTION_SHOW} = sub {
    my $s = shift;
    my ( $h, $w, $x, $y ) = calc_bounds( $s, XR->{visual_alignment} );

    if ( $s->{xterms}{main}{maximized} ) {
        $s->{xterms}{main}->bounds( $x, $y + 1, $w + 4, $h + 4 ) if XR->{visual_alignment} eq ALIGN_ROW;
        $s->{xterms}{main}->bounds( XR->{x} >= 0 ? $s->width - $w : 0, 0, $w + 4, $h + 4 ) if XR->{visual_alignment} eq ALIGN_COL;
        $s->{xterms}{main}{maximized} = 0;
        ${ $s->{caption}->[0] }->hide;
        $SHOWING = 1;
    }
    else {
        $s->{xterms}{main}->bounds( 0, 0, $s->width + 4, $s->height + 4 );
        $s->{xterms}{main}{maximized} = 1;
        $SHOWING = 0;
    }
};

$user_command{&ACTION_SHOW_TRANSPARENT} = sub {
    my $s = shift;
    if ( $s->{xterms}{main}{maximized} ) {
        my $c = ${ $s->{caption}->[0] };
        if ( $c->{visible} ) {
            $c->hide;
            $SHOWING = 0;
        }
        else {
            $c->show;
            $SHOWING = 1;
            redraw( $s, $LABELS_SHOWING );
            refresh_bounds( $s, XR->{visual_alignment} );
        }
    }
};

$user_command{&ACTION_SHOW_SIDEBAR} = sub {
    (shift)->{sidebar}->toggle;
};

$user_command{&ACTION_NEXT_PANE} = sub {
    (shift)->{sidebar}->next_pane;
};

$user_command{&ACTION_PREV_PANE} = sub {
    (shift)->{sidebar}->prev_pane;
};

$user_command{&ACTION_SHOW_LABELS} = sub {
    if ($SHOWING) {
        my $s = shift;
        $LABELS_SHOWING = !$LABELS_SHOWING;
        redraw( $s, $LABELS_SHOWING );
        refresh_bounds( $s, XR->{visual_alignment} );
    }
};

#-----------------------------------------------------------------------------------------------------------------------
#   RXVT HANDLERS
#-----------------------------------------------------------------------------------------------------------------------

sub user_command {
    my ( $s, $action ) = (@_);
    $user_command{$action}->($s);
    1;
}

sub on_refresh_begin {
    my ($s) = @_;
    my $nics_active = cdmn::proc->network_list;
    state $onAC = 0;
    state $nics = 0;
    if (   $s->{w_size} != $s->{term}->ncol
        || $s->{y_size} != $s->{term}->nrow
        || cdmn::proc::ac_online() != $onAC
        || $nics != scalar @$nics_active )
    {
        $onAC = !$onAC;
        $nics = scalar @$nics_active;

        XR->set_nics;
        redraw( $s, $LABELS_SHOWING );
        refresh_bounds( $s, XR->{visual_alignment} );
        $s->{w_size} = $s->{term}->ncol;
        $s->{y_size} = $s->{term}->nrow;
    }

    1;
}

sub on_refresh_end {
    my $s   = shift;
    my $str = $s->{term}->locale_encode("\e[0;0H\e[K");
    $s->{term}->cmd_parse($str);    #do not show the cursor!
    1;
}

sub on_configure_notify {
    my $s = shift;
    return if $s->{w_size} eq $s->{term}->ncol && $s->{y_size} eq $s->{term}->nrow;
    refresh_bounds( $s, XR->{visual_alignment} );
    1;
}

for my $h (qw(key_press key_release)) {
    ## no critic
    eval qq{
    sub on_$h {
        my (\$s, \$e) = \@_;
        \$s->{xterms}{main}{term}->$h (\$e->{state}, \$e->{keycode}, \$e->{time}); 1; }
    };
}

for my $h (qw(focus_in focus_out)) {
    eval qq{ sub on_$h { (shift)->{xterms}{main}{term}->$h; 1; } };    ## no critic
}

sub on_wm_delete_window {
    exit;
    1;
}

sub on_tt_write {
    (shift)->{xterms}{main}{term}->tt_write(shift);
    1;
}

#-----------------------------------------------------------------------------------------------------------------------
#   MAIN
#-----------------------------------------------------------------------------------------------------------------------

sub on_init {
    my ($s) = @_;
    XR->init($s);
    $SHOWING        = XR->{showing};
    $LABELS_SHOWING = XR->{showing_labels};
    ();
}

sub on_start {
    my ($s) = @_;

    $s->{xterms}{main} = cdmn::term->new(
        parent   => $s,
        resource => XR,
        bg_color => 4,
        is_root  => 1
    );

    $s->{xterms}{main}{maximized} = 1;
    my $st = cdmn::term->new(
        parent   => $s,
        resource => XR,
        x        => $s->width / 2,
        y        => 0,
        w        => $s->width / 2 + 1,
        h        => $s->fheight * ( $s->nrow ),
        bg_color => 5,
        is_root  => 0
    );

    $st->hide_cursor;
    $s->{sidebar} = cdmn::sidebar->new(
        term       => $st,
        fg         => XR->{sidebar_fg},
        bg         => XR->{sidebar_bg},
        bg_header  => XR->{sidebar_header_bg},
        fg_header  => XR->{sidebar_header_fg},
        fg_boarder => XR->{sidebar_boarder_fg},
        bg_boarder => XR->{sidebar_boarder_bg},
    );

    $s->{sidebar}->hide;
    $s->{xterms}{main}->show;

    #$s->{xterms}{main}->hide if ( XR->{visual_alignment} eq ALIGN_COL );

    $s->{w_size}     = $s->{term}->ncol;
    $s->{y_size}     = $s->{term}->nrow;
    $s->{caption}[0] = create_captions $s->{xterms}{main}{term};
    $s->{caption}[1] = create_captions $s;
    ${ $s->{caption}[0] }->create;
    ${ $s->{caption}[1] }->create;

    #$s->cmd_parse("\e[2T\e[2B"); #Scroll down and move cursor down 2 line.
    $s->cmd_parse("\033[?25l");    #do not show the cursor!

    #TODO WIP
    $s->{sidebar}->add_pane($_) for ( @{ XR->{gauges_order} } );
    $s->{sidebar}->add_pane('FS');
    $s->{sidebar}{active_pane} = 0;

    $s->{visuals_updater} = urxvt::timer->new->start( int urxvt::NOW )->interval( XR->{refresh} )->cb(
        sub {
            my %r;

            local *_filter = sub {
                my %r;
                my %d = %{ $_[0] };
                $r{$_} = $d{$_} for @{ $_[1] };
                %r;
            };

            redraw( $s, $LABELS_SHOWING ) if XR->set_disks | XR->set_batteries | XR->set_nics;

            my %usage_of;
            $usage_of{cpu}      = sub { _filter( cdmn::proc::cpu_usages(), XR->{gauges_cpus} ) };
            $usage_of{memory}   = sub { %{ cdmn::proc::memory_usages() } };
            $usage_of{cpu_temp} = sub { %{ cdmn::proc::cpu_temp_usages() } };
            $usage_of{battery}  = sub { %{ cdmn::proc::battery_usages() } };
            $usage_of{disk}     = sub { _filter( cdmn::proc::disk_usages(), XR->{gauges_disks} ) };
            $usage_of{network}  = sub { _filter( cdmn::proc::network_usages(), XR->{gauges_networks} ) };

            local *_set = sub {
                my $gauge_name = shift;
                my %inverts = map { $_ => 1 } @{ XR->{gauges_invert} };

                %r = $usage_of{$gauge_name}->();

                return 1 if scalar keys %r < 1;
                $s->{sidebar}->set_pane( $gauge_name, \%r );
                $$_->set( $gauge_name, \%r, $inverts{$gauge_name} ) for @{ $s->{caption} };

                1;
            };

            #for (qw/memory/) { _set($_); } #does not work, why?
            #for my $v (qw/memory/) { _set($_); } #works, why?
            #for my $v ( @{ XR->{gauges_order} } ) { _set($v) };

            _set($_) foreach keys %{ ${ $s->{caption}[0] }->{gauges} };

            my $mounts = cdmn::proc::mounts;
            %r = map { $_ => df($_)->{per} } ( sort values %$mounts );
            $s->{sidebar}->set_pane( 'FS', \%r ) if $s->{sidebar}{visible};
        }
    );
    refresh_bounds( $s, XR->{visual_alignment} );
    ();
}
