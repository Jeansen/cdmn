#! perl -T

# cdmn is an extension written for the rxvt terminal emulator that shows
# utilizations of different system resoureces like cpu, disk i/o, ram,
# network (and more).

# Copyright (C) 2016-2017 Marcel Lautenbach
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use 5.10.1;
use strict;
use warnings FATAL => 'all';
use autodie;

use utf8;
use autodie;

use Filesys::Df;
binmode STDOUT, ":encoding(UTF-8)";

package Null {
    my $null = bless {}, __PACKAGE__;
    sub AUTOLOAD {$null}
    sub ok       {0}
}

package cdmn::math {

    #return a ref. to anew set containing only the elements that exist in both given sets.
    sub cut_set {

        #TODO named parameters
        shift if scalar @_ > 2;    #drop first parameter if called as object
        my @cut = ();
        my %n   = ();

        for my $e ( @{ $_[0] }, @{ $_[1] } ) { $n{$e}++ }
        for my $e ( @{ $_[0] } ) { push @{ \@cut }, $e if $n{$e} > 1 }

        return \@cut;
    }
}

package cdmn::constants {
    use constant {
        ACTION_TOGGLE         => 'cdmn:show',
        ACTION_TOGGLE_LABELS  => 'cdmn:show-labels',
        ACTION_TOGGLE_SIDEBAR => 'cdmn:show-sidebar',
        ACTION_TOGGLE_OVERLAY => 'cdmn:action-show-transparent',

        ACTION_NEXT_PANE => 'cdmn:action-next-pane',
        ACTION_PREV_PANE => 'cdmn:action-prev-pane',

        VISUAL_ALIGN_COL => 'col',
        VISUAL_ALIGN_ROW => 'row',

        STYLE_LED => 'led',
        STYLE_BAR => 'bar',

        LEFT  => 'left',
        RIGHT => 'right',
    };

    use constant REND => urxvt::SET_COLOR urxvt::OVERLAY_RSTYLE, 255, 1;
}

package cdmn::proc {
    use List::Util qw(sum max min);
    use Params::Validate qw(:all);

    use constant {
        PROC_PARTITIONS => '/proc/partitions',
        PROC_MOUNTS     => '/proc/mounts',
        PROC_STAT       => '/proc/stat',
        PROC_DISKSTATS  => '/proc/diskstats',
        PROC_MEMINFO    => '/proc/meminfo',
        PROC_NET_ROUTE  => '/proc/net/route',

        SPEED     => 'speed',
        OPERSTATE => 'operstate',
        TX        => 'tx_bytes',
        RX        => 'rx_bytes',
        BAT_FULL  => 'full',
        BAT_NOW   => 'now',

        SYSFS_CPU_PRESENT => '/sys/devices/system/cpu/present',
        SYSFS_HWMON       => '/sys/class/hwmon/',
        SYSFS_NET         => '/sys/class/net/',
        SYSFS_BAT         => '/sys/class/power_supply/',
        SYSFS_BLOCK       => '/sys/block/',

        POSTFIX_TX    => '_tx',
        POSTFIX_RX    => '_rx',
        POSTFIX_READ  => '_read',
        POSTFIX_WRITE => '_write',
    };

    sub cpu_temp_usages {
        my %results;
        if ( -e SYSFS_HWMON ) {
            opendir( my $dh, SYSFS_HWMON );
            my @dir = readdir $dh;
            for (@dir) {
                next if $_ =~ /\A\.\.?\z/;
                my $p = SYSFS_HWMON . $_;
                open( my $f, '<', $p . "/name" ) || last;
                chomp( my $state = <$f> );
                if ( $state eq 'coretemp' ) {
                    opendir( $dh, $p );
                    @dir = readdir $dh;
                    my %cores = map { /(temp\d)/ ? ( ( $_ =~ /(temp\d)/ ), "" ) : () } @dir;
                    for ( keys %cores ) {
                        open( $f, '<', $p . "/" . $_ . "_input" );
                        chomp( my $cv = <$f> );
                        open( $f, '<', $p . "/" . $_ . "_crit" );
                        chomp( my $mv = <$f> );
                        open( $f, '<', $p . "/" . $_ . "_label" );
                        chomp( my $l = <$f> );
                        last if $l !~ /\ACore/;
                        $results{$l} = $cv / $mv * 100;
                    }
                    last;
                }
            }
            closedir $dh;
        }
        return \%results;
    }

    sub cores {
        my @results;
        opendir( my $dh, SYSFS_HWMON );
        my @dir = readdir $dh;
        for (@dir) {
            next if $_ =~ /\A\.\.?\z/;
            my $p = SYSFS_HWMON . $_;
            open( my $f, '<', $p . "/name" );
            chomp( my $state = <$f> );
            if ( $state eq 'coretemp' ) {
                opendir( $dh, $p );
                @dir = readdir $dh;
                my %cores = map { /(temp\d)/ ? ( ( $_ =~ /(temp\d)/ ), "" ) : () } @dir;
                for ( keys %cores ) {
                    open( $f, '<', $p . "/" . $_ . "_label" );
                    chomp( my $l = <$f> );
                    push @results, $l if $l =~ /\ACore/;
                }
                last;
            }
        }
        closedir $dh;
        return \@results;
    }

    sub sysfs_net {
        my $path = SYSFS_NET . "/$_[0]";
        return $path . "/statistics/$_[1]" if $_[1] && ( $_[1] eq TX        || $_[1] eq RX );
        return $path . "/$_[1]"            if $_[1] && ( $_[1] eq OPERSTATE || $_[1] eq SPEED );
        $path;
    }

    sub ac_online {
        opendir( my $dh, SYSFS_BAT );
        my @dir = readdir $dh;
        for (@dir) {
            if (/AC/) {
                open( my $f, '<', SYSFS_BAT . $_ . "/online" );
                chomp( my $state = <$f> );
                closedir $dh;
                return $state;
            }
        }
        closedir $dh;
        0;
    }

    sub has_wifi {
        opendir( my $dh, sysfs_net(shift) );
        my @dir = readdir $dh;
        for (@dir) { return 1 if (/wireless/); }
        closedir $dh;
        0;
    }

    sub network_down {
        open( my $f, '<', sysfs_net( shift, OPERSTATE ) );
        chomp( my $state = <$f> );

        # RFC2863 operational states: unknown notpresent down up lowerlayerdown testing dormant
        return 1 if $state =~ 'down|unknown';
        0;
    }

    sub network_list {
        my @ifs;
        opendir( my $dh, SYSFS_NET );
        my @dir = readdir $dh;
        for (@dir) {
            my $if = $_;
            next if (/\A\.\.?$|\Aveth/);
            if ( !has_wifi($if) ) {
                open( my $f, '<', sysfs_net( $if, SPEED ) );
                chomp( my @lines = <$f> );
                next if scalar @lines eq 0;
            }
            next if network_down($if);
            push @ifs, $if;
        }
        closedir $dh;
        return \@ifs;
    }

    sub mounts {
        open( my $f, '<', PROC_MOUNTS );
        my @mounts;
        my %mounts;
        for (<$f>) {
            push @mounts, /(\A\/dev\S*)\s+([a-zA-Z0-9-_.\/]+)/;    #TODO this regex is too simple
            %mounts = (@mounts);
        }
        return \%mounts;
    }

    sub battery_usages {
        local *sysfs_bat = sub {
            my $path = SYSFS_BAT . "/$_[0]";
            opendir( my $dh, $path );
            if ( $_[1] ) {
                my @dir = readdir $dh;
                for (@dir) {
                    $path .= "/" . $_ if /\Aenergy_full$|\Acharge_full$/ && $_[1] eq BAT_FULL;
                    $path .= "/" . $_ if /\Aenergy_now$|\Acharge_now$/   && $_[1] eq BAT_NOW;
                }
            }
            closedir $dh;
            $path;
        };

        my %results;
        my @bats = @{ batteries() };
        for (@bats) {
            my $bat = $_;
            open( my $f, '<', sysfs_bat( $bat, BAT_FULL ) );
            chomp( my $full = <$f> );
            open( $f, '<', sysfs_bat( $bat, BAT_NOW ) );
            chomp( my $now = <$f> );

            $results{$bat} = $now / $full * 100;
        }
        return \%results;
    }

    sub batteries {
        my @bats;
        opendir( my $dh, SYSFS_BAT );
        my @dir = readdir $dh;
        for (@dir) {
            my $bat = $_;
            next if (/\A\.\.?\z/);
            next if (/\AAC/);
            push @bats, $bat;
        }
        closedir $dh;
        return \@bats;
    }

    sub disks {
        opendir( my $dh, SYSFS_BLOCK );
        my @disks;
        my @dir = readdir $dh;
        for (@dir) {
            my $block = $_;
            next if (/\A\.\.?$|dm-|\Aloop|\Asr/);
            push @disks, $block;
        }
        closedir $dh;
        return \@disks;
    }

    sub dm_disks {
        opendir( my $dh, SYSFS_BLOCK );
        my %block;
        my @dir = readdir $dh;
        for (@dir) {
            my $block = $_;
            next if !(/\Adm-/);
            open( my $f, '<', SYSFS_BLOCK . "$block/dm/name" );
            chomp( my $d = <$f> );

            opendir( my $dh2, SYSFS_BLOCK . "$block/slaves" );
            $block{$d} = [ map {/(sd[a-z]|nvme\dn|mmcblk)/} readdir $dh2 ];
        }
        closedir $dh;
        return \%block;
    }

    sub disk_mounts {
        my @mounts = keys %{ mounts() };
        my @disks  = ( map { $_, 0 } @{ disks() } );
        my %dm     = %{ dm_disks() };
        my %disks  = @disks;

        for my $m (@mounts) {
            for my $k ( keys %disks ) {
                $disks{$k} = 1 if $m =~ /$k/;
            }
            while ( my ( $k, $v ) = each %dm ) {
                if ( $m =~ $k ) {
                    $disks{$_} = 1 for @$v;
                }
            }
        }

        @disks = ();
        while ( my ( $k, $v ) = each %disks ) {
            push @disks, $k if $v;
        }
        return \@disks;
    }

    sub cpu_usages {
        state %cpus;
        my $diff_usage = 0;
        my %results;

        open( my $f, '<', PROC_STAT );
        for (<$f>) {
            next if ( !/\Acpu[0-9]*\s+[0-9]+/ );

            my @cpu = split /\s+/;
            my $cpu = shift @cpu;

            if ( !exists $cpus{$cpu} ) {
                $cpus{$cpu}{$_} = 0 for qw/prev_idle prev_total diff_total/;
            }

            my $idle  = $cpu[3];
            my $total = sum(@cpu);

            my $diff_idle = $idle - $cpus{$cpu}{prev_idle};
            if ( $total != $cpus{$cpu}{prev_total} ) {
                $cpus{$cpu}{diff_total} = $total - $cpus{$cpu}{prev_total};
            }
            $diff_usage = 100 * ( $cpus{$cpu}{diff_total} - $diff_idle ) / $cpus{$cpu}{diff_total};

            $cpus{$cpu}{prev_idle}  = $idle;
            $cpus{$cpu}{prev_total} = $total;

            $results{$cpu} = $diff_usage;
        }
        return \%results;
    }

    sub cpu_count {
        open( my $f, '<', SYSFS_CPU_PRESENT );
        {
            local $/;
            my $cpus = <$f>;
            $cpus =~ /-([0-9]+)/;
            return $1 + 1;
        }
    }

    sub disk_usages {
        my %diff_usage;
        state( %results, $n_stat, $o_stat );
        state $t = urxvt::NOW- 1;
        my $ct      = urxvt::NOW;
        my $refresh = $ct - $t;
        $t = $ct;

        open( my $f, '<', PROC_DISKSTATS );
        for (<$f>) {
            if ( !/\bsd(a|b|c)|nvme\dn\d\b|mmcblk\d\b/ ) {
                next;
            }
            my @sda = split /\s+/, $_;
            shift @sda for 1 .. 3;

            my $name = shift @sda;
            my $stats;

            @$stats{qw/r_ios r_merged r_sectors r_time w_ios w_merged w_sectors w_time in_progress io_time weighted/} = (@sda);
            $o_stat->{$name} //= $stats;
            $n_stat->{$name} //= $stats;

            $o_stat->{$name} = $n_stat->{$name};
            $n_stat->{$name} = $stats;

            $diff_usage{$_} = $n_stat->{$name}->{$_} - $o_stat->{$name}->{$_} for ( keys %$stats );

            $diff_usage{io_time} = $diff_usage{io_time} / ( 1000 * $refresh ) * 100;
            $diff_usage{io_time} = 100 if $diff_usage{io_time} > 100;

            my $w = 0;
            $w = $diff_usage{'w_ios'} / $diff_usage{'r_ios'} if $diff_usage{'r_ios'} > 0;
            my $r = $w < 1 ? 1 - $w : 1 - 1 / $w;

            $r *= $diff_usage{io_time};
            $w *= $diff_usage{io_time};

            $results{$name}                   = $diff_usage{io_time};
            $results{ $name . POSTFIX_READ }  = $r;
            $results{ $name . POSTFIX_WRITE } = $w;
        }
        return \%results;
    }

    sub memory_usages {
        my @sda;
        my $total     = 0;
        my $available = 0;
        my %results;

        open( my $f, '<', PROC_MEMINFO );
        for (<$f>) {
            if (/\AMemTotal:\s+[0-9]+/) {
                @sda = split /\s+/, $_;
                $total = $sda[1];
            }
            if (/\AMemAvailable:\s+[0-9]+/) {
                @sda = split /\s+/, $_;
                $available = $sda[1];
            }
        }

        $results{ $sda[0] } = 100 - ( 100 * $available / $total );
        return \%results;
    }

    sub network_usages {
        my %results;
        my $bytes = 0;
        state %nics;
        state $t = urxvt::NOW- 1;
        my $ct      = urxvt::NOW;
        my $refresh = $ct - $t;
        $t = $ct;

        local *_set = sub {
            my $nic       = shift;
            my $direction = shift;
            open( my $f, '<', sysfs_net( $nic, $direction ) );
            {
                local $/;
                $bytes = <$f>;
            }

            my $diff_rx = $bytes - $nics{$nic}{$direction};
            $nics{$nic}{$direction} = $bytes;
            my $diff_usage = $diff_rx / ( network_speed($nic) * $refresh ) * 100;
            $results{ $nic . ( $direction eq RX ? POSTFIX_RX : POSTFIX_TX ) } = $diff_usage;
        };

        for ( @{ network_list() } ) {
            my $nic = $_;
            if ( !exists $nics{$nic} ) {
                $nics{$nic}{$_} = 0 for ( RX, TX );
            }
            _set( $nic, RX );
            _set( $nic, TX );

        }
        return \%results;
    }

    sub network_default {
        open( my $fh, '<', PROC_NET_ROUTE );

        my $if = <$fh>;
        $if = <$fh>;

        my @wif = split /\s+/, $if;
        $wif[0];
    }

    sub network_speed {
        my $if = shift;
        my $speed;
        state $refresh = 4;
        state $wifispeed;
        if ( has_wifi($if) ) {
            if ( $refresh >= 4 ) {
                $refresh = 0;
                my $c = qx/sudo iwconfig $if/;
                ($wifispeed) = $c =~ /Bit Rate.(\d*\.{0,1}\d*)/;
                $speed = $wifispeed;
            }
            else {
                $refresh++;
                $speed = $wifispeed;
            }
        }
        else {
            open( my $fh, '<', sysfs_net( $if, SPEED ) );
            $speed = <$fh>;
        }
        $speed *= 1000000 / 8;
        return $speed;
    }

    sub needs_refresh {
        my $r = shift;
        state $t = 0;
        my $ct = urxvt::NOW;

        return 0 if ( $ct - $t ) < $r;
        $t = $ct;
        1;
    }
}

package cdmn::resources::single {
    use Params::Validate qw(:all);
    use fields qw(
        name
        padding
        bg
        fg
        colors
        label
        length
        gauges
        style
        visual
        detail
    );

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        (%$s) = validate(
            @_,
            {   name    => 1,
                padding => 1,
                fg      => 1,
                bg      => 1,
                colors  => 1,
                label   => 1,
                length  => 1,
                gauges  => 1,
                detail  => 1,
                visual  => 1,
            }
        );
        $s;
    }
}

package cdmn::resources {
    use Scalar::Util qw(looks_like_number);

    use fields qw(
        ok
        x y
        padding
        showing
        showing_labels
        caption_bg
        actions
        graphs_length
        graphs
        configs

        label_network
        label_disk
        label_cpu
        label_memory
        label_battery
        label_battery_AC
        label_cpu_temp
        label_bg
        label_fg
        label_position
        label_padding

        gauges
        gauges_order
        gauges_bg
        gauges_colors
        gauges_invert
        gauges_batteries
        gauges_cpu_temps
        gauges_networks
        gauges_disks
        gauges_cpus
        gauges_memory

        network_tx
        network_rx
        disks
        disks_read
        disks_write

        disk_mounts_only
        refresh
        sensitivity

        visual_detail_cpu
        visual_detail_cpu_temp
        visual_detail_battery

        visual_style
        visual_align

        colors_network
        colors_disk
        colors_cpu
        colors_cpu_temp
        colors_memory
        colors_battery

        sidebar_header_fg
        sidebar_header_bg
        sidebar_fg
        sidebar_bg
        sidebar_boarder_fg
        sidebar_boarder_bg
    );

    use constant {
        POSTFIX_TX    => '_tx',
        POSTFIX_RX    => '_rx',
        POSTFIX_READ  => '_read',
        POSTFIX_WRITE => '_write',

        CDMN => 'cdmn::constants',
        MATH => 'cdmn::math',
        PROC => 'cdmn::proc',
    };

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        return $s;
    }

    sub init {
        my $s = shift;
        my $t = shift;

        local *_set_list = sub {
            my $r = $t->x_resource("$_[0]");
            return [ split( /[,[:space:]]/, $r ) ]    if $r;
            return [ split( /[,[:space:]]/, $_[1] ) ] if $_[1];
            [ () ];
        };

        local *_set_number = sub {
            my $n = $t->x_resource("$_[0]");
            looks_like_number($n) ? $n : $_[1];
        };

        $s->{label_network}  = $t->x_resource('%.label.network')  // 'NET';
        $s->{label_disk}     = $t->x_resource('%.label.disk')     // 'DISK';
        $s->{label_cpu}      = $t->x_resource('%.label.cpu')      // 'CPU';
        $s->{label_cpu_temp} = $t->x_resource('%.label.cpu.temp') // 'TEMP';
        $s->{label_memory}   = $t->x_resource('%.label.memory')   // 'MEM';
        $s->{label_battery}  = $t->x_resource('%.label.battery')  // 'BAT';
        $s->{label_battery_AC} = $s->{label_battery} . "(⌁)";
        $s->{label_fg}         = _set_number( '%.label.fg', 0 );
        $s->{label_bg}         = _set_number( '%.label.bg', 1 );
        $s->{label_position}   = $t->x_resource('%.label.position') || 'left';
        $s->{label_padding}    = _set_number( '%.label.padding', 0 );

        $s->{showing}        = _set_number( '%.showing',        1 );
        $s->{showing_labels} = _set_number( '%.showing.labels', 1 );

        $s->{visual_align} = $t->x_resource('%.visual.alignment') // 'row';    #row | col
        $s->{caption_bg} = _set_number( '%.caption.bg', 1 );                   # 0/1 map onto terminal fg/bg color

        $s->{visual_detail_cpu}      = _set_number( '%.visual.detail.cpu',      0 );     #0/1 less or more detail
        $s->{visual_detail_cpu_temp} = _set_number( '%.visual.detail.cpu.temp', 0 );     #0/1 less or more detail
        $s->{visual_detail_battery}  = _set_number( '%.visual.detail.battery',  0 );     #0/1 less or more detail
        $s->{padding}                = _set_number( '%.padding',                2 );     #Padding between visuals
        $s->{x}                      = _set_number( '%.x',                      -1 );    #positive from left, negativ from right
        $s->{y}                      = _set_number( '%.y',                      0 );     #positive from top, negativ from bottom
        $s->{disk_mounts_only}       = _set_number( '%.disk.mountsonly',        1 );     #TODO rename
        $s->{refresh}                = _set_number( '%.refresh',                1 );
        $s->{sensitivity}            = _set_number( '%.sensitivity',            1 );     #percentage
        $s->{visual_style} = $t->x_resource('%.visual.style') // 'bar';                  #bar | led | graph

        $s->{gauges_order}     = _set_list('%.gauges.order');
        $s->{disks}            = _set_list('%.gauges.disks');
        $s->{disks_read}       = _set_list('%.gauges.disks.read');
        $s->{disks_write}      = _set_list('%.gauges.disks.write');
        $s->{gauges_batteries} = _set_list('%.gauges.batteries');
        $s->{gauges_cpu_temps} = _set_list('%.gauges.cores');
        $s->{network_rx}       = _set_list('%.network.rx');
        $s->{network_tx}       = _set_list('%.network.tx');
        $s->{gauges_invert}    = _set_list( '%.gauges.invert', 'BAT' );
        $s->{gauges_memory}    = ["MemAvailable:"];

        $s->{graphs} = _set_list('%.graphs');
        $s->{graphs_length} = _set_number( '%.graphs.width', 0 );

        $s->{gauges_colors} = _set_list( '%.gauges.colors', '-1,-2' );
        $s->{"colors_$_"} = _set_list("%.colors.$_") for (qw/network disk cpu cpu_temp memory battery/);

        $s->{sidebar_header_fg}  = _set_number( '%.sidebar.header.fg',  -2 );
        $s->{sidebar_header_bg}  = _set_number( '%.sidebar.header.bg',  -1 );
        $s->{sidebar_fg}         = _set_number( '%.sidebar.fg',         -2 );
        $s->{sidebar_bg}         = _set_number( '%.sidebar.bg',         -1 );
        $s->{sidebar_boarder_fg} = _set_number( '%.sidebar.boarder.fg', -2 );
        $s->{sidebar_boarder_bg} = _set_number( '%.sidebar.boarder.bg', -1 );

        $s->set_disks;
        $s->set_batteries;
        $s->set_cores;
        $s->set_nics;
        $s->set_order;
        $s->set_invert;
        $s->set_colors;
        $s->set_graphs;

        for (qw/network disk cpu cpu_temp memory battery/) {
            ( my $t = $_ ) =~ s/y$/ie/;
            $s->{configs}{$_} = cdmn::resources::single->new(
                name    => $_,
                padding => 1,
                fg      => $s->{label_fg},
                bg      => $s->{label_bg},
                colors  => $s->{"colors_$_"},
                label   => $s->{"label_$_"},
                length  => $s->{graphs}{$_} ? $s->{graphs_length} : 0,
                gauges  => $_ eq 'memory' ? $s->{"gauges_$_"} : $s->{"gauges_${t}s"},
                detail  => exists $s->{"visual_detail_$_"} ? $s->{"visual_detail_$_"} : 1,
                visual  => $s->{visual_style},
            );
        }
    }

    sub configs {
        my ( $s, $t ) = @_;
        $s->{configs}{$t}{label} = PROC->ac_online() ? $s->{label_battery_AC} : $s->{label_battery} if $t eq 'battery';
        $s->{configs}{$t};
    }

    my $validate = sub {
        my $s             = shift;
        my @order_default = map { $s->{$_} } (qw/ label_cpu label_cpu_temp label_disk label_memory label_network label_battery /);
        my %gauges        = map { $_ => 0 } @order_default;
        $gauges{$_} = 1 for $_[0];

        return \@order_default if scalar @{ $_[0] } eq 0;
        return MATH->cut_set( $_[0], \@order_default );
    };

    sub set_cores {
        my $s    = shift;
        my $cpus = cdmn::proc::cpu_count() - 1;
        $s->{gauges_cpus} = [ map "cpu" . $_, 0 .. $cpus ];
        $s;
    }

    sub set_order {
        my $s = shift;
        $s->{gauges_order} = $validate->( $s, $s->{gauges_order} );
        $s->{gauges_order} = $s->remap( $s->{gauges_order} );
        $s;
    }

    sub set_graphs {
        my $s = shift;
        $s->{graphs} = $validate->( $s, $s->{graphs} );
        $s->{graphs} = { map { $_ => 1 } @{ $s->remap( $s->{graphs} ) } };
        $s;
    }

    sub remap {
        my $s = shift;
        my @remap;
        my %l = (
            $s->{label_cpu}      => 'cpu',
            $s->{label_disk}     => 'disk',
            $s->{label_memory}   => 'memory',
            $s->{label_network}  => 'network',
            $s->{label_cpu_temp} => 'cpu_temp',
            $s->{label_battery}  => 'battery',
        );
        push @remap, $l{$_} for ( @{ +shift } );
        \@remap;
    }

    sub set_invert {
        my $s = shift;
        $s->{gauges_invert} = $validate->( $s, $s->{gauges_invert} );
        1;
    }

    sub set_nics {
        my $s           = shift;
        my $nics_active = cdmn::proc->network_list;
        my $ov          = $s->{gauges_networks} ? scalar @{ $s->{gauges_networks} } : 0;

        my $rx_tx = MATH->cut_set( $s->{network_tx}, $nics_active );
        my @tx = map { $_ . POSTFIX_TX } @$rx_tx;

        $rx_tx = MATH->cut_set( $s->{network_rx}, $nics_active );
        my @rx = map { $_ . POSTFIX_RX } @$rx_tx;

        if ( ( scalar @tx eq 0 and scalar @rx eq 0 ) || ( @{ $s->{network_rx} } && @{ $s->{network_tx} } ) ) {
            $s->{gauges_networks} = [ map { $_ . POSTFIX_RX, $_ . POSTFIX_TX } @$nics_active ];
        }
        else { $s->{gauges_networks} = [ @rx, @tx ]; }
        $ov != scalar @{ $s->{gauges_networks} } ? $s->{ok} = 1 && return $s : Null->new;
    }

    sub set_disks {
        my $s = shift;
        my $ov = $s->{gauges_disks} ? @{ $s->{gauges_disks} } : 0;

        $s->{gauges_disks}
            = $s->{disk_mounts_only}
            ? MATH->cut_set( PROC->disk_mounts, $s->{disks} )
            : MATH->cut_set( PROC->disks,       $s->{disks} );

        my $rw
            = $s->{disk_mounts_only}
            ? MATH->cut_set( PROC->disk_mounts, $s->{disks_read} )
            : MATH->cut_set( PROC->disks,       $s->{disks_read} );

        my @r = map { $_ . POSTFIX_READ } @$rw;

        $rw
            = $s->{disk_mounts_only}
            ? MATH->cut_set( PROC->disk_mounts, $s->{disks_write} )
            : MATH->cut_set( PROC->disks,       $s->{disks_write} );

        my @w = map { $_ . POSTFIX_WRITE } @$rw;

        $s->{gauges_disks} = $s->{disk_mounts_only} ? PROC->disk_mounts : PROC->disks
            if !@{ $s->{gauges_disks} } && !@r && !@w;

        push @{ $s->{gauges_disks} }, ( @r, @w );

        $ov != @{ $s->{gauges_disks} } ? $s->{ok} = 1 && return $s : Null->new;
    }

    sub ok { (shift)->{'ok'} }

    sub set_colors {
        my $s = shift;
        for my $h (qw(network disk cpu cpu_temp memory battery)) {

            # If a specific list of colors is defined, thake it, otherwise use default colors.
            # Make sure values are numbers and add 2.
            # We have to add 2 because urxvt uses 0 and 1 for references to the terminals fg and bg colors.
            $s->{"colors_$h"}
                = [ map { $_ + 2 } grep ( looks_like_number($_), ( @{ $s->{"colors_$h"} } ? @{ $s->{"colors_$h"} } : @{ $s->{gauges_colors} } ) ) ];
        }
        1;
    }

    for my $h (qw(batteries cpu_temps)) {
        ## no critic
        eval qq{
            sub set_$h {
                my \$s = shift;
                my \$ov = \$s->{gauges_$h} ? scalar \@{\$s->{gauges_$h}} : 0;
                \$s->{gauges_$h} = MATH->cut_set(cdmn::proc::$h, \$s->{gauges_$h});
                \$s->{gauges_$h} = cdmn::proc::$h if scalar \@{\$s->{gauges_$h}} eq 0 || \@{\$s->{gauges_$h}};
                \$ov != scalar \@{\$s->{gauges_$h}} ? \$s->{ok} = 1 && return \$s : Null->new;
            }
        }
    }
}

package cdmn::sidebar {
    use Params::Validate qw(:all);
    use POSIX qw(ceil floor);

    use constant { REND => cdmn::constants::REND, };

    use fields qw(term width panes data active_pane visible order bg fg bg_header fg_header bg_boarder fg_boarder);

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        (%$s) = validate(
            @_,
            {   term       => 1,
                width      => { default => 32 },
                visible    => { default => 0 },
                bg         => 1,
                fg         => 1,
                bg_header  => 1,
                fg_header  => 1,
                bg_boarder => 1,
                fg_boarder => 1,
            }
        );
        $s->{data}  = ();
        $s->{order} = ();

        $s;
    }

    sub hide {
        my $s = shift;
        ($s)->{term}->hide;
        $s->{visible} = 0;
        $s;
    }

    sub show {
        my $s = shift;
        $s->{term}->show;
        $s->{visible} = 1;
        $s;
    }

    sub hide_cursor {
        my $s = shift;
        $s->{term}->hide_cursor;
        $s;
    }

    sub toggle {
        my $s = shift;
        $s->{visible} = !$s->{visible};
        $s->{term}->toggle;
        $s->show_pane( $s->{order}[ $s->{active_pane} ] );
        $s;
    }

    sub bounds {
        my $s = shift;
        $s->{term}->bounds(@_);
        $s;
    }

    sub show_pane {
        my ( $s, $title ) = (@_);
        return if !$s->{visible};
        my $data = $s->{panes}{$title};
        for ( my $j = 0; $j < @$data; $j++ ) {
            $$data[$j]->show if $$data[$j]->{y} < $s->{term}->nrow;
        }
        $s;
    }

    sub hide_pane {
        my ( $s, $title ) = (@_);
        return if !$s->{visible};
        my $data = $s->{panes}{$title};

        for ( my $j = 0; $j < @$data; $j++ ) {
            $$data[$j]->hide;
        }
        $s;
    }

    sub set_pane {
        my ( $s, $title, $args ) = (@_);
        $s->{panes}{$title} = $s->create_pane( $title, $args );
        $s->{data}{$title} = $args;
        $s->show_pane($title) if $title eq $s->{order}[ $s->{active_pane} ];
        $s;
    }

    sub next_pane {
        my $s = shift;
        $s->goto_pane(+1);
        $s;
    }

    sub prev_pane {
        my $s = shift;
        $s->goto_pane(-1);
        $s;
    }

    sub goto_pane {
        my $s = shift;
        my $i = $s->{active_pane};
        $s->hide_pane( $s->{order}[$i] );
        $i += (shift);
        $i = 0 if $i ge scalar @{ $s->{order} };
        $i = @{ $s->{order} } - 1 if $i lt 0;
        $s->{active_pane} = $i;
        #$s->show_pane( $s->{order}[$i] );
        $s;
    }

    sub add_pane {
        my ( $s, $title, $args ) = (@_);
        $s->{panes}{$title} = $s->create_pane( $title, $args );
        $s->{data}{$title} = $args;
        push @{ $s->{order} }, $title;
        $s;
    }

    #TODO method name and return value
    sub create_pane {
        my @data;
        my $s     = shift;
        my $title = shift;
        my $args  = shift;

        my $r     = urxvt::SET_FGCOLOR REND, $s->{fg_boarder};
        my $i = 0;

        local *_create = sub {
          cdmn::visuals::overlay->new(
            term      => $s->{term},
            x         => -1,
            y         => $i++,
            width     => $s->{width},
            height    => 1,
            rendition => $r,
            text      => (shift),
          );
        };

        #border
        $data[0] = _create("│");
        $data[0]->{x} = 0;
        $data[0]->{y} = 0;
        $data[0]->{width} = 1;
        $data[0]->{height} = $s->{term}->nrow;

        #title
        $r = (urxvt::SET_FGCOLOR REND, $s->{fg_header}) | urxvt::RS_Uline;
        push @data, _create($title);
        
        #content
        $r = urxvt::SET_FGCOLOR REND, $s->{fg};
        $i+=2;

        for ( sort keys %$args ) {
            push @data, _create($_);

            my $c = ceil( 25 * $args->{$_} / 100 );
            my $f = $c <= 25 ? 25 - $c : 0;    #should only be necessary on startup
            push @data, _create("■" x $c . "□" x $f . " " . ceil( $args->{$_} ) . "%");
        }

        for ( my $j = 0; $j < @data; $j++ ) { $data[$j]->create(); }

        return \@data;
    }
}

package cdmn::term {
    use Params::Validate qw(:all);
    use File::Basename;

    use fields qw(x y w h term parent bg_color content is_root resource maximized);

    use constant CDMN => 'cdmn::constants';

    my @terminals;
    my $root;

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        (%$s) = validate(
            @_,
            {   parent   => 1,
                resource => 1,
                bg_color => 1,
                is_root  => 1,
                x        => { default => 1 },
                y        => { default => 1 },
                w        => { default => 1 },
                h        => { default => 1 }
            }
        );

        #(%$s) = @_;
        #@$s{qw/x y w h/} // 1;

        push @urxvt::TERM_INIT, sub {
            my ($term) = @_;
            $term->{termclass} = $s;
            $term->{parent} = $s->{parent} if $s->{is_root};

            my $file_name = fileparse __FILE__;
            $term->resource( perl_ext_2 => "-$file_name" );    #Do not load this extension for child terminals!
        };

        push @urxvt::TERM_EXT, __PACKAGE__;

        my $environ = $s->{parent}->env;
        $environ->{SHELL} = 'sh' if !$s->{is_root};

        #$s->{term} = new urxvt::term( $environ, $urxvt::RXVTNAME, -embed => $s->{parent}->parent, -depth => 32, -bg =>6 );
        $s->{term} = new urxvt::term( $environ, $urxvt::RXVTNAME, -embed => $s->{parent}->parent, -depth => 32 );
        $s->bounds( @$s{qw/x y w h/} );
        $s->{is_root} ? $root = $s : push( @terminals, $s );

        $s;
    }

    sub on_user_command {
        (shift)->{term}{termclass}{parent}->user_command(@_);
        1;
    }

    sub on_init {
        my $s = shift;
        $s->bind_action( 'M-h', 'perl:' . CDMN->ACTION_TOGGLE );
        $s->bind_action( 'M-p', 'perl:' . CDMN->ACTION_TOGGLE_SIDEBAR );
        $s->bind_action( 'M-o', 'perl:' . CDMN->ACTION_TOGGLE_OVERLAY );
        $s->bind_action( 'M-l', 'perl:' . CDMN->ACTION_TOGGLE_LABELS );
        $s->bind_action( 'M-k', 'perl:' . CDMN->ACTION_NEXT_PANE );
        $s->bind_action( 'M-j', 'perl:' . CDMN->ACTION_PREV_PANE );
        ();
    }

    sub on_tt_write {
        if ( !(shift)->{term}{parent} ) {
            $root->{term}->tt_write(shift);
            1;
        }
        ();
    }

    sub on_refresh_begin {
        my $s = shift;
        if ( !$s->{term}{parent} ) {
            my $str = $s->{term}->locale_encode("\e[0;0H\e[K");
            $s->{term}->cmd_parse($str);    #do not show the cursor!
            1;
        }
        ();
    }

    sub on_destroy {
        exit;
        1;
    }

    sub bounds {
        my $s = shift;
        @$s{qw/x y w h/} = validate_pos( @_, 1, 1, 1, 1 );
        $s->{term}->XMoveResizeWindow( $s->{term}->parent, @_ );
        $s;
    }

    sub maximize {
        my $s = shift;
        $s->{maximized} = 1;    #TODO
        $s;
    }

    sub hide_cursor {
        my $s = shift;
        $s->{term}->cmd_parse("\033[?25l");
        $s;
    }

    sub hide {
        my $s = shift;
        $s->{term}->XUnmapWindow( $s->{term}->parent );
        $s;
    }

    sub show {
        my $s = shift;
        $s->{term}->XMapWindow( $s->{term}->parent );
        $s;
    }

    sub toggle {
        my $s = shift;
        $s->{term}->mapped ? $s->hide : $s->show;
        $s;
    }
}

package cdmn::visuals::container {
    use fields qw( term rendition padding align even_gauges x y bg_color label_pos graph_data graph  );
    use fields qw( gauges visible bg bg_visible label_visible detail width height );
    use Params::Validate qw(:all);

    use constant CDMN => 'cdmn::constants';
    use constant { TRUE => 1, FALSE => 0 };

    my ( $xOff, $yOff, $m ) = ( 0, 0, 0 );

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        (%$s) = validate(
            @_,
            {   term        => 1,
                rendition   => 1,
                x           => 1,
                y           => 1,
                padding     => 1,
                align       => 1,
                even_gauges => 1,
                visible     => 1,
                bg_color    => 1,
                label_pos   => 1,
            }
        );

        ( $xOff, $yOff ) = ( 0, $s->{y} );
        $s;
    }

    sub add {
        my $s = shift;
        my (%arg) = validate(
            @_,
            {   label         => 1,
                padding       => 1,
                gauges        => 1,
                label_bg      => 1,
                label_fg      => 1,
                gauges_colors => 1,
                gauges_bg     => 1,
                visual_style  => 1,
                sensitivity   => 1,
                name          => 1,
                detail        => 1,
                graph         => { default => 0 },
            }
        );

        my $visual = cdmn::visuals::visual->new(
            term          => $s->{term},
            rendition     => $s->{rendition},
            x             => $xOff,
            y             => $yOff,
            label         => $arg{label},
            gauges        => $arg{graph} ? [ 0 .. $arg{graph} * ( scalar @{ $arg{gauges} } ) - 1 ] : $arg{gauges},
            label_bg      => $arg{label_bg},
            label_fg      => $arg{label_fg},
            gauges_colors => $arg{gauges_colors},
            gauges_bg     => $arg{gauges_bg},
            visual_style  => $arg{visual_style},
            sensitivity   => $arg{sensitivity},
            label_pos     => $s->{label_pos},
            padding       => $arg{padding},
        );

        $s->{detail}{ $arg{name} } = $arg{detail};
        $s->{graph}{ $arg{name} }  = $arg{graph};

        local *_pad = sub {
            for ( values %{ $s->{gauges} } ) {
                my $c = scalar @{ $_->{gauges} };
                return if $c <= $m;
                $m = $c;
                $_->even_gauges($c);
                $xOff += $visual->{width} if $s->{align} eq CDMN->VISUAL_ALIGN_ROW;
            }
        };

        if ( $s->{even_gauges} ) {
            _pad( length $arg{label} ) if $s->{label_pos} eq CDMN->RIGHT;
            _pad( scalar @{ $arg{gauges} } ) if $s->{label_pos} eq CDMN->LEFT;
        }

        $visual->even_gauges($m) if $s->{even_gauges};
        $xOff += $visual->{width} + $s->{padding}  if $s->{align} eq CDMN->VISUAL_ALIGN_ROW;
        $yOff += $visual->{height} + $s->{padding} if $s->{align} eq CDMN->VISUAL_ALIGN_COL;
        $s->{gauges}{ $arg{name} } = $visual;
        $s;
    }

    sub create {
        my $s = shift;
        my $l = 0;

        for ( values %{ $s->{gauges} } ) {
            $l = $_->{width} if $l < $_->{width};
        }

        for ( values %{ $s->{gauges} } ) {
            if ( $s->{x} < 0 ) {
                $_->{x} = $s->{term}->ncol - $xOff + $_->{x} + $s->{x} + $s->{padding} + 1 if ( $s->{align} eq CDMN->VISUAL_ALIGN_ROW );
                $_->{x} = $s->{term}->ncol - $_->{x} - $_->{width} if ( $s->{align} eq CDMN->VISUAL_ALIGN_COL );
            }
            else {
                $_->{x} += $s->{x} if $s->{align} eq CDMN->VISUAL_ALIGN_ROW;
                $_->{x} = $l - $_->{width} if ( $s->{align} eq CDMN->VISUAL_ALIGN_COL );
            }
            if ( $s->{y} < 0 ) {
                $_->{y} = $s->{term}->nrow - $yOff + $_->{y} + $s->{y} + $s->{padding} + 1 if ( $s->{align} eq CDMN->VISUAL_ALIGN_COL );
            }
        }

        $_->create for values %{ $s->{gauges} };

        $s->{width} = $s->{align} eq CDMN->VISUAL_ALIGN_ROW ? $xOff - $s->{padding} : $l;
        $s->{height} = $s->{align} eq CDMN->VISUAL_ALIGN_ROW ? 1 : $yOff - $s->{padding} + 1;

        #Background
        $s->{bg} = cdmn::visuals::overlay->new(
            term   => $s->{term},
            x      => $s->{x},
            y      => $s->{y},
            width  => $s->{width},
            height => $s->{height},

            #rendition => urxvt::SET_BGCOLOR CDMN->REND, 4,
            rendition => urxvt::SET_BGCOLOR CDMN->REND,
            $s->{bg_color},
        );

        $s->{bg}->create();
        $s->{bg_visible} = 1;

        my $w = 0;
        for ( values %{ $s->{gauges} } ) { $w = $_->{width} if $_->{width} > $w; }
        $s->{width} = $w * $s->{term}->fwidth;
        $s->{height} = $yOff + ( $s->{padding} * ( $yOff - 1 ) * $s->{term}->fheight );
        $s;
    }

    sub set {
        my ( $s, $name, $usage, $invert ) = validate_pos( @_, 1, 1, 1, 1 );
        my $total = 0;

        if ( $s->{graph}{$name} ) {
            my $graph_count = $s->{graph}{$name};

            for ( keys %$usage ) {
                $s->{graph_data}{$name}{$_} = [ (0) x $graph_count ] if !$s->{graph_data}{$name}{$_};
                shift @{ $s->{graph_data}{$name}{$_} };
                push( @{ $s->{graph_data}{$name}{$_} }, $usage->{$_} );
                $total += $usage->{$_};
            }
            $total /= scalar keys %$usage;

            $s->{graph_data}{$name}{'simple'} = [ (0) x $graph_count ] if !$s->{graph_data}{$name}{'simple'};
            shift @{ $s->{graph_data}{$name}{'simple'} };
            push @{ $s->{graph_data}{$name}{'simple'} }, $total;

            my %t;
            my $key = 0;
            for ( sort keys %{ $s->{graph_data}{$name} } ) {
                for ( @{ $s->{graph_data}{$name}{ $s->{detail}{$name} ? $_ : 'simple' } } ) {
                    $t{ $key++ } = $_;
                }
            }
            $usage = \%t;
        }

        if ( $s->{visible} && $s->{gauges}{$name} ) {
            if ( !$s->{detail}{$name} and !$s->{graph}{$name} ) {
                $total += $_ for values %$usage;
                $total /= scalar keys %$usage;
                $s->{gauges}{$name}->set( 'simple', $total, $invert );
            }
            else {
                while ( my ( $key, $value ) = each %$usage ) {
                    $s->{gauges}{$name}->set( $key, $value, $invert );
                }
            }
        }

        $s->refresh_bg;
        $s;
    }

    sub show {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        $visible ? $_->show : $_->hide for values %{ $s->{gauges} };
        $visible ? $s->show_labels : $s->hide_labels;

        $visible ? $s->show_bg : $s->hide_bg;
        $s->{visible} = $visible;
        $s;
    }

    sub hide {
        my $s = shift;
        $s->show(FALSE);
        $s;
    }

    sub toggle {
        my $s = shift;
        $s->{visible} ? $s->hide : $s->show;
        $s;
    }

    sub show_labels {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        for ( values %{ $s->{gauges} } ) {
            $visible ? $_->show_label : $_->hide_label;
        }

        $s->refresh_bg;
        $s->{label_visible} = $visible;
        $s;
    }

    sub hide_labels {
        my $s = shift;
        $s->show_labels(FALSE);
        $s;
    }

    sub show_bg {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        $visible ? $s->{bg}->show : $s->{bg}->hide;
        $s->{bg_visible} = $visible;
        $s;
    }

    sub refresh_bg {
        my $s = shift;
        if ( $s->{bg_visible} ) {
            $s->hide_bg;
            $s->show_bg;
        }
        $s;
    }

    sub hide_bg {
        my $s = shift;
        $s->show_bg(FALSE);
        $s;
    }
}

package cdmn::visuals::visual {
    use List::Util qw(max);
    use Params::Validate qw(:all);

    use fields qw(
        term

        x y
        width
        height
        width_add
        padding

        rendition
        visual_style
        sensitivity
        count

        label
        label_bg
        label_fg
        label_pos

        gauges
        gauges_colors
        gauges_bg

    );

    use constant BLOCKS => [qw/_ ▁ ▂ ▃ ▄ ▅ ▆ ▇ █/];

    #use constant LED => '⬛';
    use constant LED => '■';
    use constant { TRUE => 1, FALSE => 0 };
    use constant CDMN => 'cdmn::constants';

    my $m = 0;

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        (%$s) = validate(
            @_,
            {   term          => 1,
                rendition     => 1,
                x             => 1,
                y             => 1,
                label         => 1,
                gauges        => 1,
                label_bg      => 1,
                label_fg      => 1,
                gauges_colors => 1,
                gauges_bg     => 1,
                visual_style  => 1,
                sensitivity   => 1,
                label_pos     => 1,
                padding       => 1,
            }
        );

        $s->{width} = ( length $s->{label} ) + $s->{padding} + @{ $s->{gauges} };

        $s->{height}    = 1;
        $s->{width_add} = 0;
        $s;
    }

    sub even_gauges {
        my ( $s, $max ) = @_;
        my $l = length $s->{label};

        $s->{width} -= $s->{width_add};
        $s->{width_add} = $max - @{ $s->{gauges} } if $s->{label_pos} eq CDMN->LEFT;
        $s->{width_add} = $l > 0 ? $max - $l : 0 if $s->{label_pos} eq CDMN->RIGHT;
        $s->{width} += $s->{width_add};
        $s;
    }

    sub create {
        my $s      = shift;
        my $w      = ( length $s->{label} );
        my @gauges = @{ $s->{gauges} };

        $s->{gauges} = {};
        $s->{x} = -( $w + $m ) if $s->{x} < 0;
        my $x = $s->{x};

        local *_label = sub {
            $s->{rendition} = urxvt::SET_COLOR $s->{rendition}, $s->{label_fg}, $s->{label_bg};
            my $labelObj = cdmn::visuals::overlay->new(
                term      => $s->{term},
                x         => $x,
                y         => $s->{y},
                width     => $w,
                height    => $s->{height},
                rendition => $s->{rendition},
                text      => $s->{label}
            );
            $s->{label} = $labelObj->create();
        };

        local *_gauges = sub {
            $s->{rendition} = urxvt::SET_BGCOLOR $s->{rendition}, $s->{gauges_bg};
            for my $i (@gauges) {
                for ( @{ $s->{gauges_colors} } ) {
                    $s->{rendition} = urxvt::SET_FGCOLOR $s->{rendition}, $_;
                    my $pictorial = cdmn::visuals::overlay->new(
                        term      => $s->{term},
                        x         => $x,
                        y         => $s->{y},
                        width     => 1,
                        height    => 1,
                        rendition => $s->{rendition},
                        text      => BLOCKS->[0],
                    );
                    $s->{gauges}{"$i"}{"$_"} = $pictorial->create();
                }
                $x++;
            }
        };

        if ( $s->{label_pos} eq CDMN->RIGHT ) { _gauges(); $x++; _label(); }
        else                                  { _label(); $x += $w + $s->{padding}; _gauges(); }
        $s;
    }

    sub show {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        for ( values %{ $s->{gauges} } ) {
            for ( values %{$_} ) {
                $visible ? $_->show : $_->hide;
            }
        }
        $s;
    }

    sub hide {
        my $s = shift;
        $s->show(FALSE);
        $s;
    }

    sub show_label {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        $visible ? $s->{label}->show : $s->{label}->hide;
        $s;
    }

    sub hide_label {
        my $s = shift;
        $s->show_label(FALSE);
        $s;
    }

    sub set {
        my ( $s, $i, $usage, $invert ) = validate_pos( @_, 1, 1, 1, 1 );
        return if !$s->{gauges}{"$i"};

        my $size = scalar @{&BLOCKS};
        my $bar_i = ( $usage > 100 ? 100 : $usage ) / 100 * ($size);
        $usage = 100 - $usage if $invert;
        $bar_i -= 1 if $bar_i >= $size;
        $size = scalar @{ $s->{gauges_colors} };
        my $clr_i = ( $usage > 100 ? 100 : $usage ) / 100 * ( $size - 1 ) + 1;
        $clr_i -= 1 if $clr_i >= $size;
        my $color = $usage < $s->{sensitivity} ? $s->{gauges_colors}[1] : $s->{gauges_colors}[$clr_i];
        for ( values %{ $s->{gauges}{"$i"} } ) {
            $_->hide;
        }

        $s->{gauges}{"$i"}{"$color"}->set( BLOCKS->[$bar_i] ) if $s->{visual_style} eq CDMN->STYLE_BAR;
        $s->{gauges}{"$i"}{"$color"}->set(LED) if $s->{visual_style} eq CDMN->STYLE_LED;
        $s->{gauges}{"$i"}{"$color"}->show;
        $s;
    }
}

package cdmn::visuals::overlay {
    use Params::Validate qw(:all);
    use fields qw(
        term
        x
        y
        width
        height
        rendition
        text
        overlay
    );

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        (%$s) = validate(
            @_,
            {   term      => 1,
                rendition => 1,
                x         => 1,
                y         => 1,
                width     => 1,
                height    => 1,
                text      => 0,
            }
        );
        $s;
    }

    sub create {
        my $s = shift;
        my ( $x, $y, $w, $h, $r, $c ) = ( $s->{x}, $s->{y}, $s->{width}, $s->{height}, $s->{rendition}, $s->{text} );

        $s->{overlay} = $s->{term}->overlay( $x, $y, $w, $h, $r, 0 );

        $s->set($c) if defined $c;
        $s;
    }

    #set text for overlay. If overlay hight > 1 repeat text for each row.
    sub set {
        my $s = shift;
        $s->{text} = shift;
        $s->{overlay}->set( 0, 0, $s->{text} );

        if ( $s->{height} > 1 ) {
            $s->{overlay}->set( 0, $_, $s->{text} ) for ( 0 .. $s->{height} );
        }

        for my $h (qw(hide show)) {
            eval qq{ sub $h { my \$s = shift; \$s->{overlay}->$h; } };    ## no critic
        }
        $s;
    }
}

use constant XR   => cdmn::resources->new();
use constant CDMN => 'cdmn::constants';

#-----------------------------------------------------------
#   HELPERS
#-----------------------------------------------------------

#
sub redraw {
    my ( $s, $showLabels ) = @_;
    my @visible = map { $$_->{visible} } @{ ( $s->{captions} ) };

    $s->{visuals_updater}->stop;
    $s->{captions}[0] = create_caption( $s->{xterms}{main}{term}, $showLabels );
    $s->{captions}[1] = create_caption( $s, $showLabels );

    while ( my ( $key, $item ) = each @{ ( $s->{captions} ) } ) {
        ${$item}->create();
        $visible[$key] ? ${$item}->show : ${$item}->hide;
    }

    #$s->{xterms}{sidebar}->refresh_pane if $s->{xterms}{sidebar}{visible};
    $s->{visuals_updater}->start;
}

# P: urxvt::term, row|col
# R: List with new bounds
sub calc_bounds {
    my ( $s, $t ) = @_;
    my ( $h, $w, $x, $y ) = ( 0, 0, $s->{x}, $s->{y} );

    if ( $t eq CDMN->VISUAL_ALIGN_ROW ) {
        $h = $s->fheight * ( $s->nrow - 1 );
        $w = $s->width;
        $y = XR->{y} >= 0 ? $s->fheight : -1;
    }
    if ( $t eq CDMN->VISUAL_ALIGN_COL ) {
        $h = $s->fheight * ( $s->nrow );
        $w = $s->width - ${ $s->{captions}[0] }->{width};
        $y = 0;
    }
    $x = 0;
    ( $h, $w, $x, $y );
}

#TODO why add 4 to w and h
sub refresh_bounds {
    my ( $s, $t ) = @_;
    my ( $h, $w, $x, $y ) = calc_bounds( $s, $t );

    if ( $s->{xterms}{main}{maximized} ) {
        $s->{xterms}{main}->bounds( 0, 0, $s->width + 4, $s->height + 4 );
    }
    else {
        $s->{xterms}{main}->bounds( $x, $y + 1, $w + 4, $h );
        $s->{xterms}{main}->bounds( XR->{x} >= 0 ? $s->width - $w : 0, 0, $w + 4, $h + 4 ) if XR->{visual_align} eq CDMN->VISUAL_ALIGN_COL;

    }
    $s->{xterms}{sidebar}->bounds( $s->width - $s->fwidth * 35 + 4, 0, $s->fwidth * 35, $s->height + 4 );

    #$s->{xterms}{sidebar}->refresh_pane if $s->{xterms}{sidebar}{visible};

}

# P: urxvt::term, 0|1
# R: ref to new cdmn::visuals::container
sub create_caption {
    my ( $s, $showLabels ) = (@_);
    my $caption;

    local *_create = sub {
        my (%arg) = @_;

        local *_add = sub {
            my $c      = shift;
            my @colors = @{ $c->{colors} };
            $caption->add(
                label => $showLabels ? $c->{label} : '',
                padding       => XR->{label_padding},
                gauges        => $arg{ $c->{name} },
                label_bg      => XR->{label_bg},
                gauges_bg     => scalar @colors > 1 ? shift @colors : XR->{gauges_colors}->[0],
                label_fg      => XR->{label_fg},
                gauges_colors => $c->{colors},
                visual_style  => XR->{visual_style},
                sensitivity   => XR->{sensitivity},
                name          => $c->{name},
                detail        => $c->{detail},
                graph         => $c->{length},
            );
        };

        for ( @{ XR->{gauges_order} } ) {
            _add( XR->configs($_) ) if $arg{$_};
        }
    };

    for ( XR->{visual_align} ) {
        $caption = do {
            if ( $_ eq CDMN->VISUAL_ALIGN_ROW ) {
                cdmn::visuals::container->new(
                    term        => $s,
                    rendition   => CDMN->REND,
                    x           => XR->{x},
                    y           => XR->{y},
                    padding     => XR->{padding},
                    align       => $_,
                    even_gauges => 0,
                    visible     => XR->{showing},
                    bg_color    => XR->{caption_bg},
                    label_pos   => XR->{label_position},
                );
            }
            elsif ( $_ eq CDMN->VISUAL_ALIGN_COL ) {
                cdmn::visuals::container->new(
                    term        => $s,
                    rendition   => CDMN->REND,
                    x           => XR->{x},
                    y           => XR->{y},
                    padding     => XR->{padding},
                    align       => $_,
                    even_gauges => 1,
                    visible     => XR->{showing},
                    bg_color    => XR->{caption_bg},
                    label_pos   => XR->{label_position},
                );
            }
        };
    }
    my %args;
    $args{cpu_temp} = ( XR->configs('cpu_temp')->{detail} ? XR->{gauges_cpu_temps} : ["simple"] ) if @{ XR->{gauges_cpu_temps} } > 0;
    $args{cpu} = XR->configs('cpu')->{detail} ? XR->{gauges_cpus} : ["simple"];
    $args{disk}    = XR->{gauges_disks} if @{ XR->{gauges_disks} } > 0 || @{ XR->{disks_write} } > 0 || @{ XR->{disks_read} } > 0;
    $args{memory}  = XR->{gauges_memory};
    $args{network} = XR->{gauges_networks} if @{ XR->{gauges_networks} } > 0;
    $args{battery} = ( XR->configs('battery')->{detail} ? XR->{gauges_batteries} : ["simple"] ) if XR->{gauges_batteries} > 0;
    _create( (%args) );
    return \$caption;
}

#-----------------------------------------------------------------------------------------------------------------------
#   ACTIONS
#-----------------------------------------------------------------------------------------------------------------------

my %user_command;

#TODO why add 4 to w and h
$user_command{ CDMN->ACTION_TOGGLE } = sub {
    my $s = shift;
    my ( $h, $w, $x, $y ) = calc_bounds( $s, XR->{visual_align} );

    if ( $s->{xterms}{main}{maximized} ) {
        $s->{xterms}{main}->bounds( $x, $y + 1, $w + 4, $h + 4 ) if XR->{visual_align} eq CDMN->VISUAL_ALIGN_ROW;
        $s->{xterms}{main}->bounds( XR->{x} >= 0 ? $s->width - $w : 0, 0, $w + 4, $h + 4 ) if XR->{visual_align} eq CDMN->VISUAL_ALIGN_COL;
        $s->{xterms}{main}{maximized} = 0;
        ${ $s->{captions}->[0] }->hide;
        XR->{showing} = 1;
    }
    else {
        $s->{xterms}{main}->bounds( 0, 0, $s->width + 4, $s->height + 4 );
        $s->{xterms}{main}{maximized} = 1;
        XR->{showing} = 0;
    }
};

$user_command{ CDMN->ACTION_TOGGLE_OVERLAY } = sub {
    my $s = shift;
    if ( $s->{xterms}{main}{maximized} ) {
        my $c = ${ $s->{captions}->[0] };
        if ( $c->{visible} ) {
            $c->hide;
            XR->{showing} = 0;
        }
        else {
            $c->show;
            XR->{showing} = 1;
            redraw( $s, XR->{showing_labels} );
            refresh_bounds( $s, XR->{visual_align} );
        }
    }
};

$user_command{ CDMN->ACTION_TOGGLE_SIDEBAR } = sub {
    (shift)->{xterms}{sidebar}->toggle;
};

$user_command{ CDMN->ACTION_NEXT_PANE } = sub {
    (shift)->{xterms}{sidebar}->next_pane;
};

$user_command{ CDMN->ACTION_PREV_PANE } = sub {
    (shift)->{xterms}{sidebar}->prev_pane;
};

$user_command{ CDMN->ACTION_TOGGLE_LABELS } = sub {
    if ( XR->{showing} ) {
        my $s = shift;
        XR->{showing_labels} = !XR->{showing_labels};
        redraw( $s, XR->{showing_labels} );
        refresh_bounds( $s, XR->{visual_align} );
    }
};

#-----------------------------------------------------------------------------------------------------------------------
#   RXVT HANDLERS
#-----------------------------------------------------------------------------------------------------------------------

sub user_command {
    my ( $s, $action ) = (@_);
    $user_command{$action}->($s);
    1;
}

# Before every terminal update, check if the state of some devices
# or the terminal size has changed and recalculate accordingly.
# The resource 'refresh' has direct impact on how often his method
# will be called.
sub on_refresh_begin {
    my ($s) = @_;
    my $nics_active = cdmn::proc->network_list;
    state $onAC = 0;
    state $nics = 0;
    if (   $s->{w_size} != $s->{term}->ncol
        || $s->{y_size} != $s->{term}->nrow
        || cdmn::proc::ac_online() != $onAC
        || $nics != scalar @$nics_active )
    {
        $onAC = !$onAC;
        $nics = scalar @$nics_active;

        XR->set_nics;
        redraw( $s, XR->{showing_labels} );
        refresh_bounds( $s, XR->{visual_align} );
        $s->{w_size} = $s->{term}->ncol;
        $s->{y_size} = $s->{term}->nrow;
    }

    1;
}

sub on_refresh_end {
    my $s   = shift;
    my $str = $s->{term}->locale_encode("\e[0;0H\e[K");
    $s->{term}->cmd_parse($str);    #do not show the cursor!
    1;
}

# React on X Events (resize)
sub on_configure_notify {
    my $s = shift;
    return if $s->{w_size} eq $s->{term}->ncol && $s->{y_size} eq $s->{term}->nrow;
    refresh_bounds( $s, XR->{visual_align} );
    1;
}

# Forward all events to main terminal
for my $h (qw(key_press key_release)) {
    ## no critic
    eval qq{
    sub on_$h {
        my (\$s, \$e) = \@_;
        \$s->{xterms}{main}{term}->$h (\$e->{state}, \$e->{keycode}, \$e->{time}); 1; }
    };
}

# Forward all events to main terminal
for my $h (qw(focus_in focus_out)) {
    eval qq{ sub on_$h { (shift)->{xterms}{main}{term}->$h; 1; } };    ## no critic
}

sub on_wm_delete_window {

    # This is the root terminal.
    # Do not forward to prevent deletion of alread deleted child terminals.
    exit;
    1;
}

sub on_tt_write {

    # Forward all terminal output to main terminal
    (shift)->{xterms}{main}{term}->tt_write(shift);
    1;
}

#-------------------------------------------------
#   MAIN
#-------------------------------------------------

sub on_init {
    my ($s) = @_;
    XR->init($s);
    ();
}

sub on_start {
    my ($s) = @_;

    $s->{xterms}{main} = cdmn::term->new(
        parent   => $s,
        resource => XR,
        bg_color => 4,
        is_root  => 1
    )->maximize->show;

    $s->{xterms}{sidebar} = cdmn::sidebar->new(
        term => (
            cdmn::term->new(
                parent   => $s,
                resource => XR,
                x        => $s->width / 2,
                y        => 0,
                w        => $s->width / 2 + 1,
                h        => $s->fheight * ( $s->nrow ),
                bg_color => 5,
                is_root  => 0
            )->hide_cursor
            )->hide,
        fg         => XR->{sidebar_fg},
        bg         => XR->{sidebar_bg},
        bg_header  => XR->{sidebar_header_bg},
        fg_header  => XR->{sidebar_header_fg},
        fg_boarder => XR->{sidebar_boarder_fg},
        bg_boarder => XR->{sidebar_boarder_bg},
    );

    #$s->{xterms}{main}->hide if ( XR->{visual_align} eq CDMN->VISUAL_ALIGN_COL );

    $s->{w_size}      = $s->{term}->ncol;
    $s->{y_size}      = $s->{term}->nrow;
    $s->{captions}[0] = create_caption $s->{xterms}{main}{term};
    $s->{captions}[1] = create_caption $s;
    ${ $s->{captions}[0] }->create();
    ${ $s->{captions}[1] }->create();

    #$s->cmd_parse("\e[2T\e[2B"); #Scroll down and move cursor down 2 line.
    $s->cmd_parse("\033[?25l");    #do not show the cursor!

    #TODO WIP
    $s->{xterms}{sidebar}->add_pane($_) for ( @{ XR->{gauges_order} } );
    $s->{xterms}{sidebar}->add_pane('FS');
    $s->{xterms}{sidebar}{active_pane} = 0;

    $s->{visuals_updater} = urxvt::timer->new->start( int urxvt::NOW )->interval( XR->{refresh} )->cb(
        sub {
            my %r;

            local *_filter = sub {
                my %r;
                my %d = %{ $_[0] };
                $r{$_} = $d{$_} for @{ $_[1] };
                %r;
            };

            redraw( $s, XR->{showing_labels} ) if XR->set_disks->ok | XR->set_batteries->ok | XR->set_nics->ok;

            #say %{cdmn::proc::cpu_usages()};
            #say @{XR->{gauges_cpus}};
            my %usage_of;
            $usage_of{cpu}      = sub { _filter( cdmn::proc::cpu_usages(), XR->{gauges_cpus} ) };
            $usage_of{memory}   = sub { %{ cdmn::proc::memory_usages() } };
            $usage_of{cpu_temp} = sub { %{ cdmn::proc::cpu_temp_usages() } };
            $usage_of{battery}  = sub { %{ cdmn::proc::battery_usages() } };
            $usage_of{disk}     = sub { _filter( cdmn::proc::disk_usages(), XR->{gauges_disks} ) };
            $usage_of{network}  = sub { _filter( cdmn::proc::network_usages(), XR->{gauges_networks} ) };

            local *_set = sub {
                my $gauge_name = shift;
                my %inverts = map { $_ => 1 } @{ XR->{gauges_invert} };

                %r = $usage_of{$gauge_name}->();

                return 1 if scalar keys %r < 1;
                $s->{xterms}{sidebar}->set_pane( $gauge_name, \%r );
                $$_->set( $gauge_name, \%r, $inverts{$gauge_name} ) for @{ $s->{captions} };

                1;
            };

            #for (qw/memory/) { _set($_); } #does not work, why?
            #for my $v (qw/memory/) { _set($_); } #works, why?
            #for my $v ( @{ XR->{gauges_order} } ) { _set($v) };

            _set($_) foreach keys %{ ${ $s->{captions}[0] }->{gauges} };

            my $mounts = cdmn::proc::mounts;
            %r = map { $_ => df($_)->{per} } ( sort values %$mounts );
            $s->{xterms}{sidebar}->set_pane( 'FS', \%r ) if $s->{xterms}{sidebar}{visible};
        }
    );
    refresh_bounds( $s, XR->{visual_align} );
    ();
}

=head1 packages

=over

=item cdmn::math [static]

 Some general useful subs.

=item cdmn::constants [static]

 Constants used throughout this extension.

=item cdmn::proc [static]

 Static subs for accessing different parts of procfs.

=item cdmn::resources::single [class]

 A single resource represents the resource attributes of a visual element e.g. name, padding, bg, fg, colors, label, length, gauges, style and so on.
 Used bye cdmn::resources for creating resource instances.

=item cdmn::resources [class]

 Initialize and setup all (default) resources.

=item cdmn::sidebar [class]

 Wrapper around urxvt::xterm that can hold multiple panes or pages a user can navigate through.

=item cdmn::term [class]

 Wrapper around urxvt::term. Used as a central registry and for creating Instances.

=item cdmn::visuals::container [class]

 Container for cdmn::visuals:visual instances.

=item cdmn::visuals::visual [class]

 Simple visible element composed of a label and a gauge.

=back

=head1 Technical details

=over

=item Terminals

 There are three terminals that have to be considered, which are the root, main and sidebar terminal. The root terminal is also the original terminal for this extension. 
 
 The main terminal is the next layer on top of the root terminal an will be resized as necessary depending on which mode a user currently uses and what aligment is set. This technique was chosen to emulate the two different modes: normal and overlay. 
  
 Tecnically the two terminals are identical and show the same captions. But in overlay mode only the main terminal will be visible. In normal mode the main terminal will be resized to fit the users setttings. For example it will be on row smaller than the root terminal and and show the captions of the root terminal to give the impression of a fixed header.
 
 The sidebar is a terminal that will be present on user interaction. The different pages a implemented as overlays thad are shown/hidden while the user navigates through them.

  All actions caught on the root and sidebar terminal will be relayed to the main terminal.

=back

=cut
