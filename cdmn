#! perl -T

# cdmn is an extension written for the rxvt terminal emulator that shows
# utilizations of different system resoureces like cpu, disk i/o, ram,
# network (and more).

# Copyright (C) 2016-2017 Marcel Lautenbach
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use 5.10.1;
use strict;
use warnings FATAL => 'all';
use autodie;

use utf8;
use autodie;

use Filesys::Df;
use POSIX qw(ceil floor);

binmode STDOUT, ":encoding(UTF-8)";

package Null {
    my $null = bless {}, __PACKAGE__;
    sub AUTOLOAD {$null}
    sub ok       {0}
}

package cdmn::math {

    #return a ref. to a new set containing only the elements that exist in both given sets.
    sub cut_set {

        #TODO named parameters
        shift if scalar @_ > 2;    #drop first parameter if called as object
        my @cut = ();
        my %n   = ();

        for my $e ( @{ $_[0] }, @{ $_[1] } ) { $n{$e}++ }
        for my $e ( @{ $_[0] } ) { push @{ \@cut }, $e if $n{$e} > 1 }

        return \@cut;
    }

    sub union {

        #TODO named parameters
        shift if scalar @_ > 2;    #drop first parameter if called as object
        my @union = ();
        my %n     = ();

        for my $e ( @{ $_[0] }, @{ $_[1] } ) { $n{$e} = 1 if !exists $n{$e} }
        for my $e ( keys %n ) { push @{ \@union }, $e }

        return \@union;
    }
}

package cdmn::constants {
    use constant {
        ACTION_TOGGLE         => 'cdmn:show',
        ACTION_TOGGLE_LABELS  => 'cdmn:show-labels',
        ACTION_TOGGLE_SIDEBAR => 'cdmn:show-sidebar',
        ACTION_TOGGLE_OVERLAY => 'cdmn:action-show-transparent',

        ACTION_NEXT_PANE   => 'cdmn:action-next-pane',
        ACTION_PREV_PANE   => 'cdmn:action-prev-pane',
        ACTION_SCROLL_DOWN => 'cdmn:action-scroll-down',
        ACTION_SCROLL_UP   => 'cdmn:action-scroll-up',

        VISUAL_ALIGN_COL => 'col',
        VISUAL_ALIGN_ROW => 'row',

        STYLE_LED => 'led',
        STYLE_BAR => 'bar',

        LEFT   => 'left',
        RIGHT  => 'right',
        TOP    => 'top',
        BOTTOM => 'bottom',
        CENTER => 'center',

        CPU      => 'cpu',
        DISK     => 'disk',
        MEMORY   => 'memory',
        NETWORK  => 'network',
        CPU_TEMP => 'cpu_temp',
        BATTERY  => 'battery',
        MOUNT    => 'mount',
    };

    use constant REND => urxvt::SET_COLOR urxvt::OVERLAY_RSTYLE, 255, 1;
}

package cdmn::proc {
    use List::Util qw(sum max min);
    use Params::Validate qw(:all);
    use Filesys::Df;

    use constant {
        PROC_PARTITIONS => '/proc/partitions',
        PROC_MOUNTS     => '/proc/mounts',
        PROC_STAT       => '/proc/stat',
        PROC_DISKSTATS  => '/proc/diskstats',
        PROC_MEMINFO    => '/proc/meminfo',
        PROC_NET_ROUTE  => '/proc/net/route',

        SPEED     => 'speed',
        OPERSTATE => 'operstate',
        TX        => 'tx_bytes',
        RX        => 'rx_bytes',
        BAT_FULL  => 'full',
        BAT_NOW   => 'now',

        SYSFS_CPU_PRESENT => '/sys/devices/system/cpu/present',
        SYSFS_HWMON       => '/sys/class/hwmon/',
        SYSFS_NET         => '/sys/class/net/',
        SYSFS_BAT         => '/sys/class/power_supply/',
        SYSFS_BLOCK       => '/sys/block/',

        POSTFIX_TX    => '_tx',
        POSTFIX_RX    => '_rx',
        POSTFIX_READ  => '_read',
        POSTFIX_WRITE => '_write',
    };

    sub cpu_temp_usages {
        my %results;
        if ( -e SYSFS_HWMON ) {
            opendir( my $dh, SYSFS_HWMON );
            my @dir = readdir $dh;
            for (@dir) {
                next if $_ =~ /\A\.\.?\z/;
                my $p = SYSFS_HWMON . $_;
                open( my $f, '<', $p . "/name" ) || last;
                chomp( my $state = <$f> );
                if ( $state eq 'coretemp' ) {
                    opendir( $dh, $p );
                    @dir = readdir $dh;
                    my %cores = map { /(temp\d)/ ? ( ( $_ =~ /(temp\d)/ ), "" ) : () } @dir;
                    for ( keys %cores ) {
                        open( $f, '<', $p . "/" . $_ . "_input" );
                        chomp( my $cv = <$f> );
                        open( $f, '<', $p . "/" . $_ . "_crit" );
                        chomp( my $mv = <$f> );
                        open( $f, '<', $p . "/" . $_ . "_label" );
                        chomp( my $l = <$f> );
                        last if $l !~ /\ACore/;
                        $results{$l} = $cv / $mv * 100;
                    }
                    last;
                }
            }
            closedir $dh;
        }
        return \%results;
    }

    sub cores {
        my @results;
        opendir( my $dh, SYSFS_HWMON );
        my @dir = readdir $dh;
        for (@dir) {
            next if $_ =~ /\A\.\.?\z/;
            my $p = SYSFS_HWMON . $_;
            open( my $f, '<', $p . "/name" );
            chomp( my $state = <$f> );
            if ( $state eq 'coretemp' ) {
                opendir( $dh, $p );
                @dir = readdir $dh;
                my %cores = map { /(temp\d)/ ? ( ( $_ =~ /(temp\d)/ ), "" ) : () } @dir;
                for ( keys %cores ) {
                    open( $f, '<', $p . "/" . $_ . "_label" );
                    chomp( my $l = <$f> );
                    push @results, $l if $l =~ /\ACore/;
                }
                last;
            }
        }
        closedir $dh;
        return \@results;
    }

    sub sysfs_net {
        my $path = SYSFS_NET . "/$_[0]";
        return $path . "/statistics/$_[1]" if $_[1] && ( $_[1] eq TX        || $_[1] eq RX );
        return $path . "/$_[1]"            if $_[1] && ( $_[1] eq OPERSTATE || $_[1] eq SPEED );
        $path;
    }

    sub ac_online {
        opendir( my $dh, SYSFS_BAT );
        my @dir = readdir $dh;
        for (@dir) {
            if (/AC/) {
                open( my $f, '<', SYSFS_BAT . $_ . "/online" );
                chomp( my $state = <$f> );
                closedir $dh;
                return $state;
            }
        }
        closedir $dh;
        0;
    }

    sub has_wifi {
        opendir( my $dh, sysfs_net(shift) );
        my @dir = readdir $dh;
        for (@dir) { return 1 if (/wireless/); }
        closedir $dh;
        0;
    }

    sub network_down {
        open( my $f, '<', sysfs_net( shift, OPERSTATE ) );
        chomp( my $state = <$f> );

        # RFC2863 operational states: unknown notpresent down up lowerlayerdown testing dormant
        return 1 if $state =~ 'down|unknown|dormant';
        0;
    }

    sub network_list {
        my @ifs;
        opendir( my $dh, SYSFS_NET );
        my @dir = readdir $dh;
        for (@dir) {
            my $if = $_;
            next if (/\A\.\.?$|\Aveth/);
            if ( !has_wifi($if) ) {
                open( my $f, '<', sysfs_net( $if, SPEED ) );
                chomp( my @lines = <$f> );
                next if scalar @lines eq 0;
            }
            next if network_down($if);
            push @ifs, $if;
        }
        closedir $dh;
        return \@ifs;
    }

    sub mounts {
        open( my $f, '<', PROC_MOUNTS );
        my @mounts;
        my @m;
        my %mounts;
        for (<$f>) {
            @m = /(\A\/dev\S*)\s+([a-zA-Z0-9-_.\/]+)/;    #TODO this regex is too simple
            push @mounts, @m if @m and !exists $mounts{ $m[0] };
            %mounts = (@mounts);
        }
        return \%mounts;
    }

    sub fs_usage {
        my %r = map { $_ => df($_)->{per} } ( sort values %{ mounts() } );
        \%r;
    }

    sub battery_usages {
        local *sysfs_bat = sub {
            my $path = SYSFS_BAT . "/$_[0]";
            opendir( my $dh, $path );
            if ( $_[1] ) {
                my @dir = readdir $dh;
                for (@dir) {
                    $path .= "/" . $_ if /\Aenergy_full$|\Acharge_full$/ && $_[1] eq BAT_FULL;
                    $path .= "/" . $_ if /\Aenergy_now$|\Acharge_now$/   && $_[1] eq BAT_NOW;
                }
            }
            closedir $dh;
            $path;
        };

        my %results;
        my @bats = @{ batteries() };
        for (@bats) {
            my $bat = $_;
            open( my $f, '<', sysfs_bat( $bat, BAT_FULL ) );
            chomp( my $full = <$f> );
            open( $f, '<', sysfs_bat( $bat, BAT_NOW ) );
            chomp( my $now = <$f> );

            $results{$bat} = $now / $full * 100;
        }
        return \%results;
    }

    sub batteries {
        my @bats;
        opendir( my $dh, SYSFS_BAT );
        my @dir = readdir $dh;
        for (@dir) {
            my $bat = $_;
            next if (/\A\.\.?\z/);
            next if (/\AAC/);
            push @bats, $bat;
        }
        closedir $dh;
        return \@bats;
    }

    sub disks {
        opendir( my $dh, SYSFS_BLOCK );
        my @disks;
        my @dir = readdir $dh;
        for (@dir) {
            my $block = $_;
            next if (/\A\.\.?$|dm-|\Aloop|\Asr/);
            push @disks, $block;
        }
        closedir $dh;
        return \@disks;
    }

    sub dm_disks {
        opendir( my $dh, SYSFS_BLOCK );
        my %block;
        my @dir = readdir $dh;
        for (@dir) {
            my $block = $_;
            next if !(/\Adm-/);
            open( my $f, '<', SYSFS_BLOCK . "$block/dm/name" );
            chomp( my $d = <$f> );

            opendir( my $dh2, SYSFS_BLOCK . "$block/slaves" );
            $block{$d} = [ map {/(sd[a-z]|nvme\dn|mmcblk)/} readdir $dh2 ];
        }
        closedir $dh;
        return \%block;
    }

    sub disk_mounts {
        my @mounts = keys %{ mounts() };
        my @disks  = ( map { $_, 0 } @{ disks() } );
        my %dm     = %{ dm_disks() };
        my %disks  = @disks;

        for my $m (@mounts) {
            for my $k ( keys %disks ) {
                $disks{$k} = 1 if $m =~ /$k/;
            }
            while ( my ( $k, $v ) = each %dm ) {
                if ( $m =~ $k ) {
                    $disks{$_} = 1 for @$v;
                }
            }
        }

        @disks = ();
        while ( my ( $k, $v ) = each %disks ) {
            push @disks, $k if $v;
        }
        return \@disks;
    }

    sub cpu_usages {
        state %cpus;
        my $diff_usage = 0;
        my %results;

        open( my $f, '<', PROC_STAT );
        for (<$f>) {
            next if ( !/\Acpu[0-9]*\s+[0-9]+/ );

            my @cpu = split /\s+/;
            my $cpu = shift @cpu;

            if ( !exists $cpus{$cpu} ) {
                $cpus{$cpu}{$_} = 0 for qw/prev_idle prev_total diff_total/;
            }

            my $idle  = $cpu[3];
            my $total = sum(@cpu);

            my $diff_idle = $idle - $cpus{$cpu}{prev_idle};
            if ( $total != $cpus{$cpu}{prev_total} ) {
                $cpus{$cpu}{diff_total} = $total - $cpus{$cpu}{prev_total};
            }
            $diff_usage = 100 * ( $cpus{$cpu}{diff_total} - $diff_idle ) / $cpus{$cpu}{diff_total};

            $cpus{$cpu}{prev_idle}  = $idle;
            $cpus{$cpu}{prev_total} = $total;

            $results{$cpu} = $diff_usage;
        }
        return \%results;
    }

    sub cpu_count {
        open( my $f, '<', SYSFS_CPU_PRESENT );
        {
            local $/;
            my $cpus = <$f>;
            $cpus =~ /([0-9]+)-([0-9]+)|([0-9]+)/;
            return 1 + ( $2 ? $2 : $3 );
        }
    }

    sub disk_usages {
        my %diff_usage;
        state( %results, $n_stat, $o_stat );
        state $t = urxvt::NOW- 1;
        my $ct      = urxvt::NOW;
        my $refresh = $ct - $t;
        $t = $ct;

        open( my $f, '<', PROC_DISKSTATS );
        for (<$f>) {
            if ( !/\bsd(a|b|c)|nvme\dn\d\b|mmcblk\d\b/ ) {
                next;
            }
            my @sda = split /\s+/, $_;
            shift @sda for 1 .. 3;

            my $name = shift @sda;
            my $stats;

            @$stats{qw/r_ios r_merged r_sectors r_time w_ios w_merged w_sectors w_time in_progress io_time weighted/} = (@sda);
            $o_stat->{$name} //= $stats;
            $n_stat->{$name} //= $stats;

            $o_stat->{$name} = $n_stat->{$name};
            $n_stat->{$name} = $stats;

            $diff_usage{$_} = $n_stat->{$name}->{$_} - $o_stat->{$name}->{$_} for ( keys %$stats );

            $diff_usage{io_time} = $diff_usage{io_time} / ( 1000 * $refresh ) * 100;
            $diff_usage{io_time} = 100 if $diff_usage{io_time} > 100;

            my $w = 0;
            $w = $diff_usage{'w_ios'} / $diff_usage{'r_ios'} if $diff_usage{'r_ios'} > 0;
            my $r = $w < 1 ? 1 - $w : 1 - 1 / $w;

            $r *= $diff_usage{io_time};
            $w *= $diff_usage{io_time};

            $results{$name}                   = $diff_usage{io_time};
            $results{ $name . POSTFIX_READ }  = $r;
            $results{ $name . POSTFIX_WRITE } = $w;
        }
        return \%results;
    }

    sub memory_usages {
        my @sda;
        my $total     = 0;
        my $available = 0;
        my %results;

        open( my $f, '<', PROC_MEMINFO );
        for (<$f>) {
            if (/\AMemTotal:\s+[0-9]+/) {
                @sda = split /\s+/, $_;
                $total = $sda[1];
            }
            if (/\AMemAvailable:\s+[0-9]+/) {
                @sda = split /\s+/, $_;
                $available = $sda[1];
            }
        }

        $results{ $sda[0] } = 100 - ( 100 * $available / $total );
        return \%results;
    }

    sub network_usages {
        my %results;
        my $bytes = 0;
        state %nics;
        state $t = urxvt::NOW- 1;
        my $ct      = urxvt::NOW;
        my $refresh = $ct - $t;
        $t = $ct;

        local *_set = sub {
            my $nic       = shift;
            my $direction = shift;
            open( my $f, '<', sysfs_net( $nic, $direction ) );
            {
                local $/;
                $bytes = <$f>;
            }

            my $diff_rx = $bytes - $nics{$nic}{$direction};
            $nics{$nic}{$direction} = $bytes;
            my $diff_usage = $diff_rx / ( network_speed($nic) * $refresh ) * 100;
            $results{ $nic . ( $direction eq RX ? POSTFIX_RX : POSTFIX_TX ) } = $diff_usage;
        };

        for ( @{ network_list() } ) {
            my $nic = $_;
            if ( !exists $nics{$nic} ) {
                $nics{$nic}{$_} = 0 for ( RX, TX );
            }
            _set( $nic, RX );
            _set( $nic, TX );

        }
        return \%results;
    }

    sub network_default {
        open( my $fh, '<', PROC_NET_ROUTE );

        my $if = <$fh>;
        $if = <$fh>;

        my @wif = split /\s+/, $if;
        $wif[0];
    }

    sub network_speed {
        my $if = shift;
        my $speed;
        state $refresh = 4;
        state $wifispeed;
        if ( has_wifi($if) ) {
            if ( $refresh >= 4 ) {
                $refresh = 0;
                my $c = qx/sudo iwconfig $if/;
                ($wifispeed) = $c =~ /Bit Rate.(\d*\.{0,1}\d*)/;
                $speed = $wifispeed;
            }
            else {
                $refresh++;
                $speed = $wifispeed;
            }
        }
        else {
            open( my $fh, '<', sysfs_net( $if, SPEED ) );
            $speed = <$fh>;
        }
        $speed *= 1000000 / 8;
        return $speed;
    }

    sub needs_refresh {
        my $r = shift;
        state $t = 0;
        my $ct = urxvt::NOW;

        return 0 if ( $ct - $t ) < $r;
        $t = $ct;
        1;
    }
}

package cdmn::resources::single {
    use Params::Validate qw(:all);
    use fields qw(
        name
        padding
        bg
        fg
        colors
        label
        length
        gauges
        style
        visual
        detail
    );

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        (%$s) = validate(
            @_,
            {   name    => 1,
                padding => 1,
                fg      => 1,
                bg      => 1,
                colors  => 1,
                label   => 1,
                length  => 1,
                gauges  => 1,
                detail  => 1,
                visual  => 1,
            }
        );
        $s;
    }
}

package cdmn::resources {
    use Scalar::Util qw(looks_like_number);

    use fields qw(
        ok
        x y
        showing
        showing_labels
        caption_bg

        disk_mounts_only
        refresh
        sensitivity

        detail
        invert

        padding
        visual_style
        visual_align

        resources
        defaults
        gauges
        labels
        mounts
        colors
        sidebar

        graph_length
        graph_expand

        keysyms
    );

    use constant {
        POSTFIX_TX    => '_tx',
        POSTFIX_RX    => '_rx',
        POSTFIX_READ  => '_read',
        POSTFIX_WRITE => '_write',

        CDMN => 'cdmn::constants',
        MATH => 'cdmn::math',
        PROC => 'cdmn::proc',
    };

    use constant DEFAULT_ORDER     => (qw/ cpu cpu_temp disk memory network battery mount /);
    use constant STYLES            => ( CDMN->STYLE_BAR, CDMN->STYLE_LED );
    use constant VISUAL_ALIGNMENTS => ( CDMN->VISUAL_ALIGN_COL, CDMN->VISUAL_ALIGN_ROW );
    use constant TBLRC             => ( CDMN->TOP, CDMN->LEFT, CDMN->RIGHT, CDMN->BOTTOM, CDMN->CENTER );
    use constant TB => ( CDMN->TOP, CDMN->BOTTOM );
    use constant LR => ( CDMN->LEFT, CDMN->RIGHT );

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        return $s;
    }

    sub init {
        my $s = shift;
        my $t = shift;

        local *_set_list = sub {
            my $r = $t->x_resource("$_[0]");
            $r = $t->locale_decode($r) if $r;
            return [ split( /[,[:space:]]+/, $r ) ]    if $r;
            return [ split( /[,[:space:]]+/, $_[1] ) ] if $_[1];
            [ () ];
        };

        local *_set_number = sub {
            my $n = $t->x_resource(shift);
            $n = looks_like_number($n) ? $n : return shift;
            shift;
            $n = $_[0] if $_[0] and $n < $_[0];
            $n = $_[1] if $_[1] and $n > $_[1];
            $n;
        };

        local *_set_boolean = sub {
            my $n = $t->x_resource_boolean(shift);
            return $n ? $n : shift;
        };

        local *_set_value = sub {
            my $n = $t->x_resource("$_[0]");
            my @r;
            @r = grep( /$n/, @{ $_[1] } ) if $n;
            return ( @r ? shift @r : $_[2] );
        };

        local *_validate = sub {
            my @order_default = map { $s->{labels}{$_} } @{ $_[1] };

            return \@order_default if scalar @{ $_[0] } eq 0;
            return MATH->cut_set( $_[0], \@order_default );
        };

        local *_set_colors = sub {
            for (DEFAULT_ORDER) {

                # If a specific list of colors is defined, take it, otherwise use default colors.
                # Make sure values are numbers and add 2.
                # We have to add 2 because urxvt uses 0 and 1 for references to the terminals fg and bg colors.
                $s->set_colors(
                    $_,
                    [   map { $_ + 2 }
                        grep ( looks_like_number($_), ( @{ $s->get_colors($_) } ? @{ $s->get_colors($_) } : @{ $s->get('gauges_colors') } ) )
                    ]
                );
            }
        };

        local *_set_cores = sub {
            my $cpus = cdmn::proc::cpu_count() - 1;
            $s->set_gauges( 'cpus', [ map "cpu" . $_, 0 .. $cpus ] );
            $s;
        };

        local *_set_mounts = sub {
            my $ov = $s->get_gauges('mounts') ? scalar @{ $s->get_gauges('mounts') } : 0;
            $s->set_gauges( 'mounts', MATH->cut_set( [ values %{&cdmn::proc::mounts} ], $s->get_gauges('mounts') ) );
            $s->set_gauges( 'mounts', [ values %{&cdmn::proc::mounts} ] ) if scalar @{ $s->get_gauges('mounts') } eq 0;
            $ov != scalar @{ $s->get_gauges('mounts') } ? $s->{ok} = 1 && return $s : Null->new;
        };

        local *_set_panes = sub {
            $s->set_sidebar( 'panes_order', _validate( $s->get_sidebar('panes_order'), [DEFAULT_ORDER] ) );
            $s->set_sidebar( 'panes_order', $s->remap( $s->get_sidebar('panes_order') ) );
        };

        local *_set_order = sub {
            $s->set( 'gauges_order', _validate( $s->get('gauges_order'), [DEFAULT_ORDER] ) );
            $s->set( 'gauges_order', $s->remap( $s->get('gauges_order') ) );
        };

        $s->set_label( 'network',  $t->x_resource('%.label.network')  // 'NET' );
        $s->set_label( 'disk',     $t->x_resource('%.label.disk')     // 'DISK' );
        $s->set_label( 'cpu',      $t->x_resource('%.label.cpu')      // 'CPU' );
        $s->set_label( 'cpu_temp', $t->x_resource('%.label.cpu_temp') // 'TEMP' );
        $s->set_label( 'memory',   $t->x_resource('%.label.memory')   // 'MEM' );
        $s->set_label( 'battery',  $t->x_resource('%.label.battery')  // 'BAT' );
        $s->set_label( 'mount',    $t->x_resource('%.label.mount')    // 'MOUNT' );
        $s->set_label( 'battery_AC', $s->get_label('battery') . "(⌁)" );

        $s->set( 'label_fg', _set_number( '%.label.fg', 0 ) );
        $s->set( 'label_bg', _set_number( '%.label.bg', 1 ) );
        $s->set( 'label_position', _set_value( '%.label.position', [LR], CDMN->LEFT ) );
        $s->set( 'label_padding', _set_number( '%.label.padding', 0 ) );
        $s->set( 'label_bold',    _set_boolean( '%.label.bold',    0 ) );

        $s->{showing}        = _set_number( '%.showing',        1 );
        $s->{showing_labels} = _set_number( '%.showing.labels', 1 );

        $s->{visual_align} = _set_value( '%.visual.alignment', [VISUAL_ALIGNMENTS], CDMN->VISUAL_ALIGN_ROW );
        $s->{caption_bg} = _set_number( '%.caption.bg', 1 );    # 0/1 map onto terminal fg/bg color

        $s->set('padding', _set_number( '%.padding',  2 ) );     #Padding between visuals
        $s->{x}                = _set_number( '%.x',               -1 );    #positive from left, negativ from right
        $s->{y}                = _set_number( '%.y',               0 );     #positive from top, negativ from bottom
        $s->{disk_mounts_only} = _set_number( '%.disk.mountsonly', 1 );     #TODO rename
        $s->{refresh}          = _set_number( '%.refresh',         1 );
        $s->{sensitivity}      = _set_number( '%.sensitivity',     1 );     #percentage

        $s->set( 'gauges_order', _set_list('%.gauges.order') );
        $s->set_gauges( 'disks',       _set_list('%.gauges.disks') );
        $s->set_gauges( 'disks_read',  _set_list('%.gauges.disks.read') );
        $s->set_gauges( 'disks_write', _set_list('%.gauges.disks.write') );
        $s->set_gauges( 'network_rx',  _set_list('%.network.rx') );
        $s->set_gauges( 'network_tx',  _set_list('%.network.tx') );
        $s->set_gauges( 'mounts',      _set_list('%.gauges.mounts') );
        $s->set_gauges( 'batteries',   _set_list('%.gauges.batteries') );
        $s->set_gauges( 'cpu_temps',   _set_list('%.gauges.cores') );
        $s->set_gauges( 'memory', ["MemAvailable:"] );

        $s->set( 'gauges_colors', _set_list( '%.gauges.colors', '-1,-2' ) );    #TODO no negative colors

        for (DEFAULT_ORDER) {
            $s->set_colors( $_, _set_list("%.$_.colors") );
            $s->set_graph_width( $_, _set_number( "%.$_.graph.width", 0 ) );
            $s->set_graph_expand( $_, _set_boolean( "%.$_.graph.expand", 0 ) );
            $s->set_visual_style( $_, _set_value( "%.$_.visual.style", [STYLES], CDMN->STYLE_BAR ) );
            $s->set_invert( $_, _set_boolean( "%.$_.invert", 0 ) );
            $s->set_detail( $_, _set_boolean( "%.$_.detail", 0) );
        }

        $s->set_sidebar( 'fg',        _set_number( '%.sidebar.fg',        9 ) );
        $s->set_sidebar( 'bg',        _set_number( '%.sidebar.bg',        0 ) );
        $s->set_sidebar( 'border_fg', _set_number( '%.sidebar.border.fg', 7 ) );
        $s->set_sidebar( 'width',     _set_number( '%.sidebar.width',     50, 30, 100 ) );    #percentage
        $s->set_sidebar( 'height',    _set_number( '%.sidebar.height',    40, 30, 100 ) );    #percentage
        $s->set_sidebar( 'position',        _set_value( '%.sidebar.position',        [TBLRC], CDMN->RIGHT ) );
        $s->set_sidebar( 'header_position', _set_value( '%.sidebar.header.position', [TB],    CDMN->BOTTOM ) );
        $s->set_sidebar( 'label_position',  _set_value( '%.sidebar.label.position',  [TB],    CDMN->TOP ) );
        $s->set_sidebar( 'graph_symbols', _set_list( '%.sidebar.graph.symbols', '■, □' ) );
        $s->set_sidebar( 'border_visible', _set_number( '%.sidebar.border.visible', 1 ) );
        $s->set_sidebar( 'panes_order', _set_list('%.sidebar.panes.order') );

        # $s->set_sidebar( 'enable', _set_number('%.sidebar.panes.enable', 1) ); #TODO

        $s->set_keysym( CDMN->ACTION_TOGGLE,         $t->x_resource('%.keysym.toggle')              // 'M-h' );
        $s->set_keysym( CDMN->ACTION_TOGGLE_SIDEBAR, $t->x_resource('%.keysym.sidebar.toggle')      // 'M-p' );
        $s->set_keysym( CDMN->ACTION_TOGGLE_OVERLAY, $t->x_resource('%.keysym.overlay.toggle')      // 'M-o' );
        $s->set_keysym( CDMN->ACTION_TOGGLE_LABELS,  $t->x_resource('%.keysym.lables.toggle')       // 'M-l' );
        $s->set_keysym( CDMN->ACTION_NEXT_PANE,      $t->x_resource('%.keysym.sidebar.pane.next')   // 'M-k' );
        $s->set_keysym( CDMN->ACTION_PREV_PANE,      $t->x_resource('%.keysym.sidebar.pane.prev')   // 'M-j' );
        $s->set_keysym( CDMN->ACTION_SCROLL_UP,      $t->x_resource('%.keysym.sidebar.scroll.up')   // 'C-k' );
        $s->set_keysym( CDMN->ACTION_SCROLL_DOWN,    $t->x_resource('%.keysym.sidebar.scroll.down') // 'C-j' );

        $s->set_disks;
        $s->set_batteries;
        $s->set_nics;

        ## no critic
        eval qq/_set_$_/ for qw/cores order colors panes mounts/;

        for ( @{ $s->get('gauges_order') } ) {
            ( my $t = $_ ) =~ s/y$/ie/;
            $s->{resources}{$_} = cdmn::resources::single->new(
                name    => $_,
                padding => $s->get('label_padding'),
                fg      => $s->get('label_fg'),
                bg      => $s->get('label_bg'),
                colors  => $s->get_colors($_),
                label   => $s->get_label($_),
                length  => $s->get_graph_expand($_) ? -1 : $s->get_graph_width($_),
                gauges  => $_ eq 'memory' ? $s->get_gauges($_) : $s->get_gauges("${t}s"),
                detail  => $s->get_detail($_),
                visual  => $s->get_visual_style($_),
            );
        }
    }

    #TODO expand or delete
    sub resources {
        my ( $s, $t ) = @_;
        $s->{resources}{$t}{label} = PROC->ac_online() ? $s->get_label('battery_AC') : $s->get_label('battery') if $t eq 'battery';
        $s->{resources}{$t};
    }

    sub get_sidebar {
        my $s = shift;
        $s->{sidebar}{ $_[0] };
    }

    sub set_sidebar {
        my $s = shift;
        $s->{sidebar}{ $_[0] } = $_[1];
        $s;
    }

    sub set_gauges {
        my $s = shift;
        $s->{gauges}{ $_[0] } = $_[1];
        $s;
    }

    sub add_gauges {
        my $s = shift;
        push @{ $s->{gauges}{ $_[0] } }, @{ $_[1] };
        $s;
    }

    sub get_gauges {
        my $s = shift;
        $s->{gauges}{ $_[0] };
    }

    sub set_colors {
        my ( $s, $k, $v ) = @_;
        $s->{colors}{$k} = $v;
        $s;
    }

    sub get_colors {
        my $s = shift;
        $s->{colors}{ $_[0] };
    }

    sub set_invert {
        my ( $s, $k, $v ) = @_;
        $s->{invert}{$k} = $v;
        $s;
    }

    sub get_invert {
        my $s = shift;
        $s->{invert}{ $_[0] };
    }

    sub set_detail {
        my ( $s, $k, $v ) = @_;
        $s->{detail}{$k} = $v;
        $s;
    }

    sub get_detail {
        my $s = shift;
        $s->{detail}{ $_[0] };
    }

    sub set_graph_width {
        my ( $s, $k, $v ) = @_;
        $s->{graph_length}{$k} = $v;
        $s;
    }

    sub get_graph_width {
        my $s = shift;
        $s->{graph_length}{ $_[0] };
    }

    sub set_graph_expand {
        my ( $s, $k, $v ) = @_;
        $s->{graph_expand}{$k} = $v;
        $s;
    }

    sub get_graph_expand {
        my $s = shift;
        $s->{graph_expand}{ $_[0] };
    }

    sub set_visual_style {
        my ( $s, $k, $v ) = @_;
        $s->{visual_style}{$k} = $v;
        $s;
    }

    sub get_visual_style {
        my $s = shift;
        $s->{visual_style}{ $_[0] };
    }

    sub set_label {
        my $s = shift;
        $s->{labels}{ $_[0] } = $_[1];
        $s;
    }

    sub get_label {
        my $s = shift;
        $s->{labels}{ $_[0] };
    }

    sub set {
        my $s = shift;
        $s->{defaults}{ $_[0] } = $_[1];
        $s;
    }

    sub get {
        my $s = shift;
        $s->{defaults}{ $_[0] };
    }

    sub get_keysym {
        my $s = shift;
        $s->{keysyms}{ $_[0] };
    }

    sub set_keysym {
        my $s = shift;
        $s->{keysyms}{ $_[0] } = $_[1];
    }

    #TODO I do not like it, have to think of something else
    sub remap {
        my $s = shift;
        my %l = (
            $s->{labels}{cpu}      => cdmn::constants::CPU,
            $s->{labels}{disk}     => cdmn::constants::DISK,
            $s->{labels}{memory}   => cdmn::constants::MEMORY,
            $s->{labels}{network}  => cdmn::constants::NETWORK,
            $s->{labels}{cpu_temp} => cdmn::constants::CPU_TEMP,
            $s->{labels}{battery}  => cdmn::constants::BATTERY,
            $s->{labels}{mount}    => cdmn::constants::MOUNT,
        );

        [ map { $l{$_} } @{ +shift } ];
    }

    sub set_nics {
        my $s           = shift;
        my $nics_active = cdmn::proc->network_list;
        my $ov          = $s->get_gauges('networks') ? scalar @{ $s->get_gauges('networks') } : 0;

        my $rx_tx = MATH->cut_set( $s->get_gauges('network_tx'), $nics_active );
        my @tx = map { $_ . POSTFIX_TX } @$rx_tx;

        $rx_tx = MATH->cut_set( $s->get_gauges('network_rx'), $nics_active );
        my @rx = map { $_ . POSTFIX_RX } @$rx_tx;

        if ( ( scalar @tx eq 0 and scalar @rx eq 0 ) || ( @{ $s->get_gauges('network_rx') } && @{ $s->get_gauges('network_tx') } ) ) {
            $s->set_gauges( 'networks', [ map { $_ . POSTFIX_RX, $_ . POSTFIX_TX } @$nics_active ] );
        }
        else { $s->set_gauges( 'networks', [ @rx, @tx ] ); }
        $ov != scalar @{ $s->get_gauges('networks') } ? $s->{ok} = 1 && return $s : Null->new;
    }

    sub set_disks {
        my $s = shift;
        my $ov = $s->get_gauges('disks') ? @{ $s->get_gauges('disks') } : 0;

        $s->set_gauges( 'disks', $s->{disk_mounts_only}
            ? MATH->cut_set( PROC->disk_mounts, $s->get_gauges('disks') )
            : MATH->cut_set( PROC->disks,       $s->get_gauges('disks') ) );

        my $rw
            = $s->{disk_mounts_only}
            ? MATH->cut_set( PROC->disk_mounts, $s->get_gauges('disks_read') )
            : MATH->cut_set( PROC->disks,       $s->get_gauges('disks_read') );

        my @r = map { $_ . POSTFIX_READ } @$rw;

        $rw
            = $s->{disk_mounts_only}
            ? MATH->cut_set( PROC->disk_mounts, $s->get_gauges('disks_write') )
            : MATH->cut_set( PROC->disks,       $s->get_gauges('disks_write') );

        my @w = map { $_ . POSTFIX_WRITE } @$rw;

        $s->set_gauges( 'disks', ( $s->{disk_mounts_only} ? PROC->disk_mounts : PROC->disks ) )
            if !@{ $s->get_gauges('disks') } && !@r && !@w;

        $s->add_gauges( 'disks', [ ( @r, @w ) ] );

        $ov != @{ $s->get_gauges('disks') } ? $s->{ok} = 1 && return $s : Null->new;
    }

    sub ok { (shift)->{'ok'} }

    #TODO I think thins whole method has to be thought over!
    sub has_content {
        my $s = shift;
        my %c;
        $c{cpu_temp} = @{ $s->get_gauges('cpu_temps') };
        $c{cpu}      = 1;
        $c{disk}     = @{ $s->get_gauges('disks') } > 0 || @{ $s->get_gauges('disks_write') } > 0 || @{ $s->get_gauges('disks_read') } > 0;
        $c{memory}   = 1;
        $c{network}  = @{ $s->get_gauges('networks') };
        $c{battery}  = $s->get_gauges('batteries');
        $c{mount}    = $s->get_gauges('mounts');
        exists $c{ $_[0] } ? $c{ $_[0] } : 0;
    }

    sub gauges {
        my $s = shift;
        my %g;
        for(DEFAULT_ORDER) {
            $g{$_} = ( $s->resources($_)->{detail} ? $s->get_gauges("${_}s") : ["simple"] ) if $s->has_content($_);
        }
        return %g;
    }

    for my $h (qw(batteries cpu_temps)) {
        ## no critic
        eval qq{
            sub set_$h {
                my \$s = shift;
                my \$ov = \$s->get_gauges($h) ? scalar \@{\$s->get_gauges($h)} : 0;
                \$s->set_gauges($h, MATH->cut_set(cdmn::proc::$h, \$s->get_gauges($h)));
                \$s->set_gauges($h, cdmn::proc::$h) if scalar \@{\$s->get_gauges($h)} eq 0;
                \$ov != scalar \@{\$s->get_gauges($h)} ? \$s->{ok} = 1 && return \$s : Null->new;
            }
        }
    }
}

package cdmn::sidebar {
    use Params::Validate qw(:all);
    use POSIX qw(ceil floor);
    use constant { REND => cdmn::constants::REND, };

    my %s;
    my @headers = ();
    my %scroll_i;
    my %data;

    use fields qw(
        term
        parent
        keysyms

        x y
        width
        height

        panes
        data
        active_pane
        visible
        order

        bg
        fg
        fg_border
        border_position
        header_position
        label_position
        graph_symbols
        border_visible
    );

    use constant {
        TL       => "┏",
        TR       => "┓",
        BL       => "┗",
        BR       => "┛",
        M        => "━",
        TD       => "▔",
        BD       => "▁",
        VD       => "┃",
        ARR_L    => "❮",
        ARR_R    => "❯",
        SPACE    => " ",
        BORDER_L => "▏",
        BORDER_R => "▕",
    };

    use constant {
        LEFT   => 'left',
        RIGHT  => 'right',
        TOP    => 'top',
        BOTTOM => 'bottom',
    };

    use constant {
        ARR_UP   => "▲",
        ARR_DOWN => "▼",
    };

    use constant { SCROLL_UP => 'up', SCROLL_DOWN => 'down' };

    #TODO method name and return value
    #TODO this method is way too big!
    $s{create_pane} = sub {
        my @header;
        my ( $s, $title, $args ) = @_;
        $data{$title} = {%$args} if $args;    #TODO Cannot use $args as ref directly? So, deref. and new ref.

        my $r = REND;
        $r = urxvt::SET_FGCOLOR REND, $s->{fg};

        local *create_header_line = sub {
            my ( $c, $h, @l ) = @_;

            return "" if !$h;
            return (
                $s->{header_position} eq TOP
                ? TL . M x( ( length $c ) + 2 ) . TR
                : BL . M x( ( length $c ) + 2 ) . BR
                )
                . create_header_line( $c, @l )
                if $c eq $h;

            " " x ( ( length $h ) + 3 ) . create_header_line( $c, @l );
        };

        local *create_header = sub {
            my $c = shift;
            local *_create = sub {
                my ( $f, $h, @l ) = @_;
                return " " . VD . " " if !$h && $f;
                return "   " if !$h;
                return " " . VD . " " . $h . _create( $c eq $h, @l ) if $c eq $h;
                return " " . VD . " " . $h . _create( 0,        @l ) if $f;
                "   " . $h . _create( $f, @l );
            };
            _create( 0, @_ );

        };

        local *_overlay = sub {
            state $i = 0;
            cdmn::visuals::overlay->new(
                {   term      => $s->{term},
                    x         => $s->{border_position} eq LEFT ? 1 : 2,
                    y         => $i++,                                                  #TODO
                    width     => $s->{term}->ncol - ( $s->{border_visible} ? 3 : 2 ),
                    height    => 1,
                    rendition => $r,
                    text      => (shift),
                }
            );
        };

        local *_center = sub {
            my $header = shift;
            my $n = $s->{term}->ncol - ( length($header) );
            $n = $n % 2 ? ceil( $n / 2 ) : $n / 2;
            " " x $n . $header if $n > 0;
        };

        local *_headers = sub {
            my $len = $s->{term}->ncol - 9;    #TODO as parameter
            my @l   = @{ +shift };
            my $c   = shift;
            my @r   = @{ +shift };

            local *_strlen = sub {
                length( join( "", @l ) . $c . join( "", @r ) ) + ( ( @l + @r + 2 ) * 3 );
            };

            while () {
                if ( @l > @r ) {
                    shift @l if _strlen() gt $len;
                }
                elsif ( @r > @l ) {
                    pop @r if _strlen() gt $len;
                }
                else {
                    shift @l if _strlen() gt $len;
                    pop @r   if _strlen() gt $len;
                }

                #use () with le, or use <, otherwise it hangs!
                return ( @l, $c, @r ) if ( _strlen() ) le $len || ( @l eq 0 and @r eq 0 );
            }
        };

        local *_pad = sub {
            my ( $h, $l, $r ) = @_;
            my @h1 = @{ $_[-2] };
            my @h2 = @{ $_[-1] };
            $h = " $l " . $h if exists $h1[0]  && exists $h2[0]  && $h1[0] ne $h2[0];
            $h = $h . " $r " if exists $h1[-1] && exists $h2[-1] && $h1[-1] ne $h2[-1];
            $h;
        };

        local *_splice = sub {
            my $t = shift;
            my @h = @{ +shift };
            [ splice( @h, 0, $t ) ], shift @h, [ ( splice( @h, 0 ) ) ];
        };

        # BORDER
        if ( $s->{border_position} =~ m/^${\(LEFT)}|^${\(RIGHT)}/ && $s->{border_visible} ) {
            $r = urxvt::SET_FGCOLOR REND, $s->{fg_border};
            push @header, _overlay( $s->{border_position} eq LEFT ? BORDER_R : BORDER_L );
            $header[-1]->{x}      = $s->{border_position} eq LEFT                         ? -1 : 0;
            $header[-1]->{width}  = $s->{border_position} =~ m/^(${\(LEFT)}|${\(RIGHT)})/ ? 1  : $s->{term}->ncol;
            $header[-1]->{height} = $s->{border_position} =~ m/^(${\(TOP)}|${\(BOTTOM)})/ ? 1  : $s->{term}->nrow;
            $header[-1]->{repeat} = 1;
        }

        $r = urxvt::SET_FGCOLOR REND, $s->{fg};

        # HEADER
        my %hi = map { $headers[$_] => $_ } 0 .. @headers - 1;
        my @headers2 = exists $hi{$title} ? _headers( _splice( $hi{$title}, \@headers ) ) : ();

        push @header, _overlay( _center( _pad( create_header_line( $title, @headers2 ), SPACE, SPACE, \@headers, \@headers2 ) ) );
        $header[-1]->{x} = 0;

        push @header, _overlay( _center( _pad( create_header( $title, @headers2 ), ARR_L, ARR_R, \@headers, \@headers2 ) ) );
        $header[-1]->{x} = 0;

        # LINE
        push @header, _overlay( $s->{header_position} eq TOP ? TD : BD );
        $header[-1]->{repeat} = 1;
        $header[-1]->{x}      = 0;
        $header[-1]->{width}  = $s->{term}->ncol;

        #CONTENT
        $scroll_i{$title}{&SCROLL_UP}   //= 0;
        $scroll_i{$title}{&SCROLL_DOWN} //= 0;

        my @content;
        my @slctn = ( sort keys %{ $data{$title} } );

        for (@slctn) {
            push @content, _overlay($_) if $s->{label_position} eq TOP;

            my $w = $s->{term}->ncol - 8;                        #TODO 2 border,space + 4 number% + 1 space
            my $c = floor( $w * $data{"$title"}->{$_} / 100 );
            $c = 0 if $c < 0;
            my $f = $c <= $w ? $w - $c : 0;                      #should only be necessary on startup
            push @content, _overlay( $s->{graph_symbols}[0] x $c . $s->{graph_symbols}[1] x $f . " " . floor( $data{$title}->{$_} ) . "%" );
            push @content, _overlay($_) if $s->{label_position} eq BOTTOM;
        }

        #TODO maybe for label visible but otherwise should be always a cluster of label and graph?!
        #my $lp     = ( $s->{label_position} eq TOP ? 2 : 1 );
        my $lp     = 1;
        my $sup    = $scroll_i{$title}{&SCROLL_UP};
        my $delta  = floor( ( @header + @content - $s->{term}->nrow ) / $lp );
        my $rest   = ( @header + @content - $s->{term}->nrow ) % $lp;
        my $cntlen = ( @content / ( $s->{label_position} eq TOP ? 2 : 1 ) );
        my $sdown  = $scroll_i{$title}{&SCROLL_DOWN} = $delta - $sup;

        local *_down = sub {
            pop @content;
            if (@content) {
                $content[-1] = _overlay( _center(ARR_DOWN) );
                $content[-1]->{y} = -1;
            }
        };

        local *_up = sub {
            shift @content;
            if (@content) {
                $content[0] = _overlay( _center(ARR_UP) );
                $content[0]->{y} = $header[-1]->{y} + 1;
            }
        };

        if ( $cntlen > 0 ) {
            if ( $sup > 0 && $delta > 0 ) {
                @content = splice( @content, $sup * $lp );
                $_->{y} -= 2 for @content;
            }
            @content = splice( @content, 0, -$sdown * $lp ) if $sdown > 0;
        }

        _down() if $sdown gt 0 && $delta > 0 && @content > 0;
        _up()   if $sup gt 0   && $delta > 0 && @content > 0;

        if ( $rest > 0 && $delta eq 0 && @content > 0 ) {
            if ( $sup gt 0 ) {
                _up();
                $_->{y} -= 1 for @content;
                $content[0]->{y} += 1;
            }
            elsif ( $sdown le 0 ) { _down() }
        }

        #MOVE HEADER TO BOTTOM, IF CONFIGURED.
        my @data = ( @header, @content );

        if ( $s->{header_position} eq BOTTOM ) {
            if ( $s->{border_position} =~ m/^${\(LEFT)}|${\(RIGHT)}/ && $s->{border_visible} ) {
                push @data, ( reverse splice @data, 1, 3 );    #TODO remove hardcoded numbers
            }
            else {
                push @data, ( reverse splice @data, 0, 3 );    #TODO remove hardcoded numbers
            }
            $data[$_]->{y} = $_ for 0 .. $#data;
            $data[$_]->{y} = $_ for -3 .. -1;
        }

        $_->create->hide for @data;
        return \@data;
    };

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        (%$s) = validate(
            @_,
            {   parent          => 1,
                x               => { default => 0 },
                y               => { default => 0 },
                width           => { default => 0 },
                height          => { default => 0 },
                visible         => { default => 0 },
                bg              => 1,
                fg              => 1,
                fg_border       => 1,
                border_position => 1,
                header_position => 1,
                label_position  => 1,
                graph_symbols   => 1,
                border_visible  => 1,
                keysyms => 0,
            }
        );

        $s->{term} = cdmn::term->new(
            parent   => $s->{parent},
            x        => $s->{x},
            y        => $s->{y},
            w        => $s->{width},
            h        => $s->{height},
            bg_color => $s->{bg},
            keysyms  => $s->{keysyms},
            bare     => 1,

            # bg_color => 8,
            is_root => 0
        );
        $s->{term}->hide if !$s->{visible};

        $s->{order} = ();
        $s;
    }

    sub hide {
        my $s = shift;
        ($s)->{term}->hide;
        $s->{visible} = 0;
        $s;
    }

    sub show {
        my $s = shift;
        $s->{term}->show;
        $s->{visible} = 1;
        $s;
    }

    sub hide_cursor {
        my $s = shift;
        $s->{term}->hide_cursor;
        $s;
    }

    sub toggle {
        my $s = shift;
        $s->{visible} = !$s->{visible};
        $s->{term}->toggle;
        $s->show_pane( $s->{order}[ $s->{active_pane} ] );
        $s;
    }

    sub bounds {
        my $s = shift;
        $s->{term}->bounds(@_);
        $s;
    }

    sub show_pane {
        my ( $s, $title ) = (@_);
        return if !$s->{visible};
        $s->hide_pane($_) for keys %{ $s->{panes} };    #just to make sure we hide everything
        for ( @{ $s->{panes}{$title} } ) {
            $_->show if $_->{y} < $s->{term}->nrow;
        }

        $s;
    }

    sub hide_pane {
        my ( $s, $title ) = (@_);
        return if !$s->{visible};

        $_->hide for @{ $s->{panes}{$title} };
        $s;
    }

    sub set_pane {
        my ( $s, $title, $args ) = (@_);
        $s->{panes}{$title} = $s{create_pane}->( $s, $title, $args );
        $s->show_pane($title) if $title eq $s->{order}[ $s->{active_pane} ];
        $s;
    }

    sub next_pane {
        my $s = shift;
        $s->goto_pane(+1);
        $s;
    }

    sub prev_pane {
        my $s = shift;
        $s->goto_pane(-1);
        $s;
    }

    sub goto_pane {
        my $s  = shift;
        my $ap = $s->{active_pane};
        $s->hide_pane( $s->{order}[$ap] );
        $ap += (shift);
        $ap = 0 if $ap ge scalar @{ $s->{order} };
        $ap = @{ $s->{order} } - 1 if $ap lt 0;
        $s->{active_pane} = $ap;
        $s->show_pane( $s->{order}[$ap] );
        $s;
    }

    sub add_pane {
        my ( $s, $title, $args ) = (@_);
        $s->{panes}{$title} = $s{create_pane}->( $s, $title, $args );
        push @{ $s->{order} }, $title;
        push @headers, $title;
        $s;
    }

    sub scroll_up {
        (shift)->scroll(SCROLL_UP);
    }

    sub scroll_down {
        (shift)->scroll(SCROLL_DOWN);
    }

    sub scroll {
        my ( $s, $d ) = @_;
        my $title = $s->{order}[ $s->{active_pane} ];
        return if $scroll_i{$title}{$d} eq 0;
        $d eq SCROLL_UP ? $scroll_i{$title}{&SCROLL_UP}-- : $scroll_i{$title}{&SCROLL_UP}++;
        $s->{panes}{$title} = $s{create_pane}->( $s, $title );
        $s->show_pane($title) if $title eq $s->{order}[ $s->{active_pane} ];
    }

    sub refresh_pane {
        my ( $s, $d ) = @_;
        my $title = $d ? $d : $s->{order}[ $s->{active_pane} ];
        $s->{panes}{$title} = $s{create_pane}->( $s, $title );
        $s->show_pane($title) if $title eq $s->{order}[ $s->{active_pane} ];
    }
}

package cdmn::term {
    use Params::Validate qw(:all);
    use File::Basename;

    use fields qw(x y w h term parent bg_color content is_root maximized bare keysyms);

    use constant CDMN => 'cdmn::constants';

    my @terminals;
    my $root;

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        (%$s) = validate(
            @_,
            {   parent   => 1,
                bg_color => 0,
                is_root  => 1,
                x        => { default => 1 },
                y        => { default => 1 },
                w        => { default => 1 },
                h        => { default => 1 },
                bare     => { default => 0 },    #bare will deactivate all disturbing settins, e.g. scrollbars, ...
                keysyms  => 0,
            }
        );

        #(%$s) = @_;
        #@$s{qw/x y w h/} // 1;

        push @urxvt::TERM_INIT, sub {
            my ($term) = @_;
            $term->{termclass} = $s;
            $term->{parent} = $s->{parent} if $s->{is_root};

            my $file_name = fileparse __FILE__;
            $term->resource( perl_ext_2 => "-$file_name" );    #Do not load this extension for child terminals!
        };

        push @urxvt::TERM_EXT, __PACKAGE__;

        my $environ = $s->{parent}->env;
        $environ->{SHELL} = 'sh' if !$s->{is_root};

        my @options = ( '-depth' => 32 );
        unshift( @options, '+sb' ) if $s->{bare};
        push( @options, '-bg' => $s->{bg_color} ) if $s->{bg_color};
        $s->{term} = new urxvt::term( $environ, $urxvt::RXVTNAME, -embed => $s->{parent}->parent, @options );    #TODO only 16 colors?

        $s->bounds( @$s{qw/x y w h/} );
        $s->{is_root} ? $root = $s : push( @terminals, $s );

        $s;
    }

    sub on_user_command {
        (shift)->{term}{termclass}{parent}->user_command(@_);
        1;
    }

    sub on_init {
        my $s = shift;
        my $t = $s->{term}{termclass};

        #TODO do not rely on external structure
        if ( exists $t->{keysyms} ) {
            while ( my ( $k, $v ) = each %{ $t->{keysyms} } ) {
                $s->bind_action( $v, 'perl:' . $k );
            }
        }
        ();
    }

    sub on_tt_write {
        my $s = shift;
        if ( !$s->{term}{parent} ) {
            $root->{term}->tt_write(@_);
            1;
        }
        ();
    }

    sub on_refresh_begin {
        my $s = shift;
        if ( !$s->{term}{parent} ) {
            my $str = $s->{term}->locale_encode("\e[0;0H\e[K");
            $s->{term}->cmd_parse($str);    #do not show the cursor!
            1;
        }
        ();
    }

    sub on_destroy {
        exit;
        1;
    }

    sub bounds {
        my $s = shift;
        my $t = $s->{term};
        my %wh;
        @wh{qw/x y w h/} = validate_pos( @_, 1, 1, 1, 1 );
        $t->XMoveResizeWindow( $t->parent, @_ ) if $wh{h} > $t->fheight && $wh{w} > $t->fwidth;    #if window to small
        $s;
    }

    sub maximize {
        my $s = shift;
        $s->{maximized} = 1;                                                                       #TODO
        $s;
    }

    sub hide_cursor {
        my $s = shift;
        $s->{term}->cmd_parse("\033[?25l");
        $s;
    }

    sub hide {
        my $s = shift;
        $s->{term}->XUnmapWindow( $s->{term}->parent );
        $s;
    }

    sub show {
        my $s = shift;
        $s->{term}->XMapWindow( $s->{term}->parent );
        $s;
    }

    sub toggle {
        my $s = shift;
        $s->{term}->mapped ? $s->hide : $s->show;
        $s;
    }
}

package cdmn::visuals::container {
    use fields qw( term rendition padding align even_gauges x y bg_color label_pos graph_data graph_length  );
    use fields qw( gauges visible bg bg_visible label_visible detail width height ncol nrow order graphs);
    use Params::Validate qw(:all);
    use POSIX qw(ceil floor);

    use constant CDMN => 'cdmn::constants';
    use constant { TRUE => 1, FALSE => 0 };

    my ( $xOff, $yOff, $m ) = ( 0, 0, 0 );

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        (%$s) = validate(
            @_,
            {   term        => 1,
                rendition   => 1,
                x           => 1,
                y           => 1,
                padding     => 1,
                align       => 1,
                even_gauges => 1,
                visible     => 1,
                bg_color    => 1,
                label_pos   => 1,
            }
        );

        ( $xOff, $yOff ) = ( 0, $s->{y} );
        $s;
    }

    sub add {
        my $s = shift;
        my (%arg) = validate(
            @_,
            {   label         => 1,
                padding       => 1,
                gauges        => 1,
                label_bg      => 1,
                label_fg      => 1,
                label_bold    => 1,
                gauges_colors => 1,
                gauges_bg     => 1,
                visual_style  => 1,
                sensitivity   => 1,
                name          => 1,
                detail        => 1,
                graph_length  => { default => 0 },
            }
        );

        push @{ $s->{order} }, $arg{name};

        $s->{graphs}{ $arg{name} } = 1 if $arg{graph_length} < 0;

        my $visual = cdmn::visuals::visual->new(
            term          => $s->{term},
            rendition     => $s->{rendition},
            x             => $xOff,
            y             => $yOff,
            label         => $arg{label},
            gauges        => $arg{graph_length} ? [ 0 .. $arg{graph_length} * ( scalar @{ $arg{gauges} } ) - 1 ] : $arg{gauges},
            label_bg      => $arg{label_bg},
            label_fg      => $arg{label_fg},
            gauges_colors => $arg{gauges_colors},
            gauges_bg     => $arg{gauges_bg},
            visual_style  => $arg{visual_style},
            sensitivity   => $arg{sensitivity},
            label_pos     => $s->{label_pos},
            padding       => $arg{padding},
            label_bold    => $arg{label_bold},
        );

        $s->{detail}{ $arg{name} }       = $arg{detail};
        $s->{graph_length}{ $arg{name} } = $arg{graph_length};

        local *_pad = sub {
            for ( values %{ $s->{gauges} } ) {
                my $c = scalar @{ $_->{gauges} };
                return if $c <= $m;
                $m = $c;
                $_->even_gauges($c);
                $xOff += $visual->{width} if $s->{align} eq CDMN->VISUAL_ALIGN_ROW;
            }
        };

        if ( $s->{even_gauges} ) {
            _pad( length $arg{label} ) if $s->{label_pos} eq CDMN->RIGHT;
            _pad( scalar @{ $arg{gauges} } ) if $s->{label_pos} eq CDMN->LEFT;
        }

        $visual->even_gauges($m) if $s->{even_gauges};
        $xOff += $visual->{width} + $s->{padding}  if $s->{align} eq CDMN->VISUAL_ALIGN_ROW;
        $yOff += $visual->{height} + $s->{padding} if $s->{align} eq CDMN->VISUAL_ALIGN_COL;
        $s->{gauges}{ $arg{name} } = $visual;
        $s;
    }

    #TODO make it shorter or split
    sub create {
        my $s = shift;
        my $l = 0;

        for ( values %{ $s->{gauges} } ) {
            $l = $_->{width} if $l < $_->{width};
        }

        for ( values %{ $s->{gauges} } ) {
            if ( $s->{x} < 0 ) {
                $_->{x} = $s->{term}->ncol - $xOff + $_->{x} + $s->{x} + $s->{padding} + 1 if ( $s->{align} eq CDMN->VISUAL_ALIGN_ROW );
                $_->{x} = $s->{term}->ncol - $_->{x} - $_->{width} if ( $s->{align} eq CDMN->VISUAL_ALIGN_COL );
            }
            else {
                $_->{x} += $s->{x} if $s->{align} eq CDMN->VISUAL_ALIGN_ROW;
                $_->{x} = $l - $_->{width} if ( $s->{align} eq CDMN->VISUAL_ALIGN_COL );
            }
            if ( $s->{y} < 0 ) {
                $_->{y} = $s->{term}->nrow - $yOff + $_->{y} + $s->{y} + $s->{padding} + 1 if ( $s->{align} eq CDMN->VISUAL_ALIGN_COL );
            }
        }

        $s->{ncol} = $s->{align} eq CDMN->VISUAL_ALIGN_ROW ? $xOff - $s->{padding} : $l;
        $s->{nrow} = $s->{align} eq CDMN->VISUAL_ALIGN_ROW ? 1 : $yOff - $s->{padding} + 1;

        #Recalculate for all elements in expand list.
        my @graphs_count = keys %{ $s->{graphs} };
        if (@graphs_count) {
            my $x = 0;
            $_->{x} -= $s->{term}->ncol - $s->{ncol} for values %{ $s->{gauges} };
            for ( @{ $s->{order} } ) {
                my $old_count = @{ $s->{gauges}{$_}{gauges} };
                my $gauges = [ 0 .. floor( ( $s->{term}->ncol - $s->{ncol} ) / @graphs_count ) + $old_count - 1 ];
                $s->{gauges}{$_}{x} += $x;
                if ( $s->{graphs}{$_} ) {
                    $s->{gauges}{$_}{gauges} = $gauges;
                    $s->{graph_length}{$_} = @$gauges;
                    $x += @$gauges - $old_count;
                }
            }
        }

        $_->create for values %{ $s->{gauges} };

        #Background
        $s->{bg} = cdmn::visuals::overlay->new(
            term   => $s->{term},
            x      => $s->{x},
            y      => $s->{y},
            width  => $s->{ncol},
            height => $s->{nrow},

            #rendition => urxvt::SET_BGCOLOR CDMN->REND, 4,
            rendition => urxvt::SET_BGCOLOR CDMN->REND,
            $s->{bg_color},
        );

        $s->{bg}->create();
        $s->{bg_visible} = 1;

        my $w = 0;
        for ( values %{ $s->{gauges} } ) { $w = $_->{width} if $_->{width} > $w; }
        $s->{width} = $w * $s->{term}->fwidth;
        $s->{height} = $yOff + ( $s->{padding} * ( $yOff - 1 ) * $s->{term}->fheight );
        $s;
    }

    sub set {
        my ( $s, $name, $usage, $invert ) = validate_pos( @_, 1, 1, 1, 1 );
        my $total = 0;

        if ( $s->{graph_length}{$name} ) {
            my $graph_count = $s->{graph_length}{$name};

            for ( keys %$usage ) {
                $s->{graph_data}{$name}{$_} = [ (0) x $graph_count ] if !$s->{graph_data}{$name}{$_};
                shift @{ $s->{graph_data}{$name}{$_} };
                push( @{ $s->{graph_data}{$name}{$_} }, $usage->{$_} );
                $total += $usage->{$_};
            }
            $total /= scalar keys %$usage;

            $s->{graph_data}{$name}{'simple'} = [ (0) x $graph_count ] if !$s->{graph_data}{$name}{'simple'};
            shift @{ $s->{graph_data}{$name}{'simple'} };
            push @{ $s->{graph_data}{$name}{'simple'} }, $total;

            my %t;
            my $key = 0;
            for ( sort keys %{ $s->{graph_data}{$name} } ) {
                for ( @{ $s->{graph_data}{$name}{ $s->{detail}{$name} ? $_ : 'simple' } } ) {
                    $t{ $key++ } = $_;
                }
            }
            $usage = \%t;
        }

        if ( $s->{visible} && $s->{gauges}{$name} ) {
            if ( !$s->{detail}{$name} and !$s->{graph_length}{$name} ) {
                $total += $_ for values %$usage;
                $total /= scalar keys %$usage;
                $s->{gauges}{$name}->set( 'simple', $total, $invert );
            }
            else {
                while ( my ( $key, $value ) = each %$usage ) {
                    $s->{gauges}{$name}->set( $key, $value, $invert );
                }
            }
        }

        $s->refresh_bg;
        $s;
    }

    sub show {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        $visible ? $_->show : $_->hide for values %{ $s->{gauges} };
        $visible ? $s->show_labels : $s->hide_labels;

        $visible ? $s->show_bg : $s->hide_bg;
        $s->{visible} = $visible;
        $s;
    }

    sub hide {
        my $s = shift;
        $s->show(FALSE);
        $s;
    }

    sub toggle {
        my $s = shift;
        $s->{visible} ? $s->hide : $s->show;
        $s;
    }

    sub show_labels {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        for ( values %{ $s->{gauges} } ) {
            $visible ? $_->show_label : $_->hide_label;
        }

        $s->refresh_bg;
        $s->{label_visible} = $visible;
        $s;
    }

    sub hide_labels {
        my $s = shift;
        $s->show_labels(FALSE);
        $s;
    }

    sub show_bg {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        $visible ? $s->{bg}->show : $s->{bg}->hide;
        $s->{bg_visible} = $visible;
        $s;
    }

    sub refresh_bg {
        my $s = shift;
        if ( $s->{bg_visible} ) {
            $s->hide_bg;
            $s->show_bg;
        }
        $s;
    }

    sub hide_bg {
        my $s = shift;
        $s->show_bg(FALSE);
        $s;
    }
}

package cdmn::visuals::visual {
    use List::Util qw(max);
    use Params::Validate qw(:all);

    use fields qw(
        term

        x y
        width
        height
        width_add
        padding

        rendition
        visual_style
        sensitivity
        count

        label
        label_bg
        label_fg
        label_pos
        label_bold

        gauges
        gauges_colors
        gauges_bg

    );

    use constant BLOCKS => [qw/_ ▁ ▂ ▃ ▄ ▅ ▆ ▇ █/];

    #use constant LED => '⬛';
    use constant LED => '■';
    use constant { TRUE => 1, FALSE => 0 };
    use constant CDMN => 'cdmn::constants';

    my $m = 0;

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        (%$s) = validate(
            @_,
            {   term          => 1,
                rendition     => 1,
                x             => 1,
                y             => 1,
                label         => 1,
                gauges        => 1,
                label_bg      => 1,
                label_fg      => 1,
                label_bold    => 1,
                gauges_colors => 1,
                gauges_bg     => 1,
                visual_style  => 1,
                sensitivity   => 1,
                label_pos     => 1,
                padding       => 1,
            }
        );

        $s->{width} = ( length $s->{label} ) + $s->{padding} + @{ $s->{gauges} };

        $s->{height}    = 1;
        $s->{width_add} = 0;
        $s;
    }

    sub even_gauges {
        my ( $s, $max ) = @_;
        my $l = length $s->{label};

        $s->{width} -= $s->{width_add};
        $s->{width_add} = $max - @{ $s->{gauges} } if $s->{label_pos} eq CDMN->LEFT;
        $s->{width_add} = $l > 0 ? $max - $l : 0 if $s->{label_pos} eq CDMN->RIGHT;
        $s->{width} += $s->{width_add};
        $s;
    }

    sub create {
        my $s      = shift;
        my $w      = ( length $s->{label} );
        my @gauges = @{ $s->{gauges} };

        $s->{gauges} = {};
        $s->{x} = -( $w + $m ) if $s->{x} < 0;
        my $x = $s->{x};

        local *_label = sub {
            my $rend = urxvt::SET_COLOR $s->{rendition}, $s->{label_fg}, $s->{label_bg};
            $rend = $rend | urxvt::RS_Bold if $s->{label_bold};
            my $labelObj = cdmn::visuals::overlay->new(
                term      => $s->{term},
                x         => $x,
                y         => $s->{y},
                width     => $w,
                height    => $s->{height},
                rendition => $rend,
                text      => $s->{label}
            );
            $s->{label} = $labelObj->create();
        };

        local *_gauges = sub {
            my $rend = urxvt::SET_BGCOLOR $s->{rendition}, $s->{gauges_bg};
            for my $i (@gauges) {
                for ( @{ $s->{gauges_colors} } ) {
                    $rend = urxvt::SET_FGCOLOR $rend, $_;
                    my $pictorial = cdmn::visuals::overlay->new(
                        term      => $s->{term},
                        x         => $x,
                        y         => $s->{y},
                        width     => 1,
                        height    => 1,
                        rendition => $rend,
                        text      => BLOCKS->[0],
                    );
                    $s->{gauges}{"$i"}{"$_"} = $pictorial->create();
                }
                $x++;
            }
        };

        if ( $s->{label_pos} eq CDMN->RIGHT ) { 
            _gauges(); $x+= $s->{padding}; _label();
        } else { 
            _label(); $x += $w + $s->{padding}; _gauges();
        }
        $s;
    }

    sub show {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        for ( values %{ $s->{gauges} } ) {
            for ( values %{$_} ) {
                $visible ? $_->show : $_->hide;
            }
        }
        $s;
    }

    sub hide {
        my $s = shift;
        $s->show(FALSE);
        $s;
    }

    sub show_label {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        $visible ? $s->{label}->show : $s->{label}->hide;
        $s;
    }

    sub hide_label {
        my $s = shift;
        $s->show_label(FALSE);
        $s;
    }

    sub set {
        my ( $s, $i, $usage, $invert ) = validate_pos( @_, 1, 1, 1, 1 );
        return if !$s->{gauges}{"$i"};

        my $size = scalar @{&BLOCKS};
        my $bar_i = ( $usage > 100 ? 100 : $usage ) / 100 * ($size);
        $usage = 100 - $usage if $invert;
        $bar_i -= 1 if $bar_i >= $size;
        $size = scalar @{ $s->{gauges_colors} };
        my $clr_i = ( $usage > 100 ? 100 : $usage ) / 100 * ( $size - 1 ) + 1;
        $clr_i -= 1 if $clr_i >= $size;
        my $color = $usage < $s->{sensitivity} ? $s->{gauges_colors}[1] : $s->{gauges_colors}[$clr_i];
        $_->hide for values %{ $s->{gauges}{"$i"} };

        $s->{gauges}{"$i"}{"$color"}->set( BLOCKS->[$bar_i] ) if $s->{visual_style} eq CDMN->STYLE_BAR;
        $s->{gauges}{"$i"}{"$color"}->set(LED) if $s->{visual_style} eq CDMN->STYLE_LED;
        $s->{gauges}{"$i"}{"$color"}->show;
        $s;
    }
}

package cdmn::visuals::overlay {
    use Params::Validate qw(:all);
    use fields qw(
        term
        x
        y
        width
        height
        rendition
        text
        overlay
        repeat
    );

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        (%$s) = validate(
            @_,
            {   term      => 1,
                rendition => 1,
                x         => 1,
                y         => 1,
                width     => 1,
                height    => 1,
                text      => 0,
                repeat    => { default => 0 },
            }
        );
        $s;
    }

    sub create {
        my $s = shift;
        my ( $x, $y, $w, $h, $r, $t ) = ( $s->{x}, $s->{y}, $s->{width}, $s->{height}, $s->{rendition}, $s->{text} );

        $s->{overlay} = $s->{term}->overlay( $x, $y, $w, $h, $r, 0 );

        $s->set($t) if defined $t;
        $s;
    }

    #set text for overlay. If overlay hight > 1 repeat text for each row.
    sub set {
        my $s = shift;
        $s->{text} = shift;
        $s->{overlay}->set( 0, 0, $s->{text} );

        if ( $s->{repeat} ) {
            for my $y ( 0 .. $s->{height} ) {
                for my $x ( 0 .. $s->{width} ) {
                    $s->{overlay}->set( $x, $y, $s->{text} );
                }
            }
        }

        #wrap hide and show from rxvt
        for my $h (qw(hide show)) {
            eval qq{ sub $h { my \$s = shift; \$s->{overlay}->$h; } };    ## no critic
        }
        $s;
    }
}

use constant XR   => cdmn::resources->new();
use constant CDMN => 'cdmn::constants';

#-----------------------------------------------------------
#   HELPERS
#-----------------------------------------------------------

#
sub redraw {
    my ( $s, $showLabels ) = @_;
    my @visible = map { $$_->{visible} } @{ ( $s->{captions} ) };

    $s->{visuals_updater}->stop;
    $s->{captions}[0] = create_caption( $s->{xterms}{main}{term}, $showLabels );
    $s->{captions}[1] = create_caption( $s, $showLabels );

    while ( my ( $key, $item ) = each @{ ( $s->{captions} ) } ) {
        ${$item}->create();
        $visible[$key] ? ${$item}->show : ${$item}->hide;
    }

    $s->{xterms}{sidebar}->refresh_pane if $s->{xterms}{sidebar}{visible};
    $s->{visuals_updater}->start;
}

# P: urxvt::term, row|col
# R: List with new bounds
sub calc_bounds {
    my ( $s, $t ) = @_;
    my ( $h, $w, $x, $y ) = ( $s->{height}, $s->{width}, $s->{x}, $s->{y} );

    if ( $t eq CDMN->VISUAL_ALIGN_ROW ) {
        $y = XR->{y} >= 0 ? $s->fheight : -1;
    }
    if ( $t eq CDMN->VISUAL_ALIGN_COL ) {
        $w = $s->{width} - ${ $s->{captions}[0] }->{width};
        $y = 0;
    }
    $x = 0;
    ( $h, $w, $x, $y );
}

sub refresh_bounds {
    my ( $s, $t ) = @_;
    my ( $h, $w, $x, $y ) = calc_bounds( $s, $t );

    if ( $s->{xterms}{main}{maximized} ) {
        $s->{xterms}{main}->bounds( 0, 0, $s->{width}, $s->{height} );
    }
    else {
        $s->{xterms}{main}->bounds( $x, $y + 1, $w, $h );
        $s->{xterms}{main}->bounds( XR->{x} >= 0 ? $s->{width} - $w : 0, 0, $w, $h ) if XR->{visual_align} eq CDMN->VISUAL_ALIGN_COL;
    }

    my ( $sb_pos, $sb_w, $sb_h ) = map { XR->get_sidebar($_) } (qw/position width height/);
    my $width  = $sb_pos =~ m/^${\(CDMN->LEFT)}|${\(CDMN->RIGHT)}/ ? $s->width *  ( $sb_w / 100 ) + $s->{dwidth}  : $s->{width};
    my $height = $sb_pos =~ m/^${\(CDMN->TOP)}|${\(CDMN->BOTTOM)}/ ? $s->height * ( $sb_h / 100 ) + $s->{dheight} : $s->{height};

    $x = $sb_pos eq CDMN->RIGHT  ? $s->{width} - $width   : 0;
    $y = $sb_pos eq CDMN->BOTTOM ? $s->{height} - $height : 0;
    $s->{xterms}{sidebar}->bounds( $x, $y, $width, $height );

    my $sidebar = $s->{xterms}{sidebar};
    $sidebar->refresh_pane
        if $sidebar->{visible}
        && ceil( $sidebar->{term}->{h} / $sidebar->{term}->fheight ) > 4
        && ceil( $sidebar->{term}->{w} / $sidebar->{term}->fwidth ) > 4    #TODO remove magic number
        && $sidebar->{visible};

}

# P: urxvt::term, 0|1
# R: ref to new cdmn::visuals::container
sub create_caption {
    my ( $s, $showLabels ) = (@_);
    my $caption;

    local *_create = sub {
        my (%arg) = @_;

        local *_add = sub {
            my $c      = shift;
            my @colors = @{ $c->{colors} };
            $caption->add(
                label => $showLabels ? $c->{label} : '',
                padding       => $c->{padding},
                gauges        => $arg{ $c->{name} },
                label_bg      => $c->{bg},
                gauges_bg     => scalar @colors > 1 ? shift @colors : XR->get('gauges_colors')->[0],
                label_fg      => $c->{fg},
                gauges_colors => $c->{colors},
                visual_style  => $c->{visual},
                sensitivity   => XR->{sensitivity},
                name          => $c->{name},
                detail        => $c->{detail},
                graph_length  => $c->{length},
                label_bold    => XR->get('label_bold'),
            );
        };

        for ( @{ XR->get('gauges_order') } ) {
            _add( XR->resources($_) ) if $arg{$_};
        }
    };

    for ( XR->{visual_align} ) {
        $caption = do {
            if ( $_ eq CDMN->VISUAL_ALIGN_ROW ) {
                cdmn::visuals::container->new(
                    term        => $s,
                    rendition   => CDMN->REND,
                    x           => XR->{x},
                    y           => XR->{y},
                    padding     => XR->get('padding'),
                    align       => $_,
                    even_gauges => 0,
                    visible     => XR->{showing},
                    bg_color    => XR->{caption_bg},
                    label_pos   => XR->get('label_position'),
                );
            }
            elsif ( $_ eq CDMN->VISUAL_ALIGN_COL ) {
                cdmn::visuals::container->new(
                    term        => $s,
                    rendition   => CDMN->REND,
                    x           => XR->{x},
                    y           => XR->{y},
                    padding     => XR->get('padding'),
                    align       => $_,
                    even_gauges => 1,
                    visible     => XR->{showing},
                    bg_color    => XR->{caption_bg},
                    label_pos   => XR->get('label_position'),
                );
            }
        };
    }

    _create( XR->gauges() );
    return \$caption;
}

#-----------------------------------------------------------------------------------------------------------------------
#   ACTIONS
#-----------------------------------------------------------------------------------------------------------------------

my %user_command;

$user_command{ CDMN->ACTION_TOGGLE } = sub {
    my $s = shift;
    my ( $h, $w, $x, $y ) = calc_bounds( $s, XR->{visual_align} );

    if ( $s->{xterms}{main}{maximized} ) {
        $s->{xterms}{main}->bounds( $x, $y + 1, $w, $h - $s->fheight ) if XR->{visual_align} eq CDMN->VISUAL_ALIGN_ROW;
        $s->{xterms}{main}->bounds( XR->{x} >= 0 ? $s->{width} - $w : 0, 0, $w, $h ) if XR->{visual_align} eq CDMN->VISUAL_ALIGN_COL;
        $s->{xterms}{main}{maximized} = 0;
        ${ $s->{captions}->[0] }->hide;
        XR->{showing} = 1;
    }
    else {
        $s->{xterms}{main}->bounds( 0, 0, $s->{width}, $s->{height} );
        $s->{xterms}{main}{maximized} = 1;
        XR->{showing} = 0;
    }
};

$user_command{ CDMN->ACTION_TOGGLE_OVERLAY } = sub {
    my $s = shift;
    if ( $s->{xterms}{main}{maximized} ) {
        my $c = ${ $s->{captions}->[0] };
        if ( $c->{visible} ) {
            $c->hide;
            XR->{showing} = 0;
        }
        else {
            $c->show;
            XR->{showing} = 1;
            redraw( $s, XR->{showing_labels} );
            refresh_bounds( $s, XR->{visual_align} );
        }
    }
};

$user_command{ CDMN->ACTION_TOGGLE_SIDEBAR } = sub {
    (shift)->{xterms}{sidebar}->toggle;
};

$user_command{ CDMN->ACTION_NEXT_PANE } = sub {
    (shift)->{xterms}{sidebar}->next_pane;
};

$user_command{ CDMN->ACTION_PREV_PANE } = sub {
    (shift)->{xterms}{sidebar}->prev_pane;
};

$user_command{ CDMN->ACTION_SCROLL_UP } = sub {
    (shift)->{xterms}{sidebar}->scroll_up;
};

$user_command{ CDMN->ACTION_SCROLL_DOWN } = sub {
    (shift)->{xterms}{sidebar}->scroll_down;
};

$user_command{ CDMN->ACTION_TOGGLE_LABELS } = sub {
    if ( XR->{showing} ) {
        my $s = shift;
        XR->{showing_labels} = !XR->{showing_labels};
        redraw( $s, XR->{showing_labels} );
        refresh_bounds( $s, XR->{visual_align} );
    }
};

#-----------------------------------------------------------------------------------------------------------------------
#   RXVT HANDLERS
#-----------------------------------------------------------------------------------------------------------------------

sub user_command {
    my ( $s, $action ) = (@_);
    $user_command{$action}->($s);
    1;
}

# Before every terminal update, check if the state of some devices
# or the terminal size has changed and recalculate accordingly.
# The resource 'refresh' has direct impact on how often his method
# will be called.
sub on_refresh_begin {
    my ($s) = @_;
    my $nics_active = cdmn::proc->network_list;
    state $onAC = 0;
    state $nics = 0;
    if (   $s->{w_size} != $s->{term}->ncol
        || $s->{y_size} != $s->{term}->nrow
        || cdmn::proc::ac_online() != $onAC
        || $nics != scalar @$nics_active )
    {
        $onAC = !$onAC;
        $nics = scalar @$nics_active;

        XR->set_nics;
        redraw( $s, XR->{showing_labels} );
        refresh_bounds( $s, XR->{visual_align} );
        $s->{w_size} = $s->{term}->ncol;
        $s->{y_size} = $s->{term}->nrow;
    }

    1;
}

sub on_refresh_end {
    my $s   = shift;
    my $str = $s->{term}->locale_encode("\e[0;0H\e[K");
    $s->{term}->cmd_parse($str);    #do not show the cursor!
    1;
}

# React on X Events (resize)
sub on_configure_notify {
    my ( $s, $e ) = @_;

    #NOTE this is a hack for saving the real height and width. Otherwise there are some (currently 4) pixels missing ;(
    $s->{width}   = $e->{width};
    $s->{height}  = $e->{height};
    $s->{dwidth}  = $e->{width} - $s->width;
    $s->{dheight} = $e->{height} - $s->height;
    return if $s->{w_size} eq $s->{term}->ncol && $s->{y_size} eq $s->{term}->nrow;
    refresh_bounds( $s, XR->{visual_align} );
    1;
}

# Forward all events to main terminal
for my $h (qw(key_press key_release)) {
    ## no critic
    eval qq{
    sub on_$h {
        my (\$s, \$e) = \@_;
        \$s->{xterms}{main}{term}->$h (\$e->{state}, \$e->{keycode}, \$e->{time}); 1; }
    };
}

# Forward all events to main terminal
for my $h (qw(focus_in focus_out)) {
    eval qq{ sub on_$h { (shift)->{xterms}{main}{term}->$h; 1; } };    ## no critic
}

sub on_wm_delete_window {

    # This is the root terminal.
    # Do not forward to prevent deletion of alread deleted child terminals.
    exit;
    1;
}

sub on_tt_write {

    # Forward all terminal output to main terminal
    (shift)->{xterms}{main}{term}->tt_write(shift);
    1;
}

#-------------------------------------------------
#   MAIN
#-------------------------------------------------

sub on_init {
    my ($s) = @_;
    XR->init($s);
    @$s{qw/width height dwidth dheight/} = (qw/0 0 0 0/);
    ();
}

sub on_start {
    my ($s) = @_;

    $s->{xterms}{main} = cdmn::term->new(
        parent  => $s,
        is_root => 1,
        keysyms => XR->{keysyms}
    )->maximize->show;

    $s->{xterms}{sidebar} = cdmn::sidebar->new(

        #x,y,width,height will be set on immediate refresh, so we use the default - see new()
        parent          => $s,
        fg              => XR->get_sidebar('fg'),
        bg              => XR->get_sidebar('bg'),
        fg_border       => XR->get_sidebar('border_fg'),
        border_position => XR->get_sidebar('position'),
        header_position => XR->get_sidebar('header_position'),
        label_position  => XR->get_sidebar('label_position'),
        graph_symbols   => XR->get_sidebar('graph_symbols'),
        border_visible  => XR->get_sidebar('border_visible'),
        keysyms => XR->{keysyms},
    );

    $s->{w_size}      = $s->{term}->ncol;
    $s->{y_size}      = $s->{term}->nrow;
    $s->{captions}[0] = create_caption $s->{xterms}{main}{term};
    $s->{captions}[1] = create_caption $s;
    ${ $s->{captions}[0] }->create();
    ${ $s->{captions}[1] }->create();

    #$s->cmd_parse("\e[2T\e[2B"); #Scroll down and move cursor down 2 line.
    $s->cmd_parse("\033[?25l");    #do not show the cursor!

    for ( @{ XR->get_sidebar('panes_order') } ) {
        $s->{xterms}{sidebar}->add_pane($_) if XR->has_content($_);
    }

    $s->{xterms}{sidebar}{active_pane} = 0;

    $s->{visuals_updater} = urxvt::timer->new->start( int urxvt::NOW )->interval( XR->{refresh} )->cb(
        sub {
            my %r;

            local *_filter = sub {
                map { $_ => ${ $_[0] }{$_} } @{ $_[1] };
            };

            redraw( $s, XR->{showing_labels} ) if XR->set_disks->ok || XR->set_batteries->ok || XR->set_nics->ok;

            #use subs because we only want to get values when we need them!
            my %usage_of;
            $usage_of{cpu}      = sub { _filter( cdmn::proc::cpu_usages(), XR->get_gauges('cpus') ) };
            $usage_of{memory}   = sub { %{ cdmn::proc::memory_usages() } };
            $usage_of{cpu_temp} = sub { %{ cdmn::proc::cpu_temp_usages() } };
            $usage_of{battery}  = sub { %{ cdmn::proc::battery_usages() } };
            $usage_of{disk}     = sub { _filter( cdmn::proc::disk_usages(), XR->get_gauges('disks') ) };
            $usage_of{network}  = sub { _filter( cdmn::proc::network_usages(), XR->get_gauges('networks') ) };
            $usage_of{mount}    = sub { %{ cdmn::proc::fs_usage() } };

            local *_set = sub {
                my $gauges = shift;
                my $panes  = shift;

                $r{$_} = { $usage_of{$_}->() } foreach @{ cdmn::math->union( $gauges, $panes ) };

                $s->{xterms}{sidebar}->set_pane( $_, $r{$_} ) for @$panes;    #if $s->{xterms}{sidebar}{visible};
                for my $g (@$gauges) {
                    $$_->set( $g, $r{$g}, XR->get_invert($g) ) for @{ $s->{captions} };
                }
            };

            my @gauges = keys %{ ${ $s->{captions}[0] }->{gauges} };
            my @panes  = keys %{ $s->{xterms}{sidebar}{panes} };
            _set( \@gauges, \@panes );
        }
    );
    refresh_bounds( $s, XR->{visual_align} );
    ();
}

=head1 packages

=over

=item cdmn::math [static]

 Some general useful subs.

=item cdmn::constants [static]

 Constants used throughout this extension.

=item cdmn::proc [static]

 Static subs for accessing different parts of procfs.

=item cdmn::resources::single [class]

 A single resource represents the resource attributes of a visual element e.g. name, padding, bg, fg, colors, label, length, gauges, style and so on.
 Used bye cdmn::resources for creating resource instances.

=item cdmn::resources [class]

 Initialize and setup all (default) resources.

=item cdmn::sidebar [class]

 Wrapper around urxvt::xterm that can hold multiple panes or pages a user can navigate through.

=item cdmn::term [class]

 Wrapper around urxvt::term. Used as a central registry and for creating Instances.

=item cdmn::visuals::container [class]

 Container for cdmn::visuals:visual instances.

=item cdmn::visuals::visual [class]

 Simple visible element composed of a label and a gauge.

=back

=head1 Technical details

=over

=item Terminals

 There are three terminals that have to be considered, which are the root, main and sidebar terminal. The root terminal is also the original terminal for this extension. 
 
 The main terminal is the next layer on top of the root terminal an will be resized as necessary depending on which mode a user currently uses and what aligment is set. This technique was chosen to emulate the two different modes: normal and overlay. 
  
 Tecnically the two terminals are identical and show the same captions. But in overlay mode only the main terminal will be visible. In normal mode the main terminal will be resized to fit the users setttings. For example it will be on row smaller than the root terminal and and show the captions of the root terminal to give the impression of a fixed header.
 
 The sidebar is a terminal that will be present on user interaction. The different pages a implemented as overlays thad are shown/hidden while the user navigates through them.

  All actions caught on the root and sidebar terminal will be relayed to the main terminal.

=back

=cut
