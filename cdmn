#! perl

# cdmn is an extension written for the rxvt terminal emulator that shows
# utilizations of different system resoureces like cpu, disk i/o, ram,
# network (and more).

# Copyright (C) 2016-2017 Marcel Lautenbach
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use 5.10.1;
use strict;
use warnings FATAL => 'all';
use utf8;
use autodie;

my $SHOWING;

package cdmn::proc {
    use List::Util qw(sum max min);

    use constant {
        PARTITIONS  => '/proc/partitions',
        MOUNTS      => '/proc/mounts',
        STAT        => '/proc/stat',
        DISKSTATS   => '/proc/diskstats',
        MEMINFO     => '/proc/meminfo',
        NET_ROUTE   => '/proc/net/route',
    };

    use constant {
        SPEED     => 'speed',
        OPERSTATE => 'operstate',
        TX        => 'tx_bytes',
        RX        => 'rx_bytes',
        BAT_FULL  => 'full',
        BAT_NOW   => 'now',
    };

    use constant {
        CPU_PRESENT => '/sys/devices/system/cpu/present',
        HWMON       => '/sys/class/hwmon/',
        SYSFS_NET   => '/sys/class/net/',
        SYSFS_BAT   => '/sys/class/power_supply/',
    };

    sub cpu_temp_usages {
        my %results;
        if (-e HWMON) {
            opendir( my $dh, HWMON );
            my @dir = readdir $dh;
            for (@dir) {
                next if $_ =~ /^\.\.?$/;
                my $p = HWMON.$_;
                open( my $f, '<', $p."/name") || last;
                chomp(my $state = <$f>);
                if ($state eq 'coretemp') {
                    opendir( $dh, $p );
                    @dir = readdir $dh;
                    my %cores = map {/(temp\d)/ ? (($_ =~ /(temp\d)/), "") : ()} @dir;
                    for (keys %cores) {
                        open( $f, '<', $p."/".$_."_input");
                        chomp(my $cv = <$f>);
                        open( $f, '<', $p."/".$_."_crit");
                        chomp(my $mv = <$f>);
                        open( $f, '<', $p."/".$_."_label");
                        chomp(my $l = <$f>);
                        $results{$l} = $cv / $mv * 100;
                    }
                    last;
                }
            }
            closedir $dh;
        }
        return \%results;
    }

    sub cores {
        my @results;
        opendir( my $dh, HWMON );
        my @dir = readdir $dh;
        for (@dir) {
            next if $_ =~ /^\.\.?$/;
            my $p = HWMON.$_;
            open( my $f, '<', $p."/name");
            chomp(my $state = <$f>);
            if ($state eq 'coretemp') {
                opendir( $dh, $p );
                @dir = readdir $dh;
                my %cores = map {/(temp\d)/ ? (($_ =~ /(temp\d)/), "") : ()} @dir;
                for (keys %cores) {
                    open( $f, '<', $p."/".$_."_label");
                    chomp(my $l = <$f>);
                    push @results, $l;
                };
                last;
            }
        }
        closedir $dh;
        return \@results;
    }

    sub sysfs_net {
        my $path = SYSFS_NET."/$_[0]";
        return $path."/statistics/$_[1]" if $_[1] && ($_[1] eq TX || $_[1] eq RX);
        return $path."/$_[1]" if $_[1] && ($_[1] eq OPERSTATE || $_[1] eq SPEED);
        $path;
    }

    sub sysfs_bat {
        my $path = SYSFS_BAT."/$_[0]";
        opendir( my $dh, $path );
        if ($_[1]) {
            while ( readdir $dh ) {
                $path .= "/".$_ if /^energy_full$|^charge_full$/ && $_[1] eq BAT_FULL;
                $path .= "/".$_ if /^energy_now$|^charge_now$/ && $_[1] eq BAT_NOW;
            }
        }
        closedir $dh;
        $path;
    }

    sub ac_online {
        opendir( my $dh, SYSFS_BAT );
        my @dir = readdir $dh; #while ( readdir $dh ) too slow?
        for (@dir) {
            if (/AC/) {
                open( my $f, '<', SYSFS_BAT.$_."/online");
                chomp(my $state = <$f>);
                closedir $dh;
                return $state;
            }
        }
        closedir $dh;
        0;
    }

    sub has_wifi {
        opendir( my $dh, sysfs_net(shift) );
        my @dir = readdir $dh;
        for (@dir) { return 1 if (/wireless/); }
        closedir $dh;
        0;
    }

    sub if_down {
        open( my $f, '<', sysfs_net(shift, OPERSTATE) );
        chomp(my $state = <$f>);
        # RFC2863 operational states: unknown notpresent down up lowerlayerdown testing dormant
        return 1 if $state eq 'down' || $state eq 'unknown';
        0;
    }

    sub if_list {
        my @ifs;
        opendir( my $dh, SYSFS_NET);
        my @dir = readdir $dh;
        for (@dir) {
            my $if = $_;
            next if (/^\.\.?$|^veth/);
            if (!has_wifi($if)) {
                open( my $f, '<', sysfs_net($if, SPEED) );
                chomp(my @lines = <$f>);
                next if scalar @lines eq 0;
            }
            next if if_down($if);
            push @ifs, $if;
        }
        closedir $dh;
        return \@ifs;
    }

    sub mounts {
        open( my $f, '<', MOUNTS );
        my @mounts;
        my %mounts;
        while (<$f>) {
            push @mounts, /(^\/dev\S*)\s+([a-zA-Z0-9-_.\/]+)/;   #TODO this regex is too simple
            %mounts = (@mounts);
        }
        return \%mounts;
    }

    sub battery_usages {
        my %results;
        my @bats = @{&batteries};
        for (@bats) {
            my $bat = $_;
            open( my $f, '<', sysfs_bat($bat, BAT_FULL) );
            chomp(my $full = <$f>);
            open( $f, '<', sysfs_bat($bat, BAT_NOW));
            chomp(my $now = <$f>);

            $results{ $bat } = $now / $full * 100;
        }
        return \%results;
    }

    sub batteries {
        my @bats;
        opendir( my $dh, SYSFS_BAT);
        while ( readdir $dh ) {
            my $bat = $_;
            next if (/^\.\.?$/);
            next if (/^AC/);
            push @bats, $bat;
        }
        closedir $dh;
        return \@bats;
    }

    sub disks {
        open( my $f, '<', PARTITIONS );
        state @disks;
        return \@disks if scalar @disks > 0; #TODO just until cdmn is aware of changes.
        while (<$f>) {
            push @disks, /(sd[a-z]$)/;
            push @disks, /(nvme\dn\d$)/;
            push @disks, /(mmcblk\d$)/;
        }
        return \@disks;
    }

    sub cpu_usages {
        state %cpus;
        my $diff_usage = 0;
        my %results;

        open( my $f, '<', STAT );
        while (<$f>) {
            next if ( !/^cpu[0-9]*\s+[0-9]+/ );

            my @cpu = split /\s+/;
            my $cpu = shift @cpu;

            if (!defined $cpus{$cpu}) {
                $cpus{$cpu}{$_} = 0 for qw/prev_idle prev_total diff_total/;
            }

            my $idle  = $cpu[3];
            my $total = sum(@cpu);

            my $diff_idle = $idle - $cpus{$cpu}{prev_idle};
            if ( $total != $cpus{$cpu}{prev_total} ) {
                $cpus{$cpu}{diff_total} = $total - $cpus{$cpu}{prev_total};
            }
            $diff_usage = 100 * ( $cpus{$cpu}{diff_total} - $diff_idle ) / $cpus{$cpu}{diff_total};

            $cpus{$cpu}{prev_idle}  = $idle;
            $cpus{$cpu}{prev_total} = $total;

            $results{$cpu} = $diff_usage;
        }
        return \%results;
    }

    sub cpu_count {
        open( my $f, '<', CPU_PRESENT );
        {
            local $/;
            my $cpus = <$f>;
            $cpus =~ /-([0-9]+)/;
            return $1 + 1;
        }
    }

    sub disk_usages {
        state %sda;
        my $diff_usage;
        my %results;

        open( my $f, '<', DISKSTATS );
        while (<$f>) {
            if (!/\bsd(a|b|c)|nvme\dn\d\b|mmcblk\d\b/) {
                next;
            }
            my @sda = split /\s+/, $_;
            shift @sda;
            shift @sda;
            shift @sda;

            $sda{ $sda[0] } = $sda{ $sda[0] } // 0;

            my $diff_sda = $sda[10] - $sda{ $sda[0] };
            $diff_usage = $diff_sda / 10;

            $sda{ $sda[0] }     = $sda[10];
            $results{ $sda[0] } = $diff_usage <= 100 ? $diff_usage : 100; #TODO check why > 100 and if avoidable
        }
        return \%results;
    }

    sub memory_usages {
        my @sda;
        my $total     = 0;
        my $available = 0;
        my %results;

        open( my $f, '<', MEMINFO );
        while (<$f>) {
            if (/^MemTotal:\s+[0-9]+/) {
                @sda = split /\s+/, $_;
                $total = $sda[1];
            }
            if (/^MemAvailable:\s+[0-9]+/) {
                @sda = split /\s+/, $_;
                $available = $sda[1];
            }
        }

        $results{ $sda[0] } = 100 - ( 100 * $available / $total );
        return \%results;
    }

    sub network_usages {
        my $direction = shift;

        my %results;
        my $bytes = 0;
        state %nics;

        for (@{&if_list}) {
            my $nic = $_;
            if (!defined $nics{$nic}) {
                $nics{$nic}{$_} = 0 for (RX, TX);
            }

            open( my $f, '<', sysfs_net($nic, $direction) );
            {
                local $/;
                $bytes = <$f>;
            }

            my $diff_rx = $bytes - $nics{$nic}{$direction};
            $nics{$nic}{$direction} = $bytes;

            my $diff_usage = 100 * $diff_rx / &if_speed($nic);
            $results{ $nic.( $direction eq RX ? '_rx' : '_tx' ) } = $diff_usage;
        }
        return \%results;
    }

    sub getWanInterface {
        open( my $fh, '<', NET_ROUTE );

        my $if = <$fh>;
        $if = <$fh>;

        my @wif = split /\s+/, $if;
        $wif[0];
    }

    sub if_speed {
        my $if = shift;
        my $speed;
        state $refresh = 4;
        state $wifispeed;
        if (has_wifi($if)) {
            if ($refresh >= 4) {
                $refresh = 0;
                my $c = qx/sudo iwconfig $if/;
                ($wifispeed) = $c =~ /Bit Rate.(\d*\.{0,1}\d*)/;
                $speed = $wifispeed;
            }
            else {
                $refresh++;
                $speed = $wifispeed;
            }
        }
        else {
            open( my $fh, '<', sysfs_net($if, SPEED) );
            $speed = <$fh>;
        }
        $speed *= 1000000 / 8;
        return $speed;
    }
}

package cdmn::constants {
    use constant {
        ACTION_SHOW             => 'cdmn:show',
        ACTION_SHOW_LABELS      => 'cdmn:show-labels',
        ACTION_SHOW_SIDEBAR     => 'cdmn:show-sidebar',
        ACTION_SHOW_TRANSPARENT => 'cdmn:action-show-transparent',
    };

    use constant {
        CAPTION_BLOCK     => 'block',
        CAPTION_BAR       => 'bar',
        CAPTION_SOLID_BAR => 'solid-bar',
    };

    use constant REND => urxvt::SET_COLOR urxvt::OVERLAY_RSTYLE, 255, 1;
}

package cdmn::resources {
    use fields qw(
        x  y  padding
            showing  showing_labels  showing_background
            caption  caption_bg
            label_network  label_disk  label_cpu  label_memory label_battery  label_battery_AC label_cpu_temp
            gauges  gauges_disks  gauges_nics gauges_batteries gauges_order  gauges_background gauges_cores
            actions
        );

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        return $s;
    }
}

package cdmn::term {
    use Filesys::Df;
    use POSIX qw(ceil floor);

    use fields qw(x y w h term parent bg_color content is_root resource maximized);
    use constant { REND => cdmn::constants::REND, };

    my @terminals;
    my $root;
    my @data;

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;
        (%$s) = @_;

        push @urxvt::TERM_INIT, sub {
                my ($term) = @_;
                $term->{termclass} = $s;
                $term->{parent} = $s->{parent} if $s->{is_root};
                $term->resource( perl_ext_2 => "-cdmn" );    #TODO remove magic name
            };

        push @urxvt::TERM_EXT, __PACKAGE__;

        my $environ = $s->{parent}->env;
        $environ->{SHELL} = 'sh' if !$s->{is_root};

        $s->{term} = new urxvt::term( $environ, $urxvt::RXVTNAME, -embed => $s->{parent}->parent, -depth => 32 );
        $s->bounds( @$s{qw/x y w h/} );
        $s->{is_root} ? $root = $s : push( @terminals, $s );

        $s;
    }

    sub on_user_command {
        (shift)->{term}{termclass}{parent}->user_command(@_);
        1;
    }

    sub on_init {
        my $s = shift;
        $s->bind_action( 'M-h', 'perl:'.&cdmn::constants::ACTION_SHOW );
        $s->bind_action( 'M-l', 'perl:'.&cdmn::constants::ACTION_SHOW_SIDEBAR );
        $s->bind_action( 'M-o', 'perl:'.&cdmn::constants::ACTION_SHOW_TRANSPARENT );
        ();
    }

    sub on_tt_write {
        if (!(shift)->{term}{parent}) {
            $root->{term}->tt_write(shift);
            1;
        }
        ();
    }

    sub on_refresh_begin {
        my $s = shift;
        if ( !$s->{term}{parent} ) {
            my $str = $s->{term}->locale_encode("\e[0;0H\e[K");
            $s->{term}->cmd_parse($str);    #do not show the cursor!
            1;
        }
        ();
    }

    sub bounds {
        my $s = shift;
        @$s{qw/x y w h/} = @_;
        $s->{term}->XMoveResizeWindow( $s->{term}->parent, @_ );
    }

    sub on_destroy {
        if ( $_[0]{term}{parent} ) {
            ${$_[0]{term}{parent}{caption}[0]}->hide;    #prevent segmentation fauls!
            $_->{term}->destroy for @terminals;
            my $p = $_[0]{term}{parent} or return;    #TODO get to understand it!
            $p->{d} = urxvt::iw->new->start->cb( sub { $p->destroy } );
        }
        1;
    }

    sub destroy_All { $root->{term}->destroy; }

    sub disableCursor { (shift)->{term}->cmd_parse("\033[?25l"); }

    #TODO refactor - just for testing at the moment
    sub create_content {
        my $s      = shift;
        my $mounts = cdmn::proc::mounts;
        my $r = urxvt::SET_FGCOLOR REND, 240;         #TODO remove magic number/hard-coded value

        $data[0] = cdmn::visuals::overlay->new(
            term      => $s->{term},
            x         => 0,
            y         => 0,
            width     => 1,
            height    => $root->{parent}->nrow,
            rendition => $r,
            caption   => "│"
        );

        $r = urxvt::SET_FGCOLOR REND, 250;            #TODO remove magic number/hard-coded value
        $r = $r | urxvt::RS_Uline;

        my $i = 1;
        push @data, cdmn::visuals::overlay->new(
                term      => $s->{term},
                x         => - 1,
                y         => $i++,
                width     => 32,
                height    => 1,
                rendition => $r,
                caption   => 'FS USAGE'
            );

        $r = urxvt::SET_FGCOLOR REND, 250;
        for (keys %$mounts) {
            my $ref = df( $mounts->{$_} );
            my $u   = ceil( 25 * $ref->{per} / 100 );
            my $f   = floor( 25 - 25 * $ref->{per} / 100 );

            $i++;
            push @data, cdmn::visuals::overlay->new(
                    term      => $s->{term},
                    x         => - 1,
                    y         => $i++,
                    width     => 32,
                    height    => 1,
                    rendition => $r,
                    caption   => $$mounts{$_}
                );

            push @data,
                cdmn::visuals::overlay->new(
                    term      => $s->{term},
                    x         => - 1,
                    y         => $i++,
                    width     => 32,
                    height    => 1,
                    rendition => $r,
                    caption   => "■" x $u."□" x $f." $ref->{per}%"
                );
        }

        for ( my $j = 1 ; $j < @data ; $j++ ) {
            $data[$j]->create("show");
        }
        $data[0]->create("show");
    }

    sub hide {
        my $s = shift;
        $s->{term}->XUnmapWindow( $s->{term}->parent );
    }

    sub show {
        my $s = shift;
        $s->{term}->XMapWindow( $s->{term}->parent );
    }

    sub toggle {
        my $s = shift;
        $s->{term}->mapped ? $s->hide : $s->show;
    }
}

package cdmn::visuals::container {
    use fields qw( term rendition padding align evenGauges x y );
    use fields qw( sprites visible bg backgroundVisible labelVisible);

    use constant {
        TRUE          => 1,
        FALSE         => 0,
        CAPTION_BAR   => cdmn::constants::CAPTION_BAR,
        CAPTION_BLOCK => cdmn::constants::CAPTION_BLOCK,
        REND          => cdmn::constants::REND,
    };

    my ( $xOff, $yOff, $m ) = ( 0, 0, 0 );

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        (%$s) = @_;
        ( $xOff, $yOff ) = ( 0, $s->{y} );
        $s;
    }

    sub add {
        my $s = shift;
        my %arg = @_;

        my $visual = cdmn::visuals::visual->new(
            term          => $s->{term},
            rendition     => $s->{rendition},
            x             => $xOff,
            y             => $yOff,
            label         => $arg{label},
            pictorials    => $arg{visuals},
            pictorials_bg => $arg{bg}
        );

        $s->{sprites}{$arg{label}} = $visual;
        if (@{$arg{visuals}} > $m && $s->{evenGauges}) {
            $m = @{$arg{visuals}};
            foreach ( values %{ $s->{sprites} } ) {
                $_->setEvenGauges($m);
                $xOff += $visual->{width} if $s->{align} eq CAPTION_BAR;
            }
        }
        $visual->setEvenGauges($m) if $s->{evenGauges};
        $xOff += $visual->{width} + $s->{padding}  if $s->{align} eq CAPTION_BAR;
        $yOff += $visual->{height} + $s->{padding} if $s->{align} eq CAPTION_BLOCK;
    }

    sub create {
        my $s = shift;

        if ( $s->{x} < 0 ) {
            for ( $s->{align} ) {
                if ( $_ eq CAPTION_BAR ) {
                    $_->{x} = $s->{term}->ncol - $xOff + $_->{x} + $s->{x} + $s->{padding} + 1
                        foreach ( values %{ $s->{sprites} } );
                }
                if ( $_ eq CAPTION_BLOCK ) {
                    $_->{x} = $s->{term}->ncol - $_->{x} - $_->{width} + $s->{x} foreach ( values %{ $s->{sprites} } );
                }
            }
        }
        else {
            $_->{x} += $s->{x} foreach values %{ $s->{sprites} };
        }
        $_->create foreach values %{ $s->{sprites} };

        #Background
        for ( $s->{align} ) {
            if ( $_ eq CAPTION_BAR ) {
                $s->{bg} = cdmn::visuals::overlay->new(
                    term      => $s->{term},
                    x         => - 1,
                    y         => 0,
                    width     => $xOff - 1,
                    height    => 1,
                    rendition => REND,
                );

                $s->{bg}->create("show");
                $s->{backgroundVisible} = 1;
            }
        }
    }

    sub set {
        my ( $s, $label, $i, $usage, $invert) = (@_);
        if ( $s->{visible} ) {
            $s->{sprites}{$label}->set( $i, $usage, $invert) if $s->{sprites}{$label};
        }
        $s->refresh_background;
    }

    sub show {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        foreach ( values %{ $s->{sprites} } ) {
            $visible ? $_->show : $_->hide;
        }
        $visible ? $s->show_labels : $s->hide_labels;

        $visible ? $s->show_background : $s->hide_background;
        $s->{visible} = $visible;
    }

    sub hide { (shift)->show(FALSE); }

    sub toggle {
        my $s = shift;
        $s->{visible} ? $s->hide : $s->show;
    }

    sub show_labels {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        foreach ( values %{ $s->{sprites} } ) {
            $visible ? $_->show_label : $_->hide_label;
        }

        $s->refresh_background;
        $s->{labelVisible} = $visible;
    }

    sub hide_labels { (shift)->show_labels(FALSE); }

    sub show_background {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        if ( $s->{align} eq CAPTION_BAR ) {
            $visible ? $s->{bg}->show : $s->{bg}->hide;
            $s->{backgroundVisible} = $visible;
        }
    }

    # TODO still necessary?
    sub refresh_background {
        my $s = shift;
        if ( $s->{backgroundVisible} ) {
            $s->hide_background;
            $s->show_background;
        }
    }

    sub hide_background { (shift)->show_background(FALSE); }
}

package cdmn::visuals::visual {
    use List::Util qw(max);

    use fields qw( term rendition x y label pictorials pictorials_bg );
    use fields qw( count width height );

    use constant BLOCKS => [qw/_ ▁ ▂ ▃ ▄ ▅ ▆ ▇ █/];
    use constant { TRUE => 1, FALSE => 0 };
    use constant {
        RED    => 3,
        GREEN  => 4,
        PINK   => 7,
        YELLOW => 5,
        BLUE   => 6,
        WHITE  => 248,
    };

    my $m = 0;

    sub getColor {
        for (shift) {
            return RED    if $_ > 80;
            return YELLOW if $_ > 60;
            return BLUE   if $_ > 40;
            return GREEN  if $_ > 20;
        }
        WHITE;
    }

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        (%$s) = @_;

        $s->{width}  = ( length $s->{label} ) + 1 + @{ $s->{pictorials} };
        $s->{height} = 1;
        return $s;
    }

    sub setEvenGauges {
        my ( $self, $max ) = @_;
        $self->{width} += ( -@{ $self->{pictorials} } + $max );
    }

    sub create {
        my $s          = shift;
        my $w          = ( length $s->{label} ) + 1;
        my @pictorials = @{ $s->{pictorials} };

        $s->{pictorials} = {};
        $s->{x}          = -( $w + $m ) if $s->{x} < 0;
        $s->{rendition}  = urxvt::SET_FGCOLOR $s->{rendition}, 5;    #TODO remove magic number/hard-coded value

        my $labelObj =
            cdmn::visuals::overlay->new(
                term      => $s->{term},
                x         => $s->{x},
                y         => $s->{y},
                width     => $w,
                height    => $s->{height},
                rendition => $s->{rendition},
                caption   => $s->{label}
            );

        $labelObj->create("show");
        $s->{label} = $labelObj;

        my $pos = 0;

        $s->{rendition} = urxvt::SET_BGCOLOR $s->{rendition}, $s->{pictorials_bg};
        for my $i (@pictorials) {
            my $x = $s->{x} + $w + $pos++;
            foreach ( &RED, &GREEN, &BLUE, &YELLOW, &WHITE, &PINK ) {
                $s->{rendition} = urxvt::SET_FGCOLOR $s->{rendition}, $_;
                my $pictorial = cdmn::visuals::overlay->new(
                    term      => $s->{term},
                    x         => $x,
                    y         => $s->{y},
                    width     => 1,
                    height    => 1,
                    rendition => $s->{rendition},
                    caption   => BLOCKS->[0]
                );
                $pictorial->create;
                $s->{pictorials}{"$i"}{"$_"} = $pictorial;
            }
        }
    }

    sub show {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        for ( values %{ $s->{pictorials} } ) {
            for ( values %{$_} ) {
                $visible ? $_->show : $_->hide;
            }
        }
    }

    sub hide {
        (shift)->show(FALSE);
    }

    sub show_label {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        $visible ? $s->{label}->show : $s->{label}->hide;
    }

    sub hide_label {
        (shift)->show_label(FALSE);
    }

    sub set {
        my ( $s, $i, $usage, $invert) = @_;
        my $barIdx = $usage / 10 * 8 / 10;

        return if !$s->{pictorials}{"$i"};
        $usage = 100 - $usage if $invert;
        my $color = &getColor($usage);
        for ( values %{ $s->{pictorials}{"$i"} } ) {
            $_->hide;
        }
        if ( $barIdx <= 8 && $barIdx >= 0 ) {
            $s->{pictorials}{"$i"}{"$color"}->show;
            $s->{pictorials}{"$i"}{"$color"}->set( BLOCKS->[$barIdx] );
        }
    }
}

package cdmn::visuals::overlay {
    use fields qw( term x y width height rendition caption );
    use fields qw( overlay );

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        (%$s) = @_;
        $s;
    }

    sub create {
        my ( $s, $show ) = ( shift, shift );
        my ( $x, $y, $w, $h, $r, $c ) = ( $s->{x}, $s->{y}, $s->{width}, $s->{height}, $s->{rendition}, $s->{caption} );

        $s->{overlay} = $s->{term}->overlay( $x, $y, $w, $h, $r, 0 );

        $s->set($c) if defined $c;
        $s->hide if !$show;
    }

    sub set {
        my $s = shift;
        $s->{caption} = shift;
        $s->{overlay}->set( 0, 0, $s->{caption} );    #TODO
        for ( 0 .. $s->{height} ) {
            $s->{overlay}->set( 0, $_, $s->{caption} ) if $s->{height} > 1;    #TODO
        }
    }

    for my $h (qw(hide show)) {
        eval qq{ sub $h { my \$s = shift; \$s->{overlay}->$h; } };             ## no critic
    }
}

use constant XR => cdmn::resources->new();

####################################################
#   UTILITY METHODS
####################################################

sub create_captions {
    my ($s) = (@_);
    my $caption;

    local *addGauges = sub {
        my (%s) = @_;

        for my $h (qw(cpu disk memory)) {
            eval qq{
            for ( \@{ XR->{gauges_order} } ) {
                 \$_ eq XR->{label_$h} and \$caption->add(
                label => \$_, visuals => \$s{$h}, bg => XR->{caption_bg} );
            }};
        }

        for ( @{ XR->{gauges_order} } ) {
            $_ eq XR->{label_network} and $caption->add(
                label => $_, visuals => $s{network}, bg => XR->{caption_bg} ) if scalar @{$s{network}} > 0;

            $_ eq XR->{label_cpu_temp} and $caption->add(
                label => $_, visuals => $s{cores}, bg => XR->{caption_bg} ) if scalar @{$s{cores}} > 0;

            $_ eq XR->{label_battery} and $caption->add(
                label   => &cdmn::proc::ac_online ? XR->{label_battery_AC} : $_,
                visuals => $s{battery}, bg => XR->{caption_bg}
            ) if scalar @{$s{battery}} > 0;
        }
    };

    for ( XR->{caption} ) {
        $caption = do {
            if ($_ eq cdmn::constants::CAPTION_BAR) {
                cdmn::visuals::container->new(
                    term       => $s,
                    rendition  => cdmn::constants::REND,
                    x          => XR->{x},
                    y          => XR->{y},
                    padding    => XR->{padding},
                    align      => $_,
                    evenGauges => 0,
                    visible    => XR->{showing}
                );
            }
            elsif ($_ eq cdmn::constants::CAPTION_BLOCK) {
                cdmn::visuals::container->new(
                    term       => $s,
                    rendition  => cdmn::constants::REND,
                    x          => - 1,
                    y          => XR->{y},
                    padding    => 0,
                    align      => $_,
                    evenGauges => 1,
                    visible    => XR->{showing}
                );
            }
        };
    }

    state $cpus = cdmn::proc::cpu_count() - 1;

    addGauges(
        cpu     => [ map "cpu".$_, 0 .. $cpus ],
        disk    => XR->{gauges_disks},
        memory  => [ "MemAvailable:" ],
        network => XR->{gauges_nics},
        battery => XR->{gauges_batteries},
        cores   => XR->{gauges_cores},
    );

    return \$caption;
}

####################################################
#   HANDLERS
####################################################

sub user_command {
    my ( $s, $action ) = (@_);

    if ($action eq &cdmn::constants::ACTION_SHOW) {
        my $h = $s->fheight * ( $s->nrow - 1 );
        my $w = $s->width;
        my $x = 0;
        my $y = XR->{y} >= 0 ? $s->fheight : -1;

        if ( $s->{xterms}{main}{maximized} ) {
            $s->{xterms}{main}->bounds( $x, $y + 1, $w + 4, $h + 4 );    #TODO why add 4?
            $s->{xterms}{main}{maximized} = 0;
            ${$s->{caption}->[0]}->hide;
            $SHOWING = 1;
        }
        else {
            $s->{xterms}{main}->bounds( 0, 0, $s->width + 4, $s->height + 4 );    #TODO why add 4?
            $s->{xterms}{main}{maximized} = 1;
            $SHOWING = 0;
        }
    }

    if ($action eq &cdmn::constants::ACTION_SHOW_TRANSPARENT) {
        if ( $s->{xterms}{main}{maximized} ) {
            my $c = ${$s->{caption}->[0]};
            if ($c->{visible}) {
                $c->hide;
                $SHOWING = 0;
            }
            else {
                $c->show;
                $SHOWING = 1;
            }
        }
    }

    if ($action eq &cdmn::constants::ACTION_SHOW_SIDEBAR and XR->{showing}) {
        $s->{xterms}{sidebar}->toggle;
    }

    1;
}

sub on_refresh_begin {
    my ($s) = @_;
    my $nics_active = cdmn::proc->if_list;
    state $onAC = 0;
    state $nics = 0;

    if ($s->{w_sizse} != $s->{term}->ncol || &cdmn::proc::ac_online != $onAC || $nics != scalar @$nics_active) {
        my @visible = map {$$_->{visible}} @{($s->{caption})};
        my $n = [ map {$_."_tx", $_."_rx"} @$nics_active ];

        $onAC = !$onAC;
        $nics = scalar @$nics_active;

        XR->{gauges_nics} = $n;

        $s->{w_sizse} = $s->{term}->ncol;
        $s->{visuals_updater}->stop;
        $s->{caption}[0] = create_captions $s->{xterms}{main}{term};
        $s->{caption}[1] = create_captions $s;

        while ( my ( $key, $item ) = each @{($s->{caption})} ) {
            ${$item}->create;
            $visible[$key] ? ${$item}->show : ${$item}->hide;
        }
        $s->{visuals_updater}->start;
    }

    1;
}

####################################################
#   TERM HANDLERS
####################################################

sub on_configure_notify {
    my $s = shift;
    my $h = $s->fheight * ( $s->nrow - 1 ) + 4;
    my $w = $s->width;
    my $x = 0;
    my $y = XR->{y} >= 0 ? $s->fheight : -1;

    if ( $s->{xterms}{main}{maximized} ) {
        $s->{xterms}{main}->bounds( 0, 0, $s->width + 4, $s->height + 4 );    #TODO why add 4?
    }
    else {
        $s->{xterms}{main}->bounds( $x, $y + 1, $w + 4, $h );                 #TODO why add 4?
    }
    $s->{xterms}{sidebar}->bounds( $w - $s->fwidth * 35 + 4, 0, $s->fwidth * 35, $s->height + 4 );    #TODO why add 4?
    $s->{xterms}{sidebar}->create_content;

    1;
}

for my $h (qw(key_press key_release)) {
    ## no critic
    eval qq{
    sub on_$h {
        my (\$s, \$e) = \@_;
        \$s->{xterms}{main}{term}->$h (\$e->{state}, \$e->{keycode}, \$e->{time}); 1; }
    };
}


for my $h (qw(focus_in focus_out)) {
    eval qq{ sub on_$h { (shift)->{xterms}{main}{term}->$h; 1; } }; ## no critic
}

sub on_wm_delete_window {
    cdmn::term::destroy_All;
    1;
}

sub on_tt_write {
    (shift)->{xterms}{main}{term}->tt_write(shift);
    1;
}

####################################################
#   MAIN
####################################################

sub on_init {
    my ($s) = @_;

    XR->{label_network} = $s->x_resource('%.label.network') // 'NET';
    XR->{label_disk}         = $s->x_resource('%.label.disk')         // 'DISK';
    XR->{label_cpu}          = $s->x_resource('%.label.cpu')          // 'CPU';
    XR->{label_cpu_temp} = $s->x_resource('%.label.cpu.temp') // 'TEMP';
    XR->{label_memory} = $s->x_resource('%.label.ram') // 'MEM';
    XR->{label_battery} = $s->x_resource('%.label.battery') // 'BAT';
    XR->{label_battery_AC} = XR->{label_battery}."(⌁)";
    XR->{showing}            = $s->x_resource('%.showing')            // 1;
    $SHOWING = XR->{showing};
    XR->{showing_labels}     = $s->x_resource('%.showing.labels')     // 1;
    XR->{showing_background} = $s->x_resource('%.showing.background') // 1;
    XR->{caption}            = $s->x_resource('%.caption')            // 'bar';       #block | bar | solid-bar
    XR->{caption_bg} = $s->x_resource('%.caption-background') // '235';
    XR->{padding}            = $s->x_resource('%.padding')            // 2;           #Padding between visuals
    XR->{x} = $s->x_resource('%.x') // -1;    #positive from left, negativ from right
    XR->{y} = $s->x_resource('%.y') // 0;     #positive from top, negativ from bottom

    my $disks = $s->x_resource('%.gauges.disks') // 'sda';    #Can be a list, e.g. 'a,b,c' or 'a b c'
    $disks = [ split( /[[:punct:],[:space:]]/, $disks ) ];
    XR->{gauges_disks} = cdmn::proc::disks;                 #TODO remove this overwrite and make it a tolerant default

    #Can be a list, e.g. 'a,b,c' or 'a b c'
    my $nics = $s->x_resource('%.gauges.nics') // 'eth0_rx,eth0_tx,eth1_rx,eth1_tx';

    #$nics = [ split( /[,[:space:]]/, $nics ) ];
    $nics = cdmn::proc->if_list;
    $nics = [ map {$_."_tx", $_."_rx"} @$nics ]; #TODO remove this overwrite and make it a tolerant
    # default
    XR->{gauges_nics} = $nics;

    my $batteries = cdmn::proc->batteries; #TODO remove this overwrite and make it a tolerant default
    XR->{gauges_batteries} = $batteries;

    my $cores = cdmn::proc->cores; #TODO remove this overwrite and make it a tolerant default
    XR->{gauges_cores} = $cores;

    my $order = $s->x_resource('%.caption-order') // 'DISK,CPU,TEMP,MEM,NET,BAT';
    $order = [ split( /[[:punct:],[:space:]]/, $order ) ];

    my @order_default;
    for (qw/label_network label_disk label_cpu label_memory label_battery label_cpu_temp/) {
        push( @order_default, XR->{$_} );
    }

    my %gauges = map { $_ => 0 } @order_default;
    while ( my ( $key, $value ) = each @$order ) {
        if (!grep( /^$value$/, @order_default )) {
            splice @$order, $key, $key;
        }
        else { $gauges{$value} = 1 }
    }

    XR->{gauges} = \%gauges;

    ( scalar @$order > 0 ) ? ( XR->{gauges_order} = $order ) : ( XR->{gauges_order} = \@order_default );

    XR->{gauges_background} = $s->x_resource('%.gauges-background') // '5';    #simple | full

    ();
}

sub on_start {
    my ($s) = @_;

    #TODO maybe just create with 0 and handle everything else in config_notify
    $s->{xterms}{main} = cdmn::term->new(
        parent   => $s,
        resource => XR,
        x        => 0,
        y        => XR->{y} >= 0 ? $s->fheight : 0,
        w        => $s->width,
        h        => $s->fheight * ( $s->nrow - 1 ),
        bg_color => 4,
        is_root  => 1
    );

    $s->{xterms}{main}{maximized} = 1 if XR->{caption} eq cdmn::constants::CAPTION_BAR;
    $s->{xterms}{sidebar} = cdmn::term->new(
        parent   => $s,
        resource => XR,
        x        => $s->width / 2,
        y        => 0,
        w        => $s->width / 2 + 1,
        h        => $s->fheight * ( $s->nrow ),
        bg_color => 5,
        is_root  => 0
    );

    $s->{xterms}{sidebar}->disableCursor;
    $s->{xterms}{sidebar}->create_content;
    $s->{xterms}{sidebar}->hide;
    $s->{xterms}{main}->show;

    $s->{xterms}{main}->hide if ( XR->{caption} eq cdmn::constants::CAPTION_BLOCK );

    $s->{w_sizse}    = $s->{term}->ncol;
    $s->{caption}[0] = create_captions $s->{xterms}{main}{term};
    $s->{caption}[1] = create_captions $s;
    ${$s->{caption}[0]}->create;
    ${$s->{caption}[1]}->create;

    $s->cmd_parse("\e[2T\e[2B"); #Scroll down and move cursor down 2 line.
    $s->cmd_parse("\033[?25l");    #do not show the cursor!

    $s->{visuals_updater} = urxvt::timer->new->start( int urxvt::NOW )->interval(1)->cb(
        sub {
            return if !$SHOWING;
            my %r;
            my $onAC = &cdmn::proc::ac_online;

            if (XR->{gauges}{ XR->{label_battery} }) {
                %r = %{&cdmn::proc::battery_usages};
                while ( my ( $key, $value ) = each %r ) {
                    $$_->set( $onAC ? XR->{label_battery_AC} : XR->{label_battery}, $key, $value,
                        1 ) foreach @{ $s->{caption} };
                }
            }

            for my $h (qw(cpu disk memory cpu_temp)) {
                eval qq{
                    if (XR->{gauges}{ XR->{label_cpu} }) {
                        %r = %{&cdmn::proc::${h}_usages};
                        while ( my ( \$key, \$value ) = each %r ) {
                            \$\$_->set( XR->{label_${h}}, \$key, \$value ) foreach \@{ \$s->{caption} };
                        }
                    }
                };
            }

            if (XR->{gauges}{ XR->{label_network} }) {
                %r = %{ &cdmn::proc::network_usages("rx_bytes") };
                while ( my ( $key, $value ) = each %r ) {
                    $$_->set( XR->{label_network}, $key, $value ) foreach @{ $s->{caption} };
                }

                %r = %{ &cdmn::proc::network_usages("tx_bytes") };
                while ( my ( $key, $value ) = each %r ) {
                    $$_->set( XR->{label_network}, $key, $value ) foreach @{ $s->{caption} };
                }
            }
        }
    );

    ();
}