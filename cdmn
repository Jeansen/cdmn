#! perl

# cdmn is an extension written for the rxvt terminal emulator that shows
# utilizations of different system resoureces like cpu, disk i/o, ram,
# network (and more).

# Copyright (C) 2016-2017 Marcel Lautenbach
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use 5.10.1;
use strict;
use warnings FATAL => 'all';
use utf8;
use autodie;

binmode STDOUT, ":encoding(UTF-8)";

my $SHOWING;

package cdmn::proc {
    use List::Util qw(sum max min);

    use constant {
        PARTITIONS  => '/proc/partitions',
        MOUNTS      => '/proc/mounts',
        STAT        => '/proc/stat',
        DISKSTATS   => '/proc/diskstats',
        MEMINFO     => '/proc/meminfo',
        NET_ROUTE   => '/proc/net/route',
    };

    use constant {
        SPEED     => 'speed',
        OPERSTATE => 'operstate',
        TX        => 'tx_bytes',
        RX        => 'rx_bytes',
        BAT_FULL  => 'full',
        BAT_NOW   => 'now',
    };

    use constant {
        CPU_PRESENT => '/sys/devices/system/cpu/present',
        HWMON       => '/sys/class/hwmon/',
        SYSFS_NET   => '/sys/class/net/',
        SYSFS_BAT   => '/sys/class/power_supply/',
        SYSFS_BLOCK => '/sys/block/',
    };

    #TODO sometimes no results are given - check
    sub cpu_temp_usages {
        my %results;
        if (-e HWMON) {
            opendir( my $dh, HWMON );
            my @dir = readdir $dh;
            for (@dir) {
                next if $_ =~ /^\.\.?$/;
                my $p = HWMON.$_;
                open( my $f, '<', $p."/name") || last;
                chomp(my $state = <$f>);
                if ($state eq 'coretemp') {
                    opendir( $dh, $p );
                    @dir = readdir $dh;
                    my %cores = map {/(temp\d)/ ? (($_ =~ /(temp\d)/), "") : ()} @dir;
                    for (keys %cores) {
                        open( $f, '<', $p."/".$_."_input");
                        chomp(my $cv = <$f>);
                        open( $f, '<', $p."/".$_."_crit");
                        chomp(my $mv = <$f>);
                        open( $f, '<', $p."/".$_."_label");
                        chomp(my $l = <$f>);
                        last if $l !~ /^Core/;
                        $results{$l} = $cv / $mv * 100;
                    }
                    last;
                }
            }
            closedir $dh;
        }
        return \%results;
    }

    sub cores {
        my @results;
        opendir( my $dh, HWMON );
        my @dir = readdir $dh;
        for (@dir) {
            next if $_ =~ /^\.\.?$/;
            my $p = HWMON.$_;
            open( my $f, '<', $p."/name");
            chomp(my $state = <$f>);
            if ($state eq 'coretemp') {
                opendir( $dh, $p );
                @dir = readdir $dh;
                my %cores = map {/(temp\d)/ ? (($_ =~ /(temp\d)/), "") : ()} @dir;
                for (keys %cores) {
                    open( $f, '<', $p."/".$_."_label");
                    chomp(my $l = <$f>);
                    push @results, $l if $l =~ /^Core/;
                };
                last;
            }
        }
        closedir $dh;
        return \@results;
    }

    sub sysfs_net {
        my $path = SYSFS_NET."/$_[0]";
        return $path."/statistics/$_[1]" if $_[1] && ($_[1] eq TX || $_[1] eq RX);
        return $path."/$_[1]" if $_[1] && ($_[1] eq OPERSTATE || $_[1] eq SPEED);
        $path;
    }

    sub sysfs_bat {
        my $path = SYSFS_BAT."/$_[0]";
        opendir( my $dh, $path );
        if ($_[1]) {
            while ( readdir $dh ) {
                $path .= "/".$_ if /^energy_full$|^charge_full$/ && $_[1] eq BAT_FULL;
                $path .= "/".$_ if /^energy_now$|^charge_now$/ && $_[1] eq BAT_NOW;
            }
        }
        closedir $dh;
        $path;
    }

    sub ac_online {
        opendir( my $dh, SYSFS_BAT );
        my @dir = readdir $dh; #while ( readdir $dh ) too slow?
        for (@dir) {
            if (/AC/) {
                open( my $f, '<', SYSFS_BAT.$_."/online");
                chomp(my $state = <$f>);
                closedir $dh;
                return $state;
            }
        }
        closedir $dh;
        0;
    }

    sub has_wifi {
        opendir( my $dh, sysfs_net(shift) );
        my @dir = readdir $dh;
        for (@dir) { return 1 if (/wireless/); }
        closedir $dh;
        0;
    }

    sub if_down {
        open( my $f, '<', sysfs_net(shift, OPERSTATE) );
        chomp(my $state = <$f>);
        # RFC2863 operational states: unknown notpresent down up lowerlayerdown testing dormant
        return 1 if $state eq 'down' || $state eq 'unknown';
        0;
    }

    sub if_list {
        my @ifs;
        opendir( my $dh, SYSFS_NET);
        my @dir = readdir $dh;
        for (@dir) {
            my $if = $_;
            next if (/^\.\.?$|^veth/);
            if (!has_wifi($if)) {
                open( my $f, '<', sysfs_net($if, SPEED) );
                chomp(my @lines = <$f>);
                next if scalar @lines eq 0;
            }
            next if if_down($if);
            push @ifs, $if;
        }
        closedir $dh;
        return \@ifs;
    }

    sub mounts {
        open( my $f, '<', MOUNTS );
        my @mounts;
        my %mounts;
        while (<$f>) {
            push @mounts, /(^\/dev\S*)\s+([a-zA-Z0-9-_.\/]+)/;   #TODO this regex is too simple
            %mounts = (@mounts);
        }
        return \%mounts;
    }

    sub battery_usages {
        my %results;
        my @bats = @{&batteries};
        for (@bats) {
            my $bat = $_;
            open( my $f, '<', sysfs_bat($bat, BAT_FULL) );
            chomp(my $full = <$f>);
            open( $f, '<', sysfs_bat($bat, BAT_NOW));
            chomp(my $now = <$f>);

            $results{ $bat } = $now / $full * 100;
        }
        return \%results;
    }

    sub batteries {
        my @bats;
        opendir( my $dh, SYSFS_BAT);
        while ( readdir $dh ) {
            my $bat = $_;
            next if (/^\.\.?$/);
            next if (/^AC/);
            push @bats, $bat;
        }
        closedir $dh;
        return \@bats;
    }

    sub disks {
        opendir( my $dh, SYSFS_BLOCK);
        state @disks;
        return \@disks if scalar @disks > 0; #TODO just until cdmn is aware of changes.
        my @block;
        while ( readdir $dh ) {
            my $block = $_;
            next if (/^\.\.?$|dm-|^loop|^sr/);
            push @disks, $block;
        }
        closedir $dh;
        return \@disks;
    }

    sub dm_disks {
        opendir( my $dh, SYSFS_BLOCK);
        my %block;
        while ( readdir $dh ) {
            my $block = $_;
            next if !(/^dm-/);
            open( my $f, '<', SYSFS_BLOCK."$block/dm/name" );
            chomp(my $d = <$f>);

            opendir( my $dh2, SYSFS_BLOCK."$block/slaves");
            $block{$d} = [ map {/(sd[a-z]|nvme\dn|mmcblk)/} readdir $dh2 ];
        }
        closedir $dh;
        return \%block;
    }

    sub disk_mounts {
        my @mounts = keys %{&mounts};
        my @disks = (map {$_, 0} @{&disks});
        my %dm = %{&dm_disks};
        my %disks = @disks;

        foreach my $m (@mounts) {
            foreach my $k (keys %disks) {
                $disks{$k} = 1 if $m =~ /$k/;
            }
            while ( my ( $k, $v ) = each %dm ) {
                if ($m =~ $k) {
                    $disks{$_} = 1 foreach @$v;
                }
            }
        }

        @disks = ();
        while ( my ( $k, $v ) = each %disks ) {
            push @disks, $k if $v;
        }
        return \@disks;
    }

    sub cpu_usages {
        state %cpus;
        my $diff_usage = 0;
        my %results;

        open( my $f, '<', STAT );
        while (<$f>) {
            next if ( !/^cpu[0-9]*\s+[0-9]+/ );

            my @cpu = split /\s+/;
            my $cpu = shift @cpu;

            if (!defined $cpus{$cpu}) {
                $cpus{$cpu}{$_} = 0 for qw/prev_idle prev_total diff_total/;
            }

            my $idle  = $cpu[3];
            my $total = sum(@cpu);

            my $diff_idle = $idle - $cpus{$cpu}{prev_idle};
            if ( $total != $cpus{$cpu}{prev_total} ) {
                $cpus{$cpu}{diff_total} = $total - $cpus{$cpu}{prev_total};
            }
            $diff_usage = 100 * ( $cpus{$cpu}{diff_total} - $diff_idle ) / $cpus{$cpu}{diff_total};

            $cpus{$cpu}{prev_idle}  = $idle;
            $cpus{$cpu}{prev_total} = $total;

            $results{$cpu} = $diff_usage;
        }
        return \%results;
    }

    sub cpu_count {
        open( my $f, '<', CPU_PRESENT );
        {
            local $/;
            my $cpus = <$f>;
            $cpus =~ /-([0-9]+)/;
            return $1 + 1;
        }
    }

    #p1 = refresh in seconds, e.g. 1, 0.1
    sub disk_usages {
        state %sda;
        my $diff_usage;
        my %results;

        open( my $f, '<', DISKSTATS );
        while (<$f>) {
            if (!/\bsd(a|b|c)|nvme\dn\d\b|mmcblk\d\b/) {
                next;
            }
            my @sda = split /\s+/, $_;
            shift @sda;
            shift @sda;
            shift @sda;

            $sda{ $sda[0] } = $sda{ $sda[0] } // 0;

            my $diff_sda = $sda[10] - $sda{ $sda[0] };
            $diff_usage = $diff_sda / (1000 * $_[0]) * 100;

            $sda{ $sda[0] }     = $sda[10];
            $results{ $sda[0] } = $diff_usage <= 100 ? $diff_usage : 100;
        }
        return \%results;
    }

    sub memory_usages {
        my @sda;
        my $total     = 0;
        my $available = 0;
        my %results;

        open( my $f, '<', MEMINFO );
        while (<$f>) {
            if (/^MemTotal:\s+[0-9]+/) {
                @sda = split /\s+/, $_;
                $total = $sda[1];
            }
            if (/^MemAvailable:\s+[0-9]+/) {
                @sda = split /\s+/, $_;
                $available = $sda[1];
            }
        }

        $results{ $sda[0] } = 100 - ( 100 * $available / $total );
        return \%results;
    }

    #p1 = refresh in seconds, e.g. 1, 0.1
    sub network_usages {
        my $direction = shift;

        my %results;
        my $bytes = 0;
        state %nics;

        for (@{&if_list}) {
            my $nic = $_;
            if (!defined $nics{$nic}) {
                $nics{$nic}{$_} = 0 for (RX, TX);
            }

            open( my $f, '<', sysfs_net($nic, $direction) );
            {
                local $/;
                $bytes = <$f>;
            }

            my $diff_rx = $bytes - $nics{$nic}{$direction};
            $nics{$nic}{$direction} = $bytes;
            my $diff_usage = $diff_rx / (&nic_speed_bytes($nic) * $_[0]) * 100;
            $results{ $nic.( $direction eq RX ? '_rx' : '_tx' ) } = $diff_usage;
        }
        return \%results;
    }

    sub getWanInterface {
        open( my $fh, '<', NET_ROUTE );

        my $if = <$fh>;
        $if = <$fh>;

        my @wif = split /\s+/, $if;
        $wif[0];
    }

    sub nic_speed_bytes {
        my $if = shift;
        my $speed;
        state $refresh = 4;
        state $wifispeed;
        if (has_wifi($if)) {
            if ($refresh >= 4) {
                $refresh = 0;
                my $c = qx/sudo iwconfig $if/;
                ($wifispeed) = $c =~ /Bit Rate.(\d*\.{0,1}\d*)/;
                $speed = $wifispeed;
            }
            else {
                $refresh++;
                $speed = $wifispeed;
            }
        }
        else {
            open( my $fh, '<', sysfs_net($if, SPEED) );
            $speed = <$fh>;
        }
        $speed *= 1000000 / 8;
        return $speed;
    }
}

package cdmn::constants {
    use constant {
        ACTION_SHOW             => 'cdmn:show',
        ACTION_SHOW_LABELS      => 'cdmn:show-labels',
        ACTION_SHOW_SIDEBAR     => 'cdmn:show-sidebar',
        ACTION_SHOW_TRANSPARENT => 'cdmn:action-show-transparent',
    };

    use constant {
        CAPTION_BLOCK     => 'block',
        CAPTION_BAR       => 'bar',
        CAPTION_SOLID_BAR => 'solid-bar',
    };

    use constant REND => urxvt::SET_COLOR urxvt::OVERLAY_RSTYLE, 255, 1;
}

package cdmn::resources {
    use Scalar::Util qw(looks_like_number);

    my $t;
    use fields qw(
        x  y  padding
            showing  showing_labels  showing_background
            caption  caption_bg
            label_network  label_disk  label_cpu  label_memory label_battery  label_battery_AC label_cpu_temp label_bg label_fg
            gauges  gauges_disks  gauges_nics gauges_batteries gauges_order gauges_bg gauges_cores gauges_colors gauges_invert
            actions network_tx network_rx
            cpu cpu_temp battery disk_mounts refresh sensitivity visual_style
            colors_network colors_disk colors_cpu colors_cpu_temp colors_memory colors_battery
        );

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        return $s;
    }

    sub cut_set {
        my @cut = ();
        my %n = ();

        foreach my $e (@{$_[0]}, @{$_[1]}) { $n{$e}++ }
        foreach my $e (@{$_[0]}) { push @{ \@cut}, $e if $n{$e} > 1 }

        return \@cut;
    }

    sub init {

        local *_set = sub {
            $t->x_resource("%.$_[0]") ? [ split( /[,[:space:]]/, $t->x_resource("%.$_[0]") ) ] : $_[1] ? [ split(
                    /[,[:space:]]/, $_[1]) ]                                                           : [ () ];
        };

        my $s = shift;
        $t = shift;
        $s->{label_network} = $t->x_resource('%.label.network') || 'NET';
        $s->{label_disk} = $t->x_resource('%.label.disk') || 'DISK';
        $s->{label_cpu} = $t->x_resource('%.label.cpu') || 'CPU';
        $s->{label_cpu_temp} = $t->x_resource('%.label.cpu.temp') || 'TEMP';
        $s->{label_memory} = $t->x_resource('%.label.memory') || 'MEM';
        $s->{label_battery} = $t->x_resource('%.label.battery') || 'BAT';
        $s->{label_battery_AC} = $s->{label_battery}."(⌁)";
        $s->{label_fg} = looks_like_number($t->x_resource('%.label.fg')) || 0;
        $s->{label_bg} = looks_like_number($t->x_resource('%.label.fg')) || 1;

        $s->{showing} = looks_like_number($t->x_resource('%.showing')) || 1; #TODO
        $s->{showing_labels} = looks_like_number($t->x_resource('%.showing.labels')) || 1; #TODO
        $s->{showing_background} = looks_like_number($t->x_resource('%.showing.background')) || 1; #TODO

        $s->{caption} = $t->x_resource('%.caption') || 'bar'; #block | bar | solid-bar #TODO
        $s->{caption_bg} = looks_like_number($t->x_resource('%.caption.bg')) || 1; # 0/1 map onto terminal fg/bg color

        $s->{padding} = looks_like_number($t->x_resource('%.padding')) || 2; #Padding between visuals
        $s->{x} = looks_like_number($t->x_resource('%.x')) || - 1; #positive from left, negativ from right
        $s->{y} = looks_like_number($t->x_resource('%.y')) || 0; #positive from top, negativ from bottom
        $s->{cpu} = $t->x_resource('%.cpu') // 'simple';     #simple | detail
        $s->{cpu_temp} = $t->x_resource('%.cpu.temp') // 'simple'; #simple | detail
        $s->{battery} = $t->x_resource('%.battery') // 'simple'; #simple | detail
        $s->{disk_mounts} = looks_like_number($t->x_resource('%.disk.mounts')) || 1; #TODO rename
        $s->{refresh} = looks_like_number($t->x_resource('%.refresh')) || 1;
        $s->{sensitivity} = looks_like_number($t->x_resource('%.sensitivity')) || 1; #percentage
        $s->{visual_style} = $t->x_resource('%.visual.style') // 'bar'; #bar | led

        #$s->{gauges_order} = $t->x_resource('%.gauges.order') ? [ split( /[,[:space:]]/, $t->x_resource('%.gauges.order') ) ] : [split( /[,[:space:]]/, 'CPU,TEMP,DISK,MEM,NET,BAT')];

        $s->{gauges_order} = _set('%.gauges.order');
        $s->{gauges_disks} = _set('%.gauges.disks');
        $s->{gauges_batteries} = _set('%.gauges.batteries');
        $s->{gauges_cores} = _set('%.gauges.cores');
        $s->{network_rx} = _set('%.network.rx');
        $s->{network_tx} = _set('%.network.tx');
        $s->{gauges_invert} = _set('%.gauges.invert', 'BAT');

        $s->{gauges_bg} = looks_like_number($t->x_resource('%.gauges.bg')) || '1';
        $s->{gauges_colors} = looks_like_number($t->x_resource('%.gauges.colors')) || '-2';

        #DEBUG
        #  $s->{colors_network} = $t->x_resource('%.colors.network') || '0,52,88,124,160,196';
        #  $s->{colors_disk} = $t->x_resource('%.colors.disk') || '0,17,18,19,20,21';
        #  $s->{colors_cpu} = $t->x_resource('%.colors.cpu') || '0,22,28,34,40,46';
        #  $s->{colors_cpu_temp} = $t->x_resource('%.colors.cpu.temp') || '0,94,130,166,172,208';
        #  $s->{colors_memory} = $t->x_resource('%.colors.memory') || '0,100,184,226,';
        #  $s->{colors_battery} = $t->x_resource('%.colors.battery') || '0,94,130,166,172,208';


        #   #$s->{gauges_invert} = '';
        #   $s->{cpu} = 'detail';     #simple | detail
        #   $s->{cpu_temp} = 'detail';     #simple | detail
        #   $s->{battery} = 'detail';     #simple | detail
        #   $s->{visual_style} = 'led'; #block | led
        #   $s->{sensitivity} = 0.01;
        #   $s->{refresh} = 0.1;
        #   #$s->{gauges_colors} = '0,52, ,x,16d0,196'; #Test invalid values
        #   $s->{gauges_colors} = '0,52,88,124,160,196';
        $s->{gauges_colors} = '246,246,2,4,3,1';
        #   #$s->{caption_bg} = '3'; # 0/1 map onto terminal fg/bg color
        $s->{label_fg} = '5';
        #   #$s->{label_bg} = '1';
        $s->{cpu} = 'detail';     #simple | detail
        #   $s->{gauges_bg} = '1';    #simple | full
        #   $s->{gauges_order} = 'CPU,TEMP,DISK,MEM,NET,BAT';
        #   $s->{network_rx} = 'etasdh0';
        #   $s->{network_tx} = 'etasdh0';
        #   $s->{y} = 0; #
    }


    my $validate = sub {
        my $s = shift;
        my @order_default = map { $s->{$_} } (qw/ label_cpu label_cpu_temp label_disk label_memory label_network label_battery /);
        my %gauges = map { $_ => 0 } @order_default;
        $gauges{$_} = 1 for $_[0];
        $s->{gauges} = \%gauges; #TODO necessary?
        return \@order_default if scalar @{$_[0]} eq 0;
        return &cut_set($_[0], \@order_default);
    };

    sub set_order {
        my $s = shift;
        $s->{gauges_order} = $validate->($s, $s->{gauges_order});
    }

    sub set_invert {
        my $s = shift;
        $s->{gauges_invert} = $validate->($s, $s->{gauges_invert});
    }

    sub set_nics {
        my $s = shift;
        my $nics_active = cdmn::proc->if_list;

        my $rx_tx = &cut_set($s->{network_tx}, $nics_active);
        my @tx = map {$_."_tx"} @$rx_tx;

        $rx_tx = &cut_set($s->{network_rx}, $nics_active);
        my @rx = map {$_."_rx"} @$rx_tx;

        if (scalar @tx eq 0 and scalar @rx eq 0) {
            $s->{gauges_nics} = [ map {$_."_rx", $_."_tx"} @$nics_active ];
        } else {
            $s->{gauges_nics} = [ @rx, @tx ];
        }
    }

    sub set_disks {
        my $s = shift;
        $s->{gauges_disks} = $s->{disk_mounts} ? cut_set(cdmn::proc::disk_mounts, $s->{gauges_disks}) : cut_set (
                cdmn::proc::disks, $s->{gauges_disks});
        $s->{gauges_disks} = $s->{disk_mounts} ? cdmn::proc::disk_mounts : cdmn::proc::disks if scalar @{$s->{gauges_disks}} eq 0;
    }

    #TODO min count colors, check invalid values, ...
    sub set_colors {
        my $s = shift;
        for my $h (qw(network disk cpu cpu_temp memory battery)) {
            $s->{"colors_$h"} = [
                map {$_ + 2} grep (looks_like_number($_), split( /[,[:space:]]/, $s->{"colors_$h"}))
            ] if $s->{"colors_$h"};
        }
        $s->{gauges_colors} = [
            map {$_ + 2} grep (looks_like_number($_), split( /[,[:space:]]/, $s->{gauges_colors}))
        ];
    }

    for my $h (qw(batteries cores)) {
        ## no critic
        eval qq{
            sub set_$h {
                my \$s = shift;
                \$s->{gauges_$h} = cut_set(cdmn::proc::$h, \$s->{gauges_$h});
                \$s->{gauges_$h} = cdmn::proc::$h if scalar \@{\$s->{gauges_$h}} eq 0;
            }
        }
    };
}

package cdmn::term {
    use Filesys::Df;
    use POSIX qw(ceil floor);

    use fields qw(x y w h term parent bg_color content is_root resource maximized);
    use constant { REND => cdmn::constants::REND, };

    my @terminals;
    my $root;
    my @data;

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;
        (%$s) = @_;

        push @urxvt::TERM_INIT, sub {
                my ($term) = @_;
                $term->{termclass} = $s;
                $term->{parent} = $s->{parent} if $s->{is_root};
                $term->resource( perl_ext_2 => "-cdmn" );    #TODO remove magic name
            };

        push @urxvt::TERM_EXT, __PACKAGE__;

        my $environ = $s->{parent}->env;
        $environ->{SHELL} = 'sh' if !$s->{is_root};

        $s->{term} = new urxvt::term( $environ, $urxvt::RXVTNAME, -embed => $s->{parent}->parent, -depth => 32 );
        $s->bounds( @$s{qw/x y w h/} );
        $s->{is_root} ? $root = $s : push( @terminals, $s );

        $s;
    }

    sub on_user_command {
        (shift)->{term}{termclass}{parent}->user_command(@_);
        1;
    }

    sub on_init {
        my $s = shift;
        $s->bind_action( 'M-h', 'perl:'.&cdmn::constants::ACTION_SHOW );
        $s->bind_action( 'M-l', 'perl:'.&cdmn::constants::ACTION_SHOW_SIDEBAR );
        $s->bind_action( 'M-o', 'perl:'.&cdmn::constants::ACTION_SHOW_TRANSPARENT );
        ();
    }

    sub on_tt_write {
        if (!(shift)->{term}{parent}) {
            $root->{term}->tt_write(shift);
            1;
        }
        ();
    }

    sub on_refresh_begin {
        my $s = shift;
        if ( !$s->{term}{parent} ) {
            my $str = $s->{term}->locale_encode("\e[0;0H\e[K");
            $s->{term}->cmd_parse($str);    #do not show the cursor!
            1;
        }
        ();
    }

    sub bounds {
        my $s = shift;
        @$s{qw/x y w h/} = @_;
        $s->{term}->XMoveResizeWindow( $s->{term}->parent, @_ );
    }

    sub on_destroy {
        if ( $_[0]{term}{parent} ) {
            ${$_[0]{term}{parent}{caption}[0]}->hide;    #prevent segmentation fauls!
            $_->{term}->destroy for @terminals;
            my $p = $_[0]{term}{parent} or return;
            $p->{d} = urxvt::iw->new->start->cb( sub { $p->destroy } );
        }
        1;
    }

    sub destroy_All { $root->{term}->destroy; }

    sub disableCursor { (shift)->{term}->cmd_parse("\033[?25l"); }

    #TODO refactor - just for testing at the moment
    sub create_content {
        my $s      = shift;
        my $mounts = cdmn::proc::mounts;
        my $r = urxvt::SET_FGCOLOR REND, 240;         #TODO remove magic number/hard-coded value

        $data[0] = cdmn::visuals::overlay->new(
            term      => $s->{term},
            x         => 0,
            y         => 0,
            width     => 1,
            height    => $root->{parent}->nrow,
            rendition => $r,
            caption   => "│"
        );

        $r = urxvt::SET_FGCOLOR REND, 250;            #TODO remove magic number/hard-coded value
        $r = $r | urxvt::RS_Uline;

        my $i = 1;
        push @data, cdmn::visuals::overlay->new(
                term      => $s->{term},
                x         => - 1,
                y         => $i++,
                width     => 32,
                height    => 1,
                rendition => $r,
                caption   => 'FS USAGE'
            );

        $r = urxvt::SET_FGCOLOR REND, 250;
        for (keys %$mounts) {
            my $ref = df( $mounts->{$_} );
            my $u   = ceil( 25 * $ref->{per} / 100 );
            my $f   = floor( 25 - 25 * $ref->{per} / 100 );

            $i++;
            push @data, cdmn::visuals::overlay->new(
                    term      => $s->{term},
                    x         => - 1,
                    y         => $i++,
                    width     => 32,
                    height    => 1,
                    rendition => $r,
                    caption   => $$mounts{$_}
                );

            push @data,
                cdmn::visuals::overlay->new(
                    term      => $s->{term},
                    x         => - 1,
                    y         => $i++,
                    width     => 32,
                    height    => 1,
                    rendition => $r,
                    caption   => "■" x $u."□" x $f." $ref->{per}%"
                );
        }

        for ( my $j = 1 ; $j < @data ; $j++ ) {
            $data[$j]->create("show");
        }
        $data[0]->create("show");
    }

    sub hide {
        my $s = shift;
        $s->{term}->XUnmapWindow( $s->{term}->parent );
    }

    sub show {
        my $s = shift;
        $s->{term}->XMapWindow( $s->{term}->parent );
    }

    sub toggle {
        my $s = shift;
        $s->{term}->mapped ? $s->hide : $s->show;
    }
}

package cdmn::visuals::container {
    use fields qw( term rendition padding align evenGauges x y bg_color);
    use fields qw( sprites visible bg backgroundVisible labelVisible);

    use constant {
        TRUE          => 1,
        FALSE         => 0,
        CAPTION_BAR   => cdmn::constants::CAPTION_BAR,
        CAPTION_BLOCK => cdmn::constants::CAPTION_BLOCK,
    };

    my ( $xOff, $yOff, $m ) = ( 0, 0, 0 );

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        (%$s) = @_;
        ( $xOff, $yOff ) = ( 0, $s->{y} );
        $s;
    }

    sub add {
        my $s = shift;
        my %arg = @_;
        my $visual = cdmn::visuals::visual->new(
            term          => $s->{term},
            rendition     => $s->{rendition},
            x             => $xOff,
            y             => $yOff,
            label         => $arg{label},
            gauges        => $arg{gauges},
            label_bg      => $arg{label_bg},
            label_fg      => $arg{label_fg},
            gauges_colors => $arg{gauges_colors},
            gauges_bg     => $arg{gauges_bg},
            visual_style  => $arg{visual_style},
            sensitivity   => $arg{sensitivity},
        );

        $s->{sprites}{$arg{label}} = $visual;
        if (@{$arg{gauges}} > $m && $s->{evenGauges}) {
            $m = @{$arg{gauges}};
            foreach ( values %{ $s->{sprites} } ) {
                $_->setEvenGauges($m);
                $xOff += $visual->{width} if $s->{align} eq CAPTION_BAR;
            }
        }
        $visual->setEvenGauges($m) if $s->{evenGauges};
        $xOff += $visual->{width} + $s->{padding}  if $s->{align} eq CAPTION_BAR;
        $yOff += $visual->{height} + $s->{padding} if $s->{align} eq CAPTION_BLOCK;
    }

    sub create {
        my $s = shift;

        if ( $s->{x} < 0 ) {
            for ( $s->{align} ) {
                if ( $_ eq CAPTION_BAR ) {
                    $_->{x} = $s->{term}->ncol - $xOff + $_->{x} + $s->{x} + $s->{padding} + 1
                        foreach ( values %{ $s->{sprites} } );
                }
                if ( $_ eq CAPTION_BLOCK ) {
                    $_->{x} = $s->{term}->ncol - $_->{x} - $_->{width} + $s->{x} foreach ( values %{ $s->{sprites} } );
                }
            }
        }
        else {
            $_->{x} += $s->{x} foreach values %{ $s->{sprites} };
        }
        $_->create foreach values %{ $s->{sprites} };

        #Background
        for ( $s->{align} ) {
            if ( $_ eq CAPTION_BAR ) {
                $s->{bg} = cdmn::visuals::overlay->new(
                    term      => $s->{term},
                    x         => $s->{x},
                    y         => $s->{y},
                    width     => $xOff - $s->{padding},
                    height    => 1,
                    rendition => urxvt::SET_BGCOLOR cdmn::constants::REND, $s->{bg_color},
                );

                $s->{bg}->create("show");
                $s->{backgroundVisible} = 1;
            }
        }
    }

    sub set {
        my ( $s, $label, $i, $usage, $invert) = (@_);
        if ( $s->{visible} ) {
            $s->{sprites}{$label}->set( $i, $usage, $invert) if $s->{sprites}{$label};
        }
        $s->refresh_background;
    }

    sub show {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        foreach ( values %{ $s->{sprites} } ) {
            $visible ? $_->show : $_->hide;
        }
        $visible ? $s->show_labels : $s->hide_labels;

        $visible ? $s->show_background : $s->hide_background;
        $s->{visible} = $visible;
    }

    sub hide { (shift)->show(FALSE); }

    sub toggle {
        my $s = shift;
        $s->{visible} ? $s->hide : $s->show;
    }

    sub show_labels {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        foreach ( values %{ $s->{sprites} } ) {
            $visible ? $_->show_label : $_->hide_label;
        }

        $s->refresh_background;
        $s->{labelVisible} = $visible;
    }

    sub hide_labels { (shift)->show_labels(FALSE); }

    sub show_background {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        if ( $s->{align} eq CAPTION_BAR ) {
            $visible ? $s->{bg}->show : $s->{bg}->hide;
            $s->{backgroundVisible} = $visible;
        }
    }

    # TODO still necessary?
    sub refresh_background {
        my $s = shift;
        if ( $s->{backgroundVisible} ) {
            $s->hide_background;
            $s->show_background;
        }
    }

    sub hide_background { (shift)->show_background(FALSE); }
}

package cdmn::visuals::visual {
    use List::Util qw(max);

    use fields qw( term rendition x y label gauges label_bg label_fg gauges_colors gauges_bg visual_style sensitivity);
    use fields qw( count width height);

    use constant BLOCKS => [qw/_ ▁ ▂ ▃ ▄ ▅ ▆ ▇ █/];
    #use constant LED => '⬛';
    use constant LED => '■';
    use constant { TRUE => 1, FALSE => 0 };

    my $m = 0;

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        (%$s) = @_;

        $s->{width} = ( length $s->{label} ) + 1 + @{ $s->{gauges} };
        $s->{height} = 1;
        return $s;
    }

    sub setEvenGauges {
        my ( $self, $max ) = @_;
        $self->{width} += ( - @{ $self->{gauges} } + $max );
    }

    sub create {
        my $s          = shift;
        my $w          = ( length $s->{label} ) + 1;
        my @gauges = @{ $s->{gauges} };

        $s->{gauges} = { };
        $s->{x}          = -( $w + $m ) if $s->{x} < 0;
        $s->{rendition} = urxvt::SET_COLOR $s->{rendition}, $s->{label_fg}, $s->{label_bg};

        my $labelObj =
            cdmn::visuals::overlay->new(
                term      => $s->{term},
                x         => $s->{x},
                y         => $s->{y},
                width     => $w,
                height    => $s->{height},
                rendition => $s->{rendition},
                caption   => $s->{label}
            );

        $labelObj->create("show");
        $s->{label} = $labelObj;

        my $pos = 0;

        $s->{rendition} = urxvt::SET_BGCOLOR $s->{rendition}, $s->{gauges_bg};
        for my $i (@gauges) {
            my $x = $s->{x} + $w + $pos++;
            foreach (@{$s->{gauges_colors}}) {
                $s->{rendition} = urxvt::SET_FGCOLOR $s->{rendition}, $_;
                my $pictorial = cdmn::visuals::overlay->new(
                    term      => $s->{term},
                    x         => $x,
                    y         => $s->{y},
                    width     => 1,
                    height    => 1,
                    rendition => $s->{rendition},
                    caption   => BLOCKS->[0],
                );
                $pictorial->create;
                $s->{gauges}{"$i"}{"$_"} = $pictorial;
            }
        }
    }

    sub show {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        for (values %{ $s->{gauges} }) {
            for ( values %{$_} ) {
                $visible ? $_->show : $_->hide;
            }
        }
    }

    sub hide {
        (shift)->show(FALSE);
    }

    sub show_label {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        $visible ? $s->{label}->show : $s->{label}->hide;
    }

    sub hide_label {
        (shift)->show_label(FALSE);
    }

    sub set {
        my ( $s, $i, $usage, $invert) = @_;
        return if !$s->{gauges}{"$i"};

        my $size = scalar @{&BLOCKS};
        my $bar_i = ($usage > 100 ? 100 : $usage) / 100 * ($size);
        $usage = 100 - $usage if $invert;
        $bar_i -= 1 if $bar_i >= $size;
        $size = scalar @{$s->{gauges_colors}};
        my $clr_i = ($usage > 100 ? 100 : $usage) / 100 * ($size - 1) + 1;
        $clr_i -= 1 if $clr_i >= $size;
        my $color = $usage < $s->{sensitivity} ? $s->{gauges_colors}[0] : $s->{gauges_colors}[$clr_i];
        for (values %{ $s->{gauges}{"$i"} }) {
            $_->hide;
        }

        $s->{gauges}{"$i"}{"$color"}->set( BLOCKS->[$bar_i] ) if $s->{visual_style} eq 'bar';
        $s->{gauges}{"$i"}{"$color"}->set( LED ) if $s->{visual_style} eq 'led';
        $s->{gauges}{"$i"}{"$color"}->show;
    }
}

package cdmn::visuals::overlay {
    use fields qw( term x y width height rendition caption );
    use fields qw( overlay );

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        (%$s) = @_;
        $s;
    }

    sub create {
        my ( $s, $show ) = ( shift, shift );
        my ( $x, $y, $w, $h, $r, $c ) = ( $s->{x}, $s->{y}, $s->{width}, $s->{height}, $s->{rendition}, $s->{caption} );

        $s->{overlay} = $s->{term}->overlay( $x, $y, $w, $h, $r, 0 );

        $s->set($c) if defined $c;
        $s->hide if !$show;
    }

    sub set {
        my $s = shift;
        $s->{caption} = shift;
        $s->{overlay}->set( 0, 0, $s->{caption} );    #TODO
        for ( 0 .. $s->{height} ) {
            $s->{overlay}->set( 0, $_, $s->{caption} ) if $s->{height} > 1;    #TODO
        }
    }

    for my $h (qw(hide show)) {
        eval qq{ sub $h { my \$s = shift; \$s->{overlay}->$h; } }; ## no critic
    }
}

use constant XR => cdmn::resources->new();

####################################################
#   UTILITY METHODS
####################################################

sub create_captions {
    my ($s) = (@_);
    my $caption;

    local *_create = sub {
        my (%arg) = @_;

        local *add = sub {
            local $_ = XR->{label_battery_AC} if $_[0] eq 'battery' and &cdmn::proc::ac_online;
            $caption->add(label                 => $_, gauges => $arg{$_[0]}, label_bg => XR->{label_bg}, gauges_bg =>
                XR->{gauges_bg}, label_fg       => XR->{label_fg}, gauges_colors => $_[1], visual_style =>
                XR->{visual_style}, sensitivity => XR->{sensitivity});
        };

        for ( @{ XR->{gauges_order} } ) {
            $_ eq XR->{label_cpu} and add('cpu', XR->{colors_cpu} || XR->{gauges_colors});
            $_ eq XR->{label_disk} and add('disk', XR->{colors_disk} || XR->{gauges_colors});
            $_ eq XR->{label_memory} and add('memory', XR->{colors_memory} || XR->{gauges_colors});
            $_ eq XR->{label_network} and add('network', XR->{colors_network} || XR->{gauges_colors}) if $arg{network};
            $_ eq XR->{label_cpu_temp} and add('cores', XR->{colors_cpu_temp} || XR->{gauges_colors}) if $arg{cores};
            $_ eq XR->{label_battery} and add('battery', XR->{colors_battery} || XR->{gauges_colors}) if $arg{battery};
        }
    };

    for ( XR->{caption} ) {
        $caption = do {
            if ($_ eq cdmn::constants::CAPTION_BAR) {
                cdmn::visuals::container->new(
                    term       => $s,
                    rendition  => cdmn::constants::REND,
                    x          => XR->{x},
                    y          => XR->{y},
                    padding    => XR->{padding},
                    align      => $_,
                    evenGauges => 0,
                    visible    => XR->{showing},
                    bg_color   => XR->{caption_bg},
                );
            }
            elsif ($_ eq cdmn::constants::CAPTION_BLOCK) {
                cdmn::visuals::container->new(
                    term       => $s,
                    rendition  => cdmn::constants::REND,
                    x          => - 1,
                    y          => XR->{y},
                    padding    => 0,
                    align      => $_,
                    evenGauges => 1,
                    visible    => XR->{showing},
                    bg_color   => XR->{caption_bg},
                );
            }
        };
    }

    state $cpus = cdmn::proc::cpu_count() - 1;

    my %args;
    $args{cores} = (XR->{cpu_temp} eq 'simple' ? [ "simple" ] : XR->{gauges_cores}) if @{XR->{gauges_cores}} > 0;
    $args{cpu} = XR->{cpu} eq 'simple' ? [ "simple" ] : [ map "cpu".$_, 0 .. $cpus ];
    $args{disk} = XR->{gauges_disks} if @{XR->{gauges_disks}} > 0;
    $args{memory} = [ "MemAvailable:" ];
    $args{network} = XR->{gauges_nics} if @{XR->{gauges_nics}} > 0;
    $args{battery} = (XR->{battery} eq 'simple' ? [ "simple" ] : XR->{gauges_batteries}) if XR->{gauges_batteries} > 0;

    _create((%args));

    return \$caption;
}

####################################################
#   HANDLERS
####################################################

sub user_command {
    my ( $s, $action ) = (@_);

    if ($action eq &cdmn::constants::ACTION_SHOW) {
        my $h = $s->fheight * ( $s->nrow - 1 );
        my $w = $s->width;
        my $x = 0;
        my $y = XR->{y} >= 0 ? $s->fheight : -1;

        if ( $s->{xterms}{main}{maximized} ) {
            $s->{xterms}{main}->bounds( $x, $y + 1, $w + 4, $h + 4 );    #TODO why add 4?
            $s->{xterms}{main}{maximized} = 0;
            ${$s->{caption}->[0]}->hide;
            $SHOWING = 1;
        }
        else {
            $s->{xterms}{main}->bounds( 0, 0, $s->width + 4, $s->height + 4 );    #TODO why add 4?
            $s->{xterms}{main}{maximized} = 1;
            $SHOWING = 0;
        }
    }

    if ($action eq &cdmn::constants::ACTION_SHOW_TRANSPARENT) {
        if ( $s->{xterms}{main}{maximized} ) {
            my $c = ${$s->{caption}->[0]};
            if ($c->{visible}) {
                $c->hide;
                $SHOWING = 0;
            }
            else {
                $c->show;
                $SHOWING = 1;
            }
        }
    }

    if ($action eq &cdmn::constants::ACTION_SHOW_SIDEBAR and XR->{showing}) {
        $s->{xterms}{sidebar}->toggle;
    }

    1;
}

sub on_refresh_begin {
    my ($s) = @_;
    my $nics_active = cdmn::proc->if_list;
    state $onAC = 0;
    state $nics = 0;

    if ($s->{w_sizse} != $s->{term}->ncol || &cdmn::proc::ac_online != $onAC || $nics != scalar @$nics_active) {
        my @visible = map {$$_->{visible}} @{($s->{caption})};

        $onAC = !$onAC;
        $nics = scalar @$nics_active;

        XR->set_nics;

        $s->{w_sizse} = $s->{term}->ncol;
        $s->{visuals_updater}->stop;
        $s->{caption}[0] = create_captions $s->{xterms}{main}{term};
        $s->{caption}[1] = create_captions $s;

        while ( my ( $key, $item ) = each @{($s->{caption})} ) {
            ${$item}->create;
            $visible[$key] ? ${$item}->show : ${$item}->hide;
        }
        $s->{visuals_updater}->start;
    }

    1;
}

####################################################
#   TERM HANDLERS
####################################################

sub on_configure_notify {
    my $s = shift;
    return if $s->{w_sizse} eq $s->{term}->ncol;
    refresh_bounds $s;
    1;
}

sub refresh_bounds{
    my $s = shift;
    my $h = $s->fheight * ( $s->nrow - 1 ) + 4;
    my $w = $s->width;
    my $x = 0;
    my $y = XR->{y} >= 0 ? $s->fheight : -1;

    if ( $s->{xterms}{main}{maximized} ) {
        $s->{xterms}{main}->bounds( 0, 0, $s->width + 4, $s->height + 4 );    #TODO why add 4?
    }
    else {
        $s->{xterms}{main}->bounds( $x, $y + 1, $w + 4, $h );                 #TODO why add 4?
    }
    $s->{xterms}{sidebar}->bounds( $w - $s->fwidth * 35 + 4, 0, $s->fwidth * 35, $s->height + 4 );    #TODO why add 4?
    $s->{xterms}{sidebar}->create_content; #TODO Memory Leak / but will go away when refactoring the sidebar
}

for my $h (qw(key_press key_release)) {
    ## no critic
    eval qq{
    sub on_$h {
        my (\$s, \$e) = \@_;
        \$s->{xterms}{main}{term}->$h (\$e->{state}, \$e->{keycode}, \$e->{time}); 1; }
    };
}

for my $h (qw(focus_in focus_out)) {
    eval qq{ sub on_$h { (shift)->{xterms}{main}{term}->$h; 1; } }; ## no critic
}

sub on_wm_delete_window {
    cdmn::term::destroy_All;
    1;
}

sub on_tt_write {
    (shift)->{xterms}{main}{term}->tt_write(shift);
    1;
}

####################################################
#   MAIN
####################################################


sub on_init {
    my ($s) = @_;

    XR->init($s);

    $SHOWING = XR->{showing};

    XR->set_disks;
    XR->set_batteries;
    XR->set_cores;
    XR->set_nics;
    XR->set_order;
    XR->set_invert;
    XR->set_colors;

    ();
}


sub on_start {
    my ($s) = @_;

    $s->{xterms}{main} = cdmn::term->new(
        parent   => $s,
        resource => XR,
        x        => 0,
        y        => XR->{y} >= 0 ? $s->fheight : 0,
        w        => $s->width,
        h        => $s->fheight * ( $s->nrow - 1 ),
        bg_color => 4,
        is_root  => 1
    );

    $s->{xterms}{main}{maximized} = 1 if XR->{caption} eq cdmn::constants::CAPTION_BAR;
    $s->{xterms}{sidebar} = cdmn::term->new(
        parent   => $s,
        resource => XR,
        x        => $s->width / 2,
        y        => 0,
        w        => $s->width / 2 + 1,
        h        => $s->fheight * ( $s->nrow ),
        bg_color => 5,
        is_root  => 0
    );

    $s->{xterms}{sidebar}->disableCursor;
    $s->{xterms}{sidebar}->create_content;
    $s->{xterms}{sidebar}->hide;
    $s->{xterms}{main}->show;

    $s->{xterms}{main}->hide if ( XR->{caption} eq cdmn::constants::CAPTION_BLOCK );

    $s->{w_sizse}    = $s->{term}->ncol;
    $s->{caption}[0] = create_captions $s->{xterms}{main}{term};
    $s->{caption}[1] = create_captions $s;
    ${$s->{caption}[0]}->create;
    ${$s->{caption}[1]}->create;

    $s->cmd_parse("\e[2T\e[2B"); #Scroll down and move cursor down 2 line.
    $s->cmd_parse("\033[?25l");    #do not show the cursor!

    $s->{visuals_updater} = urxvt::timer->new->start( int urxvt::NOW )->interval(XR->{refresh})->cb(
        sub {
            return if !$SHOWING;
            my %r;

            local *_set = sub {
                my $h = shift;
                my $simple = shift;
                my $total = 0;
                my %inverts = map { $_ => 1 } @{XR->{gauges_invert}};

                my $is_bat_ac = ($h eq XR->{label_battery} || $h eq XR->{label_battery_AC});
                %r = %{&cdmn::proc::cpu_usages} if $h eq XR->{label_cpu};
                %r = %{&cdmn::proc::cpu_temp_usages} if $h eq XR->{label_cpu_temp};
                %r = %{&cdmn::proc::memory_usages} if $h eq XR->{label_memory};
                %r = %{&cdmn::proc::disk_usages(XR->{refresh})} if $h eq XR->{label_disk};
                %r = %{&cdmn::proc::battery_usages} if $is_bat_ac;
                %r = (%{ &cdmn::proc::network_usages("rx_bytes", XR->{refresh})}, %{&cdmn::proc::network_usages
                        ("tx_bytes", XR->{refresh})}) if
                    $h eq XR->{label_network};

                my @k = keys %r;
                return 1 if scalar @k < 1;

                if ($simple) {
                    $total += $_ foreach values %r;
                    $total /= scalar @k;
                    $$_->set( $h, 'simple', $total, $inverts{$h}) foreach @{ $s->{caption} };
                }
                else {
                    while ( my ( $key, $value ) = each %r ) {
                        $$_->set( $h, $key, $value, $inverts{$h}) foreach @{ $s->{caption} };
                    }
                }
                1;
            };

            foreach (keys %{${$s->{caption}[0]}->{sprites}}) {
                my $v = $_;
                $v eq XR->{label_cpu} and _set($v, XR->{cpu} eq 'simple') and next;
                $v eq XR->{label_cpu_temp} and _set($v, XR->{cpu_temp} eq 'simple') and next;
                ($v eq XR->{label_battery} or $v eq XR->{label_battery_AC} ) and _set($v,
                    XR->{battery} eq 'simple') and next;
                _set($v);
            }
        }
    );
    refresh_bounds $s;
    ();
}