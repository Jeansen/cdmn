#! perl

# cdmn is an extension written for the rxvt terminal emulator that shows
# utilizations of different system resoureces like cpu, disk i/o, ram,
# network (and more).

# Copyright (C) 2016-2017 Marcel Lautenbach
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use 5.10.1;
use strict;
use warnings FATAL => 'all';
use utf8;

package cdmn::proc {
    use List::Util qw(sum max min);
    use Data::Dumper;

    use constant {
        PARTITIONS  => '/proc/partitions',
        MOUNTS      => '/proc/mounts',
        STAT        => '/proc/stat',
        DISKSTATS   => '/proc/diskstats',
        MEMINFO     => '/proc/meminfo',
        CPU_PRESENT => '/sys/devices/system/cpu/present',
    };

    sub getNics {
        my @nics;
        opendir( my $dh, '/sys/class/net' );
        while ( readdir $dh ) {
            my $nic = $_;
            if (!/^\.|^l/) {
                push @nics, $_."_rx";
                push @nics, $_."_tx";
            }
        }
        return @nics;
    }

    sub getMounts {
        open( my $f, '<', MOUNTS );
        my @mounts;
        my %mounts;
        while (<$f>) {
            push @mounts, /(^\/dev\S*)\s+([a-zA-Z-_\/]+)/;    #TODO this regex is too simple
            %mounts = (@mounts);
        }
        return %mounts;
    }

    sub getDisks {
        open( my $f, '<', PARTITIONS );
        my @disks;
        while (<$f>) {
            push @disks, /(sd[a-z]$)/;
            push @disks, /(nvme\dn\d$)/;
        }

        return \@disks;
    }

    sub getCpuUsage {
        state %cpus;
        my $diff_usage = 0;
        my %results;

        open( my $f, '<', STAT );
        while (<$f>) {
            if ( !/^cpu[0-9]*\s+[0-9]+/ ) {
                next;
            }

            my @cpu = split /\s+/;
            my $cpu = shift @cpu;

            if (!defined $cpus{$cpu}) {
                $cpus{$cpu}{$_} = 0 for qw/prev_idle prev_total diff_total/;
            }

            my $idle  = $cpu[3];
            my $total = sum(@cpu);

            my $diff_idle = $idle - $cpus{$cpu}{prev_idle};
            if ( $total != $cpus{$cpu}{prev_total} ) {
                $cpus{$cpu}{diff_total} = $total - $cpus{$cpu}{prev_total};
            }
            $diff_usage = 100 * ( $cpus{$cpu}{diff_total} - $diff_idle ) / $cpus{$cpu}{diff_total};

            $cpus{$cpu}{prev_idle}  = $idle;
            $cpus{$cpu}{prev_total} = $total;

            $results{$cpu} = $diff_usage;
        }
        return \%results;
    }

    sub getCpuCount {
        open( my $f, '<', CPU_PRESENT );
        {
            local $/;
            my $cpus = <$f>;
            $cpus =~ /-([0-9]+)/;
            return $1 + 1;
        }
    }

    sub getDiskUsage {
        state %sda;
        my $diff_usage;
        my %results;

        open( my $f, '<', DISKSTATS );
        while (<$f>) {
            if ( !/\bsd(a|b|c)|nvme\dn\d\b/ ) {
                next;
            }
            my @sda = split /\s+/, $_;
            shift @sda;
            shift @sda;
            shift @sda;

            $sda{ $sda[0] } = $sda{ $sda[0] } // 0;

            my $diff_sda = $sda[10] - $sda{ $sda[0] };
            $diff_usage = $diff_sda / 10;

            $sda{ $sda[0] }     = $sda[10];
            $results{ $sda[0] } = $diff_usage;
        }
        return \%results;
    }

    sub getMemoryUsage {
        my @sda;
        my $total     = 0;
        my $available = 0;
        my %results;

        open( my $f, '<', MEMINFO );
        while (<$f>) {
            if (/^MemTotal:\s+[0-9]+/) {
                @sda = split /\s+/, $_;
                $total = $sda[1];
            }
            if (/^MemAvailable:\s+[0-9]+/) {
                @sda = split /\s+/, $_;
                $available = $sda[1];
            }
        }

        $results{ $sda[0] } = 100 - ( 100 * $available / $total );
        return \%results;
    }

    sub getNetworkUsage {
        my $direction = shift;

        my %results;
        my $bytes = 0;
        state %nics;

        opendir( my $dh, '/sys/class/net' );
        while ( readdir $dh ) {
            my $nic = $_;
            if (!/^\.|^l/) {
                if (!defined $nics{$nic}) {
                    $nics{$nic}{$_} = 0 for qw/rx_bytes tx_bytes/;
                }

                open( my $f, '<', "/sys/class/net/$_/statistics/$direction" );
                {
                    local $/;
                    $bytes = <$f>;
                }

                my $diff_rx = $bytes - $nics{$nic}{$direction};
                $nics{$nic}{$direction} = $bytes;

                my $diff_usage = 100 * $diff_rx / &getInterfaceSpeed($nic);
                $results{ $nic.( $direction eq 'rx_bytes' ? '_rx' : '_tx' ) } = $diff_usage;
            }
        }
        closedir $dh;

        return \%results;
    }

    sub getWanInterface {
        open( my $fh, '<', '/proc/net/route' );

        my $if = <$fh>;
        $if = <$fh>;

        my @wif = split /\s+/, $if;
        return $wif[0];
    }

    sub getInterfaceSpeed {
        my $if = shift;
        open( my $fh, '<', "/sys/class/net/$if/speed" );
        my $speed = <$fh>;
        $speed *= 1000000 / 8;
        return $speed;
    }
}

package cdmn::constants {
    use constant {
        ACTION_SHOW             => 'cdmn:show',
        ACTION_SHOW_LABELS      => 'cdmn:show-labels',
        ACTION_SHOW_SIDEBAR     => 'cdmn:show-sidebar',
        ACTION_SHOW_TRANSPARENT => 'cdmn:action-show-transparent',
    };

    use constant {
        CAPTION_BLOCK     => 'block',
        CAPTION_BAR       => 'bar',
        CAPTION_SOLID_BAR => 'solid-bar',
    };

    use constant REND => urxvt::SET_COLOR urxvt::OVERLAY_RSTYLE, 255, 1;
}

package cdmn::resources {
    use fields qw(
      x  y  padding
      showing  showing_labels  showing_background
      caption  caption_bg
      label_network  label_disk  label_cpu  label_ram
      gauges  gauges_disks  gauges_nics  gauges_order  gauges_background
      actions
    );

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        return $s;
    }
}

package cdmn::term {
    use Filesys::Df;
    use POSIX qw(ceil floor);

    use fields qw(x y w h term parent bg_color content is_root resource maximized);
    use constant { REND => cdmn::constants::REND, };

    my @terminals;
    my $root;
    my @data;

    sub new {
        my $s = shift;

        $s = fields::new($s) unless ref $s;

        $s->{parent} = shift;
        @$s{qw/resource x y w h bg_color is_root/} = (@_);

        # save a backlink to us, make sure tabbed is inactive
        push @urxvt::TERM_INIT, sub {
            my ($term) = @_;
            $term->{termclass} = $s;
            $term->{parent} = $s->{parent} if $s->{is_root};
                $term->resource( perl_ext_2 => "-cdmn" );    #TODO remove magic name
        };

        push @urxvt::TERM_EXT, __PACKAGE__;

        my $environ = $s->{parent}->env;
        $environ->{SHELL} = 'sh' if !$s->{is_root};

        $s->{term} = new urxvt::term( $environ, $urxvt::RXVTNAME, -embed => $s->{parent}->parent, -depth => 32 );
        $s->bounds( @$s{qw/x y w h/} );
        $s->{is_root} ? $root = $s : push( @terminals, $s );

        return $s;
    }

    sub on_user_command {

        #my ($s, $a) = ($_[0], $_[1] =~ /([a-zA-Z-]*$)/);
        my $s = shift;
        $s->{term}{termclass}{parent}->user_command(@_);
        1;
    }

    sub on_init {
        my $s = shift;
        $s->bind_action( 'M-h', 'perl:'.&cdmn::constants::ACTION_SHOW );
        $s->bind_action( 'M-l', 'perl:'.&cdmn::constants::ACTION_SHOW_SIDEBAR );
        $s->bind_action( 'M-o', 'perl:'.&cdmn::constants::ACTION_SHOW_TRANSPARENT );
    }

    sub on_tt_write {
        my $s = shift;
        if ( !$s->{term}{parent} ) {
            $root->{term}->tt_write(shift);
            return 1;
        }
        ();
    }

    sub on_refresh_begin {
        my $s = shift;
        if ( !$s->{term}{parent} ) {
            my $str = $s->{term}->locale_encode("\e[0;0H\e[K");
            $s->{term}->cmd_parse($str);    #do not show the cursor!
            return 1;
        }
    }

    sub bounds {
        my $s = shift;
        @$s{qw/x y w h/} = @_;
        $s->{term}->XMoveResizeWindow( $s->{term}->parent, @_ );
    }

    sub on_destroy {
        if ( $_[0]{term}{parent} ) {
            $_[0]{term}{parent}{caption}[0]->hide;    #prevent segmentation fauls!
            $_->{term}->destroy for @terminals;
            my $p = $_[0]{term}{parent} or return;    #TODO get to understand it!
            $p->{d} = urxvt::iw->new->start->cb( sub { $p->destroy } );
        }
        1;
    }

    sub destroy_All {
        $root->{term}->destroy;
    }

    sub disableCursor {
        (shift)->{term}->cmd_parse("\033[?25l");      #do not show the cursor!
    }

    sub setContent {
        my $s      = shift;
        my %mounts = cdmn::proc::getMounts;

        my $r = urxvt::SET_FGCOLOR REND, 240;         #TODO remove magic number/hard-coded value

        $data[0] = cdmn::visuals::overlay->new( $s->{term}, 0, 0, 1, $root->{parent}->nrow, $r, "│" );
        $r = urxvt::SET_FGCOLOR REND, 250;            #TODO remove magic number/hard-coded value
        $r = $r | urxvt::RS_Uline;

        my $i = 1;
        push @data, cdmn::visuals::overlay->new( $s->{term}, - 1, $i++, 32, 1, $r, 'FS USAGE' );
        $r = urxvt::SET_FGCOLOR REND, 250;
        for ( keys %mounts ) {
            my $ref = df( $mounts{$_} );
            my $u   = ceil( 25 * $ref->{per} / 100 );
            my $f   = floor( 25 - 25 * $ref->{per} / 100 );

            $i++;
            push @data, cdmn::visuals::overlay->new( $s->{term}, - 1, $i++, 32, 1, $r, $mounts{$_} );
            push @data,
                cdmn::visuals::overlay->new( $s->{term}, - 1, $i++, 32, 1, $r, "■" x $u."□" x $f." $ref->{per}%" );
        }

        for ( my $j = 1 ; $j < @data ; $j++ ) {
            $data[$j]->create("show");
        }
        $data[0]->create("show");
    }

    sub hide {
        my $s = shift;
        $s->{term}->XUnmapWindow( $s->{term}->parent );
    }

    sub show {
        my $s = shift;
        $s->{term}->XMapWindow( $s->{term}->parent );
    }

    sub toggle {
        my $s = shift;
        $s->{term}->mapped ? $s->hide : $s->show;
    }
}

package cdmn::visuals::container {
    use fields qw( term rendition padding align evenGauges x y );
    use fields qw( sprites visible bg backgroundVisible labelVisible);

    use constant {
        TRUE          => 1,
        FALSE         => 0,
        CAPTION_BAR   => cdmn::constants::CAPTION_BAR,
        CAPTION_BLOCK => cdmn::constants::CAPTION_BLOCK,
        REND          => cdmn::constants::REND,
    };

    my ( $xOff, $yOff, $m ) = ( 0, 0, 0 );

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        @$s{qw/term rendition x y padding align evenGauges visible/} = @_;
        ( $xOff, $yOff ) = ( 0, $s->{y} );
        return $s;
    }

    #TODO no Reference for visuals?
    sub add {
        my ( $s, $label, $visuals, $captbg ) = @_;
        my $visual = cdmn::visuals::visual->new( $s->{term}, $s->{rendition}, $xOff, $yOff, $label, $visuals, $captbg );

        $s->{sprites}{$label} = $visual;
        if ( @{$visuals} > $m && $s->{evenGauges} ) {
            $m = @{$visuals};
            foreach ( values %{ $s->{sprites} } ) {
                $_->setEvenGauges($m);
                $xOff += $visual->{width} if $s->{align} eq CAPTION_BAR;
            }
        }
        $visual->setEvenGauges($m) if $s->{evenGauges};
        $xOff += $visual->{width} + $s->{padding}  if $s->{align} eq CAPTION_BAR;
        $yOff += $visual->{height} + $s->{padding} if $s->{align} eq CAPTION_BLOCK;
    }

    sub create {
        my $s = shift;

        if ( $s->{x} < 0 ) {
            for ( $s->{align} ) {
                if ( $_ eq CAPTION_BAR ) {
                    $_->{x} = $s->{term}->ncol - $xOff + $_->{x} + $s->{x} + $s->{padding} + 1
                      foreach ( values %{ $s->{sprites} } );
                }
                if ( $_ eq CAPTION_BLOCK ) {
                    $_->{x} = $s->{term}->ncol - $_->{x} - $_->{width} + $s->{x} foreach ( values %{ $s->{sprites} } );
                }
            }
        }
        else {
            $_->{x} += $s->{x} foreach values %{ $s->{sprites} };
        }
        $_->create foreach values %{ $s->{sprites} };

        #Background
        for ( $s->{align} ) {
            if ( $_ eq CAPTION_BAR ) {
                $s->{bg} = cdmn::visuals::overlay->new( $s->{term}, - 1, 0, $xOff - 1, 1, REND );
                $s->{bg}->create("show");
                $s->{backgroundVisible} = 1;
            }
        }
    }

    sub set {
        my ( $s, $label, $i, $usage ) = (@_);
        if ( $s->{visible} ) {
            $s->{sprites}{$label}->set( $i, $usage );
        }
        $s->refreshBackground;
    }

    sub setColor {
        my ( $s, $label, $i, $usage ) = @_;
        $s->{sprites}{$label}->setColor( $i, $usage );
    }

    sub show {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        foreach ( values %{ $s->{sprites} } ) {
            $visible ? $_->show : $_->hide;
        }
        $visible ? $s->showLabels : $s->hideLabels;

        $visible ? $s->showBackground : $s->hideBackground;
        $s->{visible} = $visible;
    }

    sub hide {
        my ($s) = @_;
        $s->show(FALSE);
    }

    sub toggle {
        my $s = shift;
        $s->{visible} ? $s->hide : $s->show;
    }

    sub showLabels {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        foreach ( values %{ $s->{sprites} } ) {
            $visible ? $_->showLabel : $_->hideLabel;
        }

        $s->refreshBackground;
        $s->{labelVisible} = $visible;
    }

    sub hideLabels {
        my ($s) = @_;
        $s->showLabels(FALSE);
    }

    sub showBackground {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        if ( $s->{align} eq CAPTION_BAR ) {
            $visible ? $s->{bg}->show : $s->{bg}->hide;
            $s->{backgroundVisible} = $visible;
        }
    }

    sub refreshBackground {
        my ($s) = @_;
        if ( $s->{backgroundVisible} ) {
            $s->hideBackground;
            $s->showBackground;
        }
    }

    sub hideBackground {
        my ($s) = @_;
        $s->showBackground(FALSE);
    }
}

package cdmn::visuals::visual {
    use List::Util qw(max);

    use fields qw( term rendition x y label pictorials pictorials_bg );
    use fields qw( count width height );

    use constant BLOCKS => [qw/_ ▁ ▂ ▃ ▄ ▅ ▆ ▇ █/];
    use constant { TRUE => 1, FALSE => 0 };
    use constant {
        RED    => 3,
        GREEN  => 4,
        PINK   => 7,
        YELLOW => 5,
        BLUE   => 6,
        WHITE  => 248,
    };

    my $m = 0;

    sub getColor {
        for (shift) {
            return RED    if $_ > 80;
            return YELLOW if $_ > 60;
            return BLUE   if $_ > 40;
            return GREEN  if $_ > 20;
        }
        WHITE;
    }

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        @$s{qw/term rendition x y label pictorials pictorials_bg/} = @_;

        $s->{width}  = ( length $s->{label} ) + 1 + @{ $s->{pictorials} };
        $s->{height} = 1;
        return $s;
    }

    sub setEvenGauges {
        my ( $self, $max ) = @_;
        $self->{width} += ( -@{ $self->{pictorials} } + $max );
    }

    sub create {
        my $s          = shift;
        my $w          = ( length $s->{label} ) + 1;
        my @pictorials = @{ $s->{pictorials} };

        $s->{pictorials} = {};
        $s->{x}          = -( $w + $m ) if $s->{x} < 0;
        $s->{rendition}  = urxvt::SET_FGCOLOR $s->{rendition}, 5;    #TODO remove magic number/hard-coded value

        my $labelObj =
            cdmn::visuals::overlay->new( $s->{term}, $s->{x}, $s->{y}, $w, $s->{height}, $s->{rendition}, $s->{label} );

        $labelObj->create("show");
        $s->{label} = $labelObj;

        my $pos = 0;

        $s->{rendition} = urxvt::SET_BGCOLOR $s->{rendition}, $s->{pictorials_bg};
        for my $i (@pictorials) {
            my $x = $s->{x} + $w + $pos++;
            foreach ( &RED, &GREEN, &BLUE, &YELLOW, &WHITE, &PINK ) {
                $s->{rendition} = urxvt::SET_FGCOLOR $s->{rendition}, $_;
                my $pictorial =
                    cdmn::visuals::overlay->new( $s->{term}, $x, $s->{y}, 1, 1, $s->{rendition}, BLOCKS->[0] );
                $pictorial->create;
                $s->{pictorials}{"$i"}{"$_"} = $pictorial;
            }
        }
    }

    sub show {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        for ( values %{ $s->{pictorials} } ) {
            for ( values %{$_} ) {
                $visible ? $_->show : $_->hide;
            }
        }
    }

    sub hide {
        my ($s) = @_;
        $s->show(FALSE);
    }

    sub showLabel {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        $visible ? $s->{label}->show : $s->{label}->hide;
    }

    sub hideLabel {
        my ($s) = @_;
        $s->showLabel(FALSE);
    }

    sub set {
        my ( $s, $i, $usage ) = @_;
        my $barIdx = $usage / 10 * 8 / 10;

        my $color = &getColor($usage);
        for ( values %{ $s->{pictorials}{"$i"} } ) {
            $_->hide;
        }
        if ( $barIdx <= 8 && $barIdx >= 0 ) {
            $s->{pictorials}{"$i"}{"$color"}->show;
            $s->{pictorials}{"$i"}{"$color"}->set( BLOCKS->[$barIdx] );
        }
    }
}

package cdmn::visuals::overlay {
    use fields qw( term x y width height rendition caption );
    use fields qw( overlay );

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        @$s{qw(term x y width height rendition caption)} = @_;
        return $s;
    }

    sub create {
        my ( $s, $show ) = ( shift, shift );
        my ( $x, $y, $w, $h, $r, $c ) = ( $s->{x}, $s->{y}, $s->{width}, $s->{height}, $s->{rendition}, $s->{caption} );

        $s->{overlay} = $s->{term}->overlay( $x, $y, $w, $h, $r, 0 );

        $s->set($c) if defined $c;
        $s->hide if !$show;
    }

    sub set {
        my $s = shift;
        $s->{caption} = shift;
        $s->{overlay}->set( 0, 0, $s->{caption} );    #TODO
        for ( 0 .. $s->{height} ) {
            $s->{overlay}->set( 0, $_, $s->{caption} ) if $s->{height} > 1;    #TODO
        }
    }

    for my $h (qw(hide show)) {
        eval qq{ sub $h { my \$s = shift; \$s->{overlay}->$h; } };             ## no critic
    }
}

use constant {
    CPU     => 'cpu',
    MEMORY  => 'memory',
    NETWORK => 'network',
    DISK    => 'disk',
    REND    => cdmn::constants::REND,
};

use constant XR => cdmn::resources->new();

####################################################
#   UTILITY METHODS
####################################################

sub setCaption {
    my ($s) = (@_);
    my $caption;

    local *addGauges = sub {
        for ( @{ XR->{gauges_order} } ) {
            $_ eq XR->{label_cpu}     and $caption->add( $_, $_[0], XR->{caption_bg} );
            $_ eq XR->{label_disk}    and $caption->add( $_, $_[1], XR->{caption_bg} );
            $_ eq XR->{label_ram}     and $caption->add( $_, $_[2], XR->{caption_bg} );
            $_ eq XR->{label_network} and $caption->add( $_, $_[3], XR->{caption_bg} );
        }
    };

    for ( XR->{caption} ) {
        $caption = do {
            if ($_ eq cdmn::constants::CAPTION_BAR) {
                cdmn::visuals::container->new( $s, REND, XR->{x}, XR->{y}, XR->{padding}, $_, 0, XR->{showing} );
            }
            elsif ($_ eq cdmn::constants::CAPTION_BLOCK) {
                cdmn::visuals::container->new( $s, REND, - 1, XR->{y}, 0, $_, 1, XR->{showing} );
            }
        };
    }

    state $cpus = cdmn::proc::getCpuCount() - 1;

    addGauges( [ map "cpu" . $_, 0 .. $cpus ], XR->{gauges_disks}, ["MemAvailable:"], XR->{gauges_nics} );

    return $caption;
}

####################################################
#   HANDLERS
####################################################

sub user_command {
    my ( $s, $action ) = (@_);

    if ($action eq &cdmn::constants::ACTION_SHOW) {
        my $h = $s->fheight * ( $s->nrow - 1 );
        my $w = $s->width;
        my $x = 0;
        my $y = XR->{y} >= 0 ? $s->fheight : -1;
        if ( $s->{xterms}{main}{maximized} ) {
            $s->{xterms}{main}->bounds( $x, $y + 1, $w + 4, $h + 4 );    #TODO why add 4?
            $s->{xterms}{main}{maximized} = 0;
            $s->{caption}[0]->hide;
        }
        else {
            $s->{xterms}{main}->bounds( 0, 0, $s->width + 4, $s->height + 4 );    #TODO why add 4?
            $s->{xterms}{main}{maximized} = 1;
        }
    }

    if ($action eq &cdmn::constants::ACTION_SHOW_TRANSPARENT) {
        if ( $s->{xterms}{main}{maximized} ) {
            $s->{caption}[0]->{visible} ? $s->{caption}[0]->hide : $s->{caption}[0]->show;
        }
    }

    if ($action eq &cdmn::constants::ACTION_SHOW_SIDEBAR and XR->{showing}) {
        $s->{xterms}{sidebar}->toggle;
    }

    1;
}

sub on_refresh_begin {
    my ($s) = @_;

    if ( $s->{w_sizse} != $s->{term}->ncol ) {
        my $visible_0 = $s->{caption}[0]->{visible};
        my $visible_1 = $s->{caption}[1]->{visible};

        $s->{w_sizse} = $s->{term}->ncol;
        $s->{visuals_updater}->stop;
        $s->{caption}[0] = setCaption $s->{xterms}{main}{term};
        $s->{caption}[1] = setCaption $s;
        $s->{caption}[0]->create;
        $s->{caption}[1]->create;
        $visible_0 ? $s->{caption}[0]->show : $s->{caption}[0]->hide;
        $visible_1 ? $s->{caption}[1]->show : $s->{caption}[1]->hide;
        $s->{visuals_updater}->start;
    }
    1;
}

####################################################
#   TERM HANDLERS
####################################################

sub on_configure_notify {
    my $s = shift;
    my $h = $s->fheight * ( $s->nrow - 1 ) + 4;
    my $w = $s->width;
    my $x = 0;
    my $y = XR->{y} >= 0 ? $s->fheight : -1;

    if ( $s->{xterms}{main}{maximized} ) {
        $s->{xterms}{main}->bounds( 0, 0, $s->width + 4, $s->height + 4 );    #TODO why add 4?
    }
    else {
        $s->{xterms}{main}->bounds( $x, $y + 1, $w + 4, $h );                 #TODO why add 4?
    }
    $s->{xterms}{sidebar}->bounds( $w - $s->fwidth * 35 + 4, 0, $s->fwidth * 35, $s->height + 4 );    #TODO why add 4?
    $s->{xterms}{sidebar}->setContent;
    1;
}

#just to be save
for my $h (qw(key_press key_release)) {
    ## no critic
    eval qq { sub on_$h { 1; } };
}

for my $h (qw(focus_in focus_out)) {
    eval qq{ sub on_$h { (shift)->{xterms}{main}{term}->$h; 1; } };                                   ## no critic
}

sub on_wm_delete_window {
    cdmn::term::destroy_All;
    1;
}

sub on_tt_write {
    (shift)->{xterms}{main}{term}->tt_write(shift);
    1;
}

####################################################
#   MAIN
####################################################

sub on_init {
    my ($s) = @_;

    XR->{label_network}      = $s->x_resource('%.label.network')      // 'NETWORK';
    XR->{label_disk}         = $s->x_resource('%.label.disk')         // 'DISK';
    XR->{label_cpu}          = $s->x_resource('%.label.cpu')          // 'CPU';
    XR->{label_ram}          = $s->x_resource('%.label.ram')          // 'RAM';
    XR->{showing}            = $s->x_resource('%.showing')            // 1;
    XR->{showing_labels}     = $s->x_resource('%.showing.labels')     // 1;
    XR->{showing_background} = $s->x_resource('%.showing.background') // 1;
    XR->{caption}            = $s->x_resource('%.caption')            // 'bar';       #block | bar | solid-bar
    XR->{caption_bg} = $s->x_resource('%.caption-background') // '235';
    XR->{padding}            = $s->x_resource('%.padding')            // 2;           #Padding between visuals
    XR->{x} = $s->x_resource('%.x') // -1;    #positive from left, negativ from right
    XR->{y} = $s->x_resource('%.y') // 0;     #positive from top, negativ from bottom

    my $disks = $s->x_resource('%.gauges.disks') // 'sda';    #Can be a list, e.g. 'a,b,c' or 'a b c'
    $disks = [ split( /[[:punct:],[:space:]]/, $disks ) ];
    XR->{gauges_disks} = cdmn::proc::getDisks;                 #TODO remove this overwrite and make it a tolerant default

    #Can be a list, e.g. 'a,b,c' or 'a b c'
    my $nics = $s->x_resource('%.gauges.nics') // 'eth0_rx,eth0_tx,eth1_rx,eth1_tx';

    #$nics = [ split( /[,[:space:]]/, $nics ) ];
    $nics = [ cdmn::proc->getNics ];                           #TODO remove this overwrite and make it a tolerant default
    XR->{gauges_nics} = $nics;

    my $order = $s->x_resource('%.header-labels') // 'DISK,CPU,RAM,NETWORK';
    $order = [ split( /[[:punct:],[:space:]]/, $order ) ];

    my @order_default;
    for (qw/label_network label_disk label_cpu label_ram/) {
        push( @order_default, XR->{$_} );
    }

    my %gauges = map { $_ => 0 } @order_default;
    while ( my ( $key, $value ) = each @$order ) {
        if (!grep( /^$value$/, @order_default )) {
            splice @$order, $key, $key;
        }
        else { $gauges{$value} = 1 }
    }

    XR->{gauges} = \%gauges;

    ( scalar @$order > 0 ) ? ( XR->{gauges_order} = $order ) : ( XR->{gauges_order} = \@order_default );

    XR->{gauges_background} = $s->x_resource('%.gauges-background') // '5';    #simple | full

    ();
}

sub on_start {
    my ($s) = @_;
    my @argv = $s->argv;

    #TODO maybe just create with 0 and handle everything else in config_notify
    $s->{xterms}{main} = cdmn::term->new(
        $s, XR, 0, XR->{y} >= 0 ? $s->fheight : 0,
        $s->width, $s->fheight * ( $s->nrow - 1 ),
        4, 1, @argv
    );

    $s->{xterms}{main}{maximized} = 1 if XR->{caption} eq cdmn::constants::CAPTION_BAR;
    $s->{xterms}{sidebar} =
        cdmn::term->new( $s, XR, $s->width / 2, 0, $s->width / 2 + 1, $s->fheight * ( $s->nrow ), 5, 0, @argv );
    $s->{xterms}{sidebar}->disableCursor;
    $s->{xterms}{sidebar}->setContent;
    $s->{xterms}{sidebar}->hide;
    $s->{xterms}{main}->show;

    $s->{xterms}{main}->hide if ( XR->{caption} eq cdmn::constants::CAPTION_BLOCK );

    $s->{w_sizse}    = $s->{term}->ncol;
    $s->{caption}[0] = setCaption $s->{xterms}{main}{term};
    $s->{caption}[1] = setCaption $s;
    $s->{caption}[0]->create;
    $s->{caption}[1]->create;

    $s->cmd_parse("\e[1T\e[1B");
    $s->cmd_parse("\e[1T\e[1B");

    $s->cmd_parse("\033[?25l");    #do not show the cursor!
    do { shift @argv; } while @argv && $argv[0] ne "-e";    #urxvt [options] [-e command [ args ]]

    $s->{visuals_updater} = urxvt::timer->new->start( int urxvt::NOW )->interval(1)->cb(
        sub {
            my %r;
            if (XR->{gauges}{ XR->{label_cpu} }) {
                %r = %{&cdmn::proc::getCpuUsage};
                while ( my ( $key, $value ) = each %r ) {
                    $s->{caption}[0]->set( XR->{label_cpu}, $key, $value ) if ( $key =~ /^cpu[0-9]/ );
                    $s->{caption}[1]->set( XR->{label_cpu}, $key, $value ) if ( $key =~ /^cpu[0-9]/ );
                }
            }

            if (XR->{gauges}{ XR->{label_disk} }) {
                %r = %{&cdmn::proc::getDiskUsage};
                foreach ( @{ XR->{gauges_disks} } ) {
                    $s->{caption}[0]->set( XR->{label_disk}, $_, $r{$_} );
                    $s->{caption}[1]->set( XR->{label_disk}, $_, $r{$_} );
                }
            }

            if (XR->{gauges}{ XR->{label_ram} }) {
                %r = %{&cdmn::proc::getMemoryUsage};
                while ( my ( $key, $value ) = each %r ) {
                    $_->set( XR->{label_ram}, $key, $value ) foreach @{ $s->{caption} };
                }
            }

            if (XR->{gauges}{ XR->{label_network} }) {
                %r = %{ &cdmn::proc::getNetworkUsage("rx_bytes") };
                while ( my ( $key, $value ) = each %r ) {
                    $_->set( XR->{label_network}, $key, $value ) foreach @{ $s->{caption} };
                }

                %r = %{ &cdmn::proc::getNetworkUsage("tx_bytes") };
                while ( my ( $key, $value ) = each %r ) {
                    $_->set( XR->{label_network}, $key, $value ) foreach @{ $s->{caption} };
                }
            }
        }
    );

    ();
}

