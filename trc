#!/usr/bin/perl

# TopRightCorner (TRC) is an extension written for urxvt that shows
# utilizations of different system resoureces like cpu, disk i/o, ram,
# network (and more).

# Copyright (C) 2016 Marcel Lautenbach
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


use strict;
use warnings FATAL => 'all';
use autodie;
use 5.22.2;
use List::Util qw(sum);
use autodie;
use utf8;

use open ':std', ':encoding(UTF-8)';

my $G_rend = urxvt::OVERLAY_RSTYLE;
$G_rend = urxvt::SET_BGCOLOR $G_rend, 1;
$G_rend = urxvt::SET_FGCOLOR $G_rend, 255;

#$rend = $rend | urxvt::RS_Bold;

my $G_speed = `curl -s "http://fritz.box:49000/igd2upnp/control/WANCommonIFC1" -H "Content-Type: text/xml; charset="utf-8"" -H "SoapAction:urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1#GetCommonLinkProperties" -d '<?xml version="1.0" encoding="utf-8"?><s:Envelope s:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" xmlns:s="http://schemas.xmlsoap.org/soap/envelope/"><s:Body><u:GetCommonLinkProperties xmlns:u="urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1" /></s:Body></s:Envelope>'`;
$G_speed =~ /.*(NewLayer1DownstreamMaxBitRate)>([0-9]+)/;
$G_speed = $2 / 8;


use constant {
    RED => 3,
    GREEN => 4,
    PINK => 7,
    YELLOW => 5,
    BLUE => 6,
    WHITE => 248,
};

use constant {
    STAT => '/proc/stat',
    DISKSTATS => '/proc/diskstats',
    MEMINFO => '/proc/meminfo',
    RX_BYTES => '/sys/class/net/eth0/statistics/rx_bytes',
};

use constant {
    CPU => 'cpu',
    MEMORY => 'memory',
    NETWORK => 'network',
    DISK => 'disk',
};

use constant {GAUGE => '▪'};

use constant BLOCKS => [ qw/_ ▁ ▂ ▃ ▄ ▅ ▆ ▇ █/ ];


####################################################
#   UTILITY METHODS
####################################################

sub getColor {
    for(shift){
        return RED if $_ > 80;
        return YELLOW if $_ > 60;
        return BLUE if $_ > 40;
        return GREEN if $_ > 20;
    }
    WHITE;
}


####################################################
#   GUI / OVERLAY
####################################################

sub createHeader {
    my ($self, $label, $xOff, $count, $padding) = @_;
    $self = ${$self};

    my $w = (length $self->{LABELS}->{$label}) + 2;

    my $r = urxvt::SET_FGCOLOR $G_rend, 5;
    #  $r = urxvt::SET_BGCOLOR $r, 19;

    my %label = (
        "overlay" => $self->overlay( $xOff, 0, $w, 1, $r, 0 ),
        "x"       => 0,
        "y"       => 0,
        "with"    => $w,
        "height"  => 1,
    );

    my $with = 1;
    for (my $pos =0; $pos<$count; $pos++) {
        my $x = $xOff+$w+$pos;
        $with += $padding if ($pos == $count-1);

        my %gauge = (
            "overlay" => $self->overlay( $x, 0, $with, 1, $r, 0 ),
            "x"       => $x,
            "y"       => 0,
            "with"    => $with,
            "height"  => 1,
        );
        $gauge{overlay}->show;
        $self->{GAUGES}->{$label}[$pos] = \%gauge;
    }

    my %properties = (
        "label" => \%label,
        "gauges" => $self->{GAUGES}->{$label},
    );

    $label{overlay}->set ( 0, 0, $self->{LABELS}->{$label} );
    $label{overlay}->show;

    $self->{header}->{$self->{LABELS}->{$label}} = \%properties;

    return $xOff+$w+$count+$padding;
};

sub createOverlay {
    my($self, $designation, $rend, $diff_usage, $y) = @_;
    $self = ${$self};

    my $len = length $self->{LABELS}->{$designation};

    $rend = urxvt::SET_FGCOLOR $rend, getColor( $diff_usage );
    $self->{overlays}->{$designation."Label"} = $self->overlay ( -($len + 2), $y, $len, 1, $rend, 0 );
    $self->{overlays}->{$designation."Label"}->set ( 0, 0, $self->{LABELS}->{$designation} );
    ( $self->{SHOWING_LABELS} and $self->{SHOWING} )? $self->{overlays}->{$designation."Label"}->show : $self->{overlays}->{$designation."Label"}->hide;

    $self->{overlays}->{$designation} = $self->overlay ( -1, $y, 1, 1, $rend, 0 );
    $self->{overlays}->{$designation}->set ( 0, 0, GAUGE );
    $self->{SHOWING} ? $self->{overlays}->{$designation}->show : $self->{overlays}->{$designation}->hide;
};

sub createHeaderOverlay {
    my($self, $designation, $rend, $diff_usage, $label, $x) = @_;
    $self = ${$self};

    my $usage = $diff_usage / 10 * 9 / 10;

    $self->{header}->{$label}->{gauges}[$x]->{overlay}->set ( 0, 0, BLOCKS->[$usage] ) if $usage < 10;

    my $d = @{$self->{HEADER_LABELS}}[-1];
    my $xx = $self->{header}->{$d}->{gauges}[-1]->{x};

    my $rend2 = urxvt::OVERLAY_RSTYLE;
    $rend2 = urxvt::SET_FGCOLOR $rend2, 5;
    $rend2 = urxvt::SET_BGCOLOR $rend2, 1;
    $rend2 = $rend2 | urxvt::RS_Bold;

    $self->{overlays}->{x2} = $self->overlay( $xx, 0, $self->ncol-$xx-1, 1, $rend2, 0 );
    $self->{overlays}->{x2}->show;
    # $self->{overlays}->{x3} = $self->overlay( 0, 1, $self->ncol, 1, $rend2, 0 );
    # $self->{overlays}->{x3}->set ( 0, 0, "─"x$self->ncol );
    # $self->{overlays}->{x3}->show;
};


####################################################
#   DATA
####################################################

sub getCpuUsage {
    my ($self) = @_;
    $self = ${$self};

    my $diff_usage = 0;
    my $count = 0;

    open( my $f, '<', STAT );
    while (<$f>) {
        if (! /^cpu[0-9]*\s+[0-9]+/) {
            next;
        }

        my @cpu = split /\s+/;
        my $cpu = shift @cpu;

        $self->{$cpu}{prev_idle} = $self->{$cpu}{prev_idle} // 0;
        $self->{$cpu}{prev_total} = $self->{$cpu}{prev_total} // 0;
        $self->{$cpu}{diff_total} = $self->{$cpu}{diff_total} // 0;

        my $idle = $cpu[3];
        my $total = sum( @cpu );

        my $diff_idle = $idle - $self->{$cpu}{prev_idle};
        if ($total != $self->{$cpu}{prev_total}) {
            $self->{$cpu}{diff_total} = $total - $self->{$cpu}{prev_total};
        }
        $diff_usage = 100 * ($self->{$cpu}{diff_total} - $diff_idle) / $self->{$cpu}{diff_total};

        $self->{$cpu}{prev_idle} = $idle;
        $self->{$cpu}{prev_total} = $total;

        if ($cpu =~ /^cpu$/) {
            $self->{createOverlay}(\$self, $cpu, $G_rend, $diff_usage, 0);
        }

        if ($cpu =~ /^cpu[0-9]+/) {
            $self->{createHeaderOverlay}(\$self, $cpu, $G_rend, $diff_usage, $self->{LABELS}->{&CPU}, $count++);
        }
    }
};

sub getDiskUsage {
    my ($self) = @_;
    $self = ${$self};

    my $diff_usage;
    my $count = 0;

    open( my $f, '<', DISKSTATS );
    while (<$f>) {
        if (! /\bsd(a|b|c)\b/) {
            next;
        }
        my @sda = split /\s+/, $_;
        shift @sda;
        shift @sda;
        shift @sda;

        $self->{$sda[0]}{prev_sda} = $self->{$sda[0]}{prev_sda} // 0;

        my $diff_sda = $sda[10] - $self->{$sda[0]}{prev_sda};
        $diff_usage = $diff_sda / 10;

        $self->{$sda[0]}{prev_sda} = $sda[10];
        $self->{createHeaderOverlay}(\$self, $sda[0], $G_rend, $diff_usage, $self->{LABELS}->{&DISK}, $count++);
    }

    $self->{createOverlay}(\$self, &DISK, $G_rend, $diff_usage, 1);
};

sub getMemoryUsage {
    my ($self) = @_;
    $self = ${$self};

    my @sda;
    my $total = 0;
    my $available = 0;

    open( my $f, '<', MEMINFO );
    while (<$f>) {
        if (/^MemTotal:\s+[0-9]+/) {
            @sda = split /\s+/, $_;
            $total = $sda[1];
        }
        if (/^MemAvailable:\s+[0-9]+/) {
            @sda = split /\s+/, $_;
            $available = $sda[1];
        }
    }

    my $diff_usage = 100 - (100 * $available / $total);

    $self->{createHeaderOverlay}(\$self, $sda[0], $G_rend, $diff_usage, $self->{LABELS}->{&MEMORY}, 0);
    $self->{createOverlay}(\$self, &MEMORY, $G_rend, $diff_usage, 2);
};

sub getNetworkUsage {
    my ($self) = @_;
    $self = ${$self};

    my $rx_bytes = 0;
    state $prev_rx = 0;

    open( my $f, '<', RX_BYTES );
    {
        local $/;
        $rx_bytes = <$f>;
    }

    my $diff_rx = $rx_bytes - $prev_rx;
    my $diff_usage = 100 * $diff_rx / $G_speed;

    $prev_rx = $rx_bytes;

    $self->{createOverlay}(\$self, &NETWORK, $G_rend, $diff_usage, 3);
    $self->{createHeaderOverlay}(\$self, "net", $G_rend, $diff_usage, $self->{LABELS}->{&NETWORK}, 0);


    #open(STAT, '/sys/class/net/eth0/speed');
    #{
    #    local $/;
    #    $speed = <STAT>;
    #    $speed = 11 * 1000000 / 8
    #}
    #close STAT;
};


####################################################
#   HANDLERS
####################################################

sub on_init {
    my ($self) = @_;

    my $hotkey = $self->x_resource ("%") || "M-n";
    $self->bind_action ($hotkey, "%:show") or warn "unable to register '$hotkey' as hotkey\n";

    $hotkey = $self->x_resource ("%") || "M-l";
    $self->bind_action ($hotkey, "%:show-labels") or warn "unable to register '$hotkey' as hotkey\n";

    ()
}

sub on_action {
    my ($self, $action) = @_;

    if ( $action eq "show") {
        $self->{SHOWING} = !$self->{SHOWING};
        while ( my($key, $value) = each(%{$self->{overlays}}) ) {
            $value->show if $key !~ /label/i and $self->{SHOWING};
            $value->hide if ! $self->{SHOWING};
            $value->show if $key =~ /label/i and $self->{SHOWING_LABELS} and $self->{SHOWING};
        }
    }

    if ( $action eq "show-labels" and $self->{SHOWING}) {
        $self->{SHOWING_LABELS} = !$self->{SHOWING_LABELS};
        while ( my($key, $value) = each(%{$self->{overlays}}) ) {
            $value->show if $key =~ /label/i and $self->{SHOWING_LABELS};
            $value->hide if $key =~ /label/i and ! $self->{SHOWING_LABELS} ;
        }
    }
    ()
}

sub on_refresh_begin {
    my ($self) = @_;

    my $empty = 1;

    for(my $i = 1; $i < $self->nrow; $i++) {
        $empty = 0 if $self->ROW_t($i) !~ /^\s*$/;
    }

    if ($self->ROW_t(0) !~ /^\s*$/ and $empty ) {
        #if ($self->ROW_t(0) =~ /.*d/){
        $self->cmd_parse("\e[1T\e[1B");
        #$self->view_start(-1);
    }
}

sub on_start {
    my ($self) = @_;

    # $visibility{"cpu"} = true if ($self->x_resource('trc.cpu'));
    # $visibility{"disk"} = true if ($self->x_resource('trc.disk'));
    #$visibility{"ram"} = true if ($self->x_resource('trc.ram'));
    # $visibility{"network"} = true if ($self->x_resource('trc.network'));

    #$colors{"network"} = true if ($self->x_resource('trc.color.1'));
    #$colors{"network"} = true if ($self->x_resource('trc.color.2'));
    #$colors{"network"} = true if ($self->x_resource('trc.color.3'));
    #$colors{"network"} = true if ($self->x_resource('trc.color.5'));

    $self->{LABELS}->{&NETWORK} = $self->x_resource('%.label.network') // 'NETWORK';
    $self->{LABELS}->{&DISK} = $self->x_resource('%.label.disk') // 'DISK';
    $self->{LABELS}->{&CPU} = $self->x_resource('%.label.cpu') // 'CPU';
    $self->{LABELS}->{&MEMORY} = $self->x_resource('%.label.ram') // 'RAM';

    $self->{SHOWING} = $self->x_resource_boolean('%.showing') // 1;
    $self->{SHOWING_LABELS} = $self->x_resource_boolean('%.showing-labels') // 0;

    $self->{HEADER_LABELS} = $self->x_resource('%.header-labels') // 'CPU,DISK,RAM,NETWORK';
    $self->{HEADER_LABELS} = [split(/[[:punct:],[:space:]]/, $self->{HEADER_LABELS})];

    my @h = @{$self->{HEADER_LABELS}};
    my @v = (values %{$self->{LABELS}});
    foreach my $value (@h) {
        if(! grep {$_ eq $value} @v or $#v != $#h) {
            $self->{HEADER_LABELS} = [qw(CPU DISK RAM NETWORK)];
            last;
        }
    }

    for (keys  %{$self->{LABELS}}) {
        $self->{GAUGES}->{$self->{LABELS}->{$_}} = [];
    }

    $self->{createTimer} = \&createTimer;
    $self->{createHeader} = \&createHeader;
    $self->{createOverlay} = \&createOverlay;
    $self->{createHeaderOverlay} = \&createHeaderOverlay;

    $self->{"sub_".&CPU} = sub { getCpuUsage \$self };
    $self->{"sub_".&DISK} = sub { getDiskUsage \$self };
    $self->{"sub_".&MEMORY} = sub { getMemoryUsage \$self };
    $self->{"sub_".&NETWORK} = sub { getNetworkUsage \$self };

    my @stats = (CPU, DISK, MEMORY, NETWORK);
    foreach (@stats) {
        $self->{createTimer}(\$self, $_);
    }

    my @stats2 = (CPU, DISK, MEMORY, NETWORK);
    my $xOff = 0;
    foreach (@stats2) {
        $xOff = $self->{createHeader}(\$self, $_, $xOff, 4, 3);
    }

    # $self->{createHeaderOverlay}();
    ()
}


####################################################
#   MAIN
####################################################

sub createTimer {
    my $self = shift;
    $self = ${$self};

    my $p = shift;
    $self->{$p} = urxvt::timer
        ->new
        ->start ( 1 + int urxvt::NOW )
        ->interval ( 1 )
        ->cb ( $self->{"sub_$p"} );
};
