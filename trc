#!/usr/bin/perl

# TopRightCorner (TRC) is an extension written for urxvt that shows
# utilizations of different system resoureces like cpu, disk i/o, ram,
# network (and more).

# Copyright (C) 2016 Marcel Lautenbach
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use 5.24.1;
use strict;
use warnings FATAL => 'all';
use utf8;

package trc::proc {
    use List::Util qw(sum max min);

    my $NETSPEED =
`curl -s "http://fritz.box:49000/igd2upnp/control/WANCommonIFC1" -H "Content-Type: text/xml; charset="utf-8"" -H "SoapAction:urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1#GetCommonLinkProperties" -d '<?xml version="1.0" encoding="utf-8"?><s:Envelope s:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" xmlns:s="http://schemas.xmlsoap.org/soap/envelope/"><s:Body><u:GetCommonLinkProperties xmlns:u="urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1" /></s:Body></s:Envelope>'`;
    $NETSPEED =~ /.*(NewLayer1DownstreamMaxBitRate)>([0-9]+)/;
    $NETSPEED = $2 / 8;

    use constant {
        PARTITIONS  => '/proc/partitions',
        MOUNTS      => '/proc/mounts',
        STAT        => '/proc/stat',
        DISKSTATS   => '/proc/diskstats',
        MEMINFO     => '/proc/meminfo',
        RX_BYTES    => '/sys/class/net/eth0/statistics/rx_bytes',    #TODO
        CPU_PRESENT => '/sys/devices/system/cpu/present',
    };

    sub getMounts {
        open( my $f, '<', MOUNTS );
        my @a;
        my %a;
        while (<$f>) {
            push @a, /(^\/dev\S*)\s+([a-zA-Z-_\/]+)/;                #TODO this regex is too simple
            %a = (@a);
        }
        return %a;
    }

    sub getDisks {
        open( my $f, '<', PARTITIONS );
        my @a;
        while (<$f>) {
            push @a, /(sd[a-z]$)/;
        }

        return \@a;
    }

    sub getCpuUsage {
        state %cpus;
        my $diff_usage = 0;
        my %results;

        open( my $f, '<', STAT );
        while (<$f>) {
            if ( !/^cpu[0-9]*\s+[0-9]+/ ) {
                next;
            }

            my @cpu = split /\s+/;
            my $cpu = shift @cpu;

            $cpus{$cpu} = {} if !defined $cpus{$cpu};

            $cpus{$cpu}{prev_idle}  = $cpus{$cpu}{prev_idle}  // 0;
            $cpus{$cpu}{prev_total} = $cpus{$cpu}{prev_total} // 0;
            $cpus{$cpu}{diff_total} = $cpus{$cpu}{diff_total} // 0;

            my $idle  = $cpu[3];
            my $total = sum(@cpu);

            my $diff_idle = $idle - $cpus{$cpu}{prev_idle};
            if ( $total != $cpus{$cpu}{prev_total} ) {
                $cpus{$cpu}{diff_total} = $total - $cpus{$cpu}{prev_total};
            }
            $diff_usage = 100 * ( $cpus{$cpu}{diff_total} - $diff_idle ) / $cpus{$cpu}{diff_total};

            $cpus{$cpu}{prev_idle}  = $idle;
            $cpus{$cpu}{prev_total} = $total;

            $results{$cpu} = $diff_usage;
        }
        return \%results;
    }

    sub getCpuCount {
        open( my $f, '<', CPU_PRESENT );
        {
            local $/;
            my $cpus = <$f>;
            $cpus =~ /-([0-9]+)/;
            return $1 + 1;
        }
    }

    sub getDiskUsage {

        state %sda;
        my $diff_usage;
        my %results;

        open( my $f, '<', DISKSTATS );
        while (<$f>) {
            if ( !/\bsd(a|b|c)\b/ ) {
                next;
            }
            my @sda = split /\s+/, $_;
            shift @sda;
            shift @sda;
            shift @sda;

            $sda{ $sda[0] } = $sda{ $sda[0] } // 0;

            my $diff_sda = $sda[10] - $sda{ $sda[0] };
            $diff_usage = $diff_sda / 10;

            $sda{ $sda[0] }     = $sda[10];
            $results{ $sda[0] } = $diff_usage;
        }
        return \%results;
    }

    sub getMemoryUsage {
        my @sda;
        my $total     = 0;
        my $available = 0;
        my %results;

        open( my $f, '<', MEMINFO );
        while (<$f>) {
            if (/^MemTotal:\s+[0-9]+/) {
                @sda = split /\s+/, $_;
                $total = $sda[1];
            }
            if (/^MemAvailable:\s+[0-9]+/) {
                @sda = split /\s+/, $_;
                $available = $sda[1];
            }
        }

        $results{ $sda[0] } = 100 - ( 100 * $available / $total );
        return \%results;
    }

    sub getNetworkUsage {
        my $rx_bytes = 0;
        state $prev_rx = 0;

        open( my $f, '<', RX_BYTES );
        {
            local $/;
            $rx_bytes = <$f>;
        }

        my $diff_rx    = $rx_bytes - $prev_rx;
        my $diff_usage = 100 * $diff_rx / $NETSPEED;

        $prev_rx = $rx_bytes;

        return { "eth0", $diff_usage };

        #open(STAT, '/sys/class/net/eth0/speed');
        #{
        #    local $/;
        #    $speed = <STAT>;
        #    $speed = 11 * 1000000 / 8
        #}
        #close STAT;
    }
}

package trc::constants {
    use constant {
        ACTION_SHOW             => 'trc:show',
        ACTION_SHOW_LABELS      => 'trc:show-labels',
        ACTION_SHOW_SIDEBAR     => 'trc:show-sidebar',
        ACTION_SHOW_TRANSPARENT => 'trc:action-show-transparent',
    };

    use constant {
        CAPTION_BLOCK     => 'block',
        CAPTION_BAR       => 'bar',
        CAPTION_SOLID_BAR => 'solid-bar',
    };

    use constant REND => urxvt::SET_COLOR urxvt::OVERLAY_RSTYLE, 255, 1;
}

package trc::resources {
    use fields qw(
      x  y  padding
      showing  showing_labels  showing_background
      caption  caption_background
      label_network  label_disk  label_cpu  label_ram
      gauges  gauges_disks  gauges_nics  gauges_order  gauges_background
      actions
    );



    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        return $s;
    }
}

package trc::term {
    use fields qw(x y w h term parent bg_color content is_root resource maximized);
    use Filesys::Df;
    use POSIX qw(ceil floor);

    use constant { REND => trc::constants::REND, };

    my @terminals;
    my $root;
    my @data;

    sub new {
        my $s = shift;

        $s = fields::new($s) unless ref $s;

        $s->{parent} = shift;
        @$s{qw/resource x y w h bg_color is_root/} = (@_);

        # save a backlink to us, make sure tabbed is inactive
        push @urxvt::TERM_INIT, sub {
            my ($term) = @_;
            $term->{termclass} = $s;
            $term->{parent} = $s->{parent} if $s->{is_root};
            $term->resource( perl_ext_2 => "-trc" );    #TODO
        };

        push @urxvt::TERM_EXT, __PACKAGE__;

        my $environ = $s->{parent}->env;
        $environ->{SHELL} = 'sh' if !$s->{is_root};

        $s->{term} = new urxvt::term( $environ, $urxvt::RXVTNAME, -embed => $s->{parent}->parent, -depth => 32 );
        $s->bounds( @$s{qw/x y w h/} );
        $s->{is_root} ? $root = $s : push( @terminals, $s );

        return $s;
    }

    sub on_user_command {

        #my ($s, $a) = ($_[0], $_[1] =~ /([a-zA-Z-]*$)/);
        my $s = shift;
        $s->{term}->{termclass}->{parent}->user_command(@_);
        1;
    }

    sub on_init {
        my $s = shift;
        $s->bind_action( 'M-h', 'perl:' . &trc::constants::ACTION_SHOW );
        $s->bind_action( 'M-l', 'perl:' . &trc::constants::ACTION_SHOW_SIDEBAR );
        $s->bind_action( 'M-o', 'perl:' . &trc::constants::ACTION_SHOW_TRANSPARENT );
    }

    sub on_tt_write {
        my $s = shift;
        if ( !$s->{term}->{parent} ) {
            $root->{term}->tt_write(shift);
            return 1;
        }
        ();
    }

    sub on_refresh_begin {
        my $s = shift;
        if ( !$s->{term}->{parent} ) {
            my $str = $s->{term}->locale_encode("\e[0;0H\e[K");
            $s->{term}->cmd_parse($str);    #do not show the cursor!
            return 1;
        }
    }

    sub bounds {
        my $s = shift;
        @$s{qw/x y w h/} = @_;
        $s->{term}->XMoveResizeWindow( $s->{term}->parent, @_ );
    }

    sub on_destroy {
        if ( $_[0]{term}{parent} ) {
            $_[0]{term}{parent}{caption}[0]->hide;    #prevent segmentation fauls!
            $_->{term}->destroy for @terminals;
            my $p = $_[0]{term}{parent} or return;    #TODO get to understand it!
            $p->{d} = urxvt::iw->new->start->cb( sub { $p->destroy } );
        }
        1;
    }

    sub destroy_All {
        $root->{term}->destroy;
    }

    sub disableCursor {
        (shift)->{term}->cmd_parse("\033[?25l");      #do not show the cursor!
    }

    sub setContent {
        my $s      = shift;
        my %mounts = trc::proc::getMounts;

        my $r = urxvt::SET_FGCOLOR REND, 240;         #TODO

        $data[0] = trc::visuals::overlay->new( $s->{term}, 0, 0, 1, $root->{parent}->nrow, $r, "│" );
        $r = urxvt::SET_FGCOLOR REND, 250;            #TODO
        $r = $r | urxvt::RS_Uline;

        my $i = 1;
        push @data, trc::visuals::overlay->new( $s->{term}, -1, $i++, 32, 1, $r, 'FS USAGE' );
        $r = urxvt::SET_FGCOLOR REND, 250;
        for ( keys %mounts ) {
            my $ref = df( $mounts{$_} );
            my $u   = ceil( 25 * $ref->{per} / 100 );
            my $f   = floor( 25 - 25 * $ref->{per} / 100 );

            $i++;
            push @data, trc::visuals::overlay->new( $s->{term}, -1, $i++, 32, 1, $r, $mounts{$_} );
            push @data,
              trc::visuals::overlay->new( $s->{term}, -1, $i++, 32, 1, $r, "■" x $u . "□" x $f . " $ref->{per}%" );
        }

        for ( my $j = 1 ; $j < @data ; $j++ ) {
            $data[$j]->create("show");
        }
        $data[0]->create("show");
    }

    sub hide {
        my $s = shift;
        $s->{term}->XUnmapWindow( $s->{term}->parent );
    }

    sub show {
        my $s = shift;
        $s->{term}->XMapWindow( $s->{term}->parent );
    }

    sub toggle {
        my $s = shift;
        $s->{term}->mapped ? $s->hide : $s->show;
    }
}

package trc::visuals::container {
    use fields qw(
      term rendition padding align evenGauges x y
      sprites visible bg type
    );

    use constant {
        TRUE          => 1,
        FALSE         => 0,
        CAPTION_BAR   => trc::constants::CAPTION_BAR,
        CAPTION_BLOCK => trc::constants::CAPTION_BLOCK,
        REND          => trc::constants::REND,
    };

    my ( $xOff, $yOff, $m ) = ( 0, 0, 0 );

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        @$s{qw/term rendition x y padding align evenGauges visible/} = @_;
        ( $xOff, $yOff ) = ( 0, $s->{y} );
        return $s;
    }

    #TODO no Reference for visuals?
    sub add {
        my ( $s, $label, $visuals, $captbg ) = @_;
        my $visual = trc::visuals::visual->new( $s->{term}, $s->{rendition}, $xOff, $yOff, $label, $visuals, $captbg );

        $s->{sprites}->{$label} = $visual;
        if ( @{$visuals} > $m && $s->{evenGauges} ) {
            $m = @{$visuals};
            foreach ( values %{ $s->{sprites} } ) {
                $_->setEvenGauges($m);
                $xOff += $visual->{width} if $s->{align} eq CAPTION_BAR;
            }
        }
        $visual->setEvenGauges($m) if $s->{evenGauges};
        $xOff += $visual->{width} + $s->{padding}  if $s->{align} eq CAPTION_BAR;
        $yOff += $visual->{height} + $s->{padding} if $s->{align} eq CAPTION_BLOCK;
    }

    sub create {
        my $s = shift;

        if ( $s->{x} < 0 ) {
            for ( $s->{align} ) {
                if ( $_ eq CAPTION_BAR ) {
                    $_->{x} = $s->{term}->ncol - $xOff + $_->{x} + $s->{x} + $s->{padding} + 1
                      foreach ( values %{ $s->{sprites} } );
                }
                if ( $_ eq CAPTION_BLOCK ) {
                    $_->{x} = $s->{term}->ncol - $_->{x} - $_->{width} + $s->{x} foreach ( values %{ $s->{sprites} } );
                }
            }
        }
        else {
            $_->{x} += $s->{x} foreach values %{ $s->{sprites} };
        }
        $_->create foreach values %{ $s->{sprites} };

        #Background
        #for ( $s->{align} ) {
        #    if ( $_ eq CAPTION_BAR ) {
        #        $s->{bg} = trc::visuals::overlay->new( $s->{term}, 0, 0, $s->{term}->ncol, 1, REND );
        #        $s->{bg}->create("show");
        #        $s->{type} = CAPTION_BAR;
        #    }
        #    if ( $_ eq CAPTION_BLOCK ) {
        #        $s->{type} = CAPTION_BLOCK;
        #    }
        #}
    }

    sub set {
        my ( $s, $label, $i, $usage ) = (@_);
        if ( $s->{visible} ) {
            $s->{sprites}->{$label}->set( $i, $usage );
        }
    }

    sub setColor {
        my ( $s, $label, $i, $usage ) = @_;
        $s->{sprites}->{$label}->setColor( $i, $usage );
    }

    sub show {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        foreach ( values %{ $s->{sprites} } ) {
            $visible ? $_->show : $_->hide;
        }
        $visible ? $s->showLabels : $s->hideLabels;

        #$visible ? $s->showBackground : $s->hideBackground;
        $s->{visible} = $visible;
    }

    sub hide {
        my ($s) = @_;
        $s->show(FALSE);
    }

    sub toggle {
        my $s = shift;
        $s->{visible} ? $s->hide : $s->show;
    }

    sub showLabels {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        foreach ( values %{ $s->{sprites} } ) {
            $visible ? $_->showLabel : $_->hideLabel;
        }

        #$s->refreshBackground;
        #$s->{labelVisible} = $visible;
    }

    sub hideLabels {
        my ($s) = @_;
        $s->showLabels(FALSE);
    }

    #sub showBackground {
    #    my ( $s, $visible ) = @_;
    #    $visible = $visible // 1;
    #    if ( $s->{type} eq $s->{term}->CAPTION_BAR ) {
    #        $visible ? $s->{bg}->show : $s->{bg}->hide;
    #        $s->{backgroundVisible} = $visible;
    #    }
    #}
    #
    #sub refreshBackground {
    #    my ($s) = @_;
    #    if ( $s->{backgroundVisible} ) {
    #        $s->hideBackground;
    #        $s->showBackground;
    #    }
    #}
    #
    #sub hideBackground {
    #    my ($s) = @_;
    #    $s->showBackground(FALSE);
    #}
}

package trc::visuals::visual {
    use List::Util qw(max);

    use fields qw(
      term rendition x y label pictorials pictorials_bg
      count width height );

    use constant BLOCKS => [qw/_ ▁ ▂ ▃ ▄ ▅ ▆ ▇ █/];
    use constant { TRUE => 1, FALSE => 0 };
    use constant {
        RED    => 3,
        GREEN  => 4,
        PINK   => 7,
        YELLOW => 5,
        BLUE   => 6,
        WHITE  => 248,
    };

    my $m = 0;

    sub getColor {
        for (shift) {
            return RED    if $_ > 80;
            return YELLOW if $_ > 60;
            return BLUE   if $_ > 40;
            return GREEN  if $_ > 20;
        }
        WHITE;
    }

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        @$s{qw/term rendition x y label pictorials pictorials_bg/} = @_;

        $s->{width}  = ( length $s->{label} ) + 1 + @{ $s->{pictorials} };
        $s->{height} = 1;
        return $s;
    }

    sub setEvenGauges {
        my ( $self, $max ) = @_;
        $self->{width} += ( -@{ $self->{pictorials} } + $max );
    }

    sub create {
        my $s          = shift;
        my $w          = ( length $s->{label} ) + 1;
        my @pictorials = @{ $s->{pictorials} };

        $s->{pictorials} = {};
        $s->{x}          = -( $w + $m ) if $s->{x} < 0;
        $s->{rendition}  = urxvt::SET_FGCOLOR $s->{rendition}, 5;    #TODO

        my $labelObj =
          trc::visuals::overlay->new( $s->{term}, $s->{x}, $s->{y}, $w, $s->{height}, $s->{rendition}, $s->{label} );

        $labelObj->create("show");
        $s->{label} = $labelObj;

        my $pos = 0;

        $s->{rendition} = urxvt::SET_BGCOLOR $s->{rendition}, $s->{pictorials_bg};
        for my $i (@pictorials) {
            my $x = $s->{x} + $w + $pos++;
            foreach ( &RED, &GREEN, &BLUE, &YELLOW, &WHITE, &PINK ) {
                $s->{rendition} = urxvt::SET_FGCOLOR $s->{rendition}, $_;
                my $pictorial =
                  trc::visuals::overlay->new( $s->{term}, $x, $s->{y}, 1, 1, $s->{rendition}, BLOCKS->[0] );
                $pictorial->create;
                $s->{pictorials}{"$i"}{"$_"} = $pictorial;
            }
        }
    }

    sub show {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        for ( values %{ $s->{pictorials} } ) {
            for ( values %{$_} ) {
                $visible ? $_->show : $_->hide;
            }
        }
    }

    sub hide {
        my ($s) = @_;
        $s->show(FALSE);
    }

    sub showLabel {
        my ( $s, $visible ) = @_;
        $visible = $visible // 1;
        $visible ? $s->{label}->show : $s->{label}->hide;
    }

    sub hideLabel {
        my ($s) = @_;
        $s->showLabel(FALSE);
    }

    sub set {
        my ( $s, $i, $usage ) = @_;
        my $barIdx = $usage / 10 * 8 / 10;

        my $color = &getColor($usage);
        for ( values %{ $s->{pictorials}{"$i"} } ) {
            $_->hide;
        }
        if ( $barIdx <= 8 && $barIdx >= 0 ) {
            $s->{pictorials}{"$i"}{"$color"}->show;
            $s->{pictorials}{"$i"}{"$color"}->set( BLOCKS->[$barIdx] );
        }
    }
}

package trc::visuals::overlay {
    use fields qw(
      term x y
      width height
      rendition caption

      overlay
    );

    sub new {
        my $s = shift;
        $s = fields::new($s) unless ref $s;

        @$s{qw(term x y width height rendition caption)} = @_;
        return $s;
    }

    sub create {
        my ( $s, $show ) = ( shift, shift );
        my ( $x, $y, $w, $h, $r, $c ) = ( $s->{x}, $s->{y}, $s->{width}, $s->{height}, $s->{rendition}, $s->{caption} );

        $s->{overlay} = $s->{term}->overlay( $x, $y, $w, $h, $r, 0 );

        $s->set($c) if defined $c;
        $s->hide if !$show;
    }

    sub set {
        my $s = shift;
        $s->{caption} = shift;
        $s->{overlay}->set( 0, 0, $s->{caption} );    #TODO
        for ( 0 .. $s->{height} ) {
            $s->{overlay}->set( 0, $_, $s->{caption} ) if $s->{height} > 1;    #TODO
        }
    }

    for my $h (qw(hide show)) {
        eval qq{ sub $h { my \$s = shift; \$s->{overlay}->$h; } };             ## no critic
    }
}

use constant {
    CPU     => 'cpu',
    MEMORY  => 'memory',
    NETWORK => 'network',
    DISK    => 'disk',
    REND    => trc::constants::REND,
};

use constant XR => trc::resources->new();

####################################################
#   UTILITY METHODS
####################################################

sub setCaption {
    my ($s) = (@_);
    my $caption;

    local *addGauges = sub {
        for ( @{ XR->{gauges_order} } ) {
            $_ eq XR->{label_cpu}     and $caption->add( $_, $_[0], XR->{caption_background} );
            $_ eq XR->{label_disk}    and $caption->add( $_, $_[1], XR->{caption_background} );
            $_ eq XR->{label_ram}     and $caption->add( $_, $_[2], XR->{caption_background} );
            $_ eq XR->{label_network} and $caption->add( $_, $_[3], XR->{caption_background} );
        }
    };

    for ( XR->{caption} ) {
        $caption = do {
            if ( $_ eq trc::constants::CAPTION_BAR ) {
                trc::visuals::container->new( $s, REND, XR->{x}, XR->{y}, XR->{padding}, $_, 0, XR->{showing} );
            }
            elsif ( $_ eq trc::constants::CAPTION_BLOCK ) {
                trc::visuals::container->new( $s, REND, -1, XR->{y}, 0, $_, 1, XR->{showing} );
            }
        };
    }

    state $cpus = trc::proc::getCpuCount() - 1;

    addGauges( [ map "cpu" . $_, 0 .. $cpus ], XR->{gauges_disks}, ["MemAvailable:"], XR->{gauges_nics} );

    return $caption;
}

####################################################
#   HANDLERS
####################################################

sub user_command {
    my ( $s, $action ) = (@_);

    if ( $action eq &trc::constants::ACTION_SHOW ) {
        my $h = $s->fheight * ( $s->nrow - 1 );
        my $w = $s->width;
        my $x = 0;
        my $y = XR->{y} >= 0 ? $s->fheight : -1;
        if ( $s->{eterm}->{maximized} ) {
            $s->{eterm}->bounds( $x, $y + 1, $w + 4, $h + 4 );    #TODO why add 4?
            $s->{eterm}->{maximized} = 0;
            $s->{caption}[0]->hide;
        }
        else {
            $s->{eterm}->bounds( 0, 0, $s->width + 4, $s->height + 4 );    #TODO why add 4?
            $s->{eterm}->{maximized} = 1;
        }
    }

    if ( $action eq &trc::constants::ACTION_SHOW_TRANSPARENT ) {
        if ( $s->{eterm}->{maximized} ) {
            $s->{caption}[0]->{visible} ? $s->{caption}[0]->hide : $s->{caption}[0]->show;
        }
    }

    if ( $action eq &trc::constants::ACTION_SHOW_SIDEBAR and XR->{showing} ) {
        $s->{eterm2}->toggle;
    }

    1;
}

sub on_refresh_begin {
    my ($s) = @_;

    if ( $s->{w_sizse} != $s->{term}->ncol ) {
        my $visible_0 = $s->{caption}[0]->{visible};
        my $visible_1 = $s->{caption}[1]->{visible};

        $s->{w_sizse} = $s->{term}->ncol;
        $s->{visuals_updater}->stop;
        $s->{caption}[0] = setCaption $s->{eterm}->{term};
        $s->{caption}[1] = setCaption $s;
        $s->{caption}[0]->create;
        $s->{caption}[1]->create;
        $visible_0 ? $s->{caption}[0]->show : $s->{caption}[0]->hide;
        $visible_1 ? $s->{caption}[1]->show : $s->{caption}[1]->hide;
        $s->{visuals_updater}->start;
    }
    1;
}

####################################################
#   TERM HANDLERS
####################################################

sub on_configure_notify {
    my $s = shift;
    my $h = $s->fheight * ( $s->nrow - 1 ) + 4;
    my $w = $s->width;
    my $x = 0;
    my $y = XR->{y} >= 0 ? $s->fheight : -1;

    if ( $s->{eterm}->{maximized} ) {
        $s->{eterm}->bounds( 0, 0, $s->width + 4, $s->height + 4 );    #TODO why add 4?
    }
    else {
        $s->{eterm}->bounds( $x, $y + 1, $w + 4, $h );                 #TODO why add 4?
    }
    $s->{eterm2}->bounds( $w - $s->fwidth * 35 + 4, 0, $s->fwidth * 35, $s->height + 4 );    #TODO why add 4?
    $s->{eterm2}->setContent;
    1;
}

#just to be save
for my $h (qw(key_press key_release)) {
    ## no critic
    eval qq { sub on_$h { 1; } };
}

for my $h (qw(focus_in focus_out)) {
    eval qq{ sub on_$h { (shift)->{eterm}->{term}->$h; 1; } };                               ## no critic
}

sub on_wm_delete_window {
    trc::term::destroy_All;    #TODO works, but I don't understand why since destroy is not defined ...
    1;
}

sub on_tt_write {
    (shift)->{eterm}->{term}->tt_write(shift);
    1;
}

####################################################
#   MAIN
####################################################

sub on_init {
    my ($s) = @_;

    XR->{label_network}      = $s->x_resource('%.label.network')      // 'NETWORK';
    XR->{label_disk}         = $s->x_resource('%.label.disk')         // 'DISK';
    XR->{label_cpu}          = $s->x_resource('%.label.cpu')          // 'CPU';
    XR->{label_ram}          = $s->x_resource('%.label.ram')          // 'RAM';
    XR->{showing}            = $s->x_resource('%.showing')            // 1;
    XR->{showing_labels}     = $s->x_resource('%.showing.labels')     // 1;
    XR->{showing_background} = $s->x_resource('%.showing.background') // 1;
    XR->{caption}            = $s->x_resource('%.caption')            // 'bar';       #block | bar | solid-bar
    XR->{caption_background} = $s->x_resource('%.caption-background') // '235';
    XR->{padding}            = $s->x_resource('%.padding')            // 2;           #Padding between visuals
    XR->{x} = $s->x_resource('%.x') // -1;    #positive from left, negativ from right
    XR->{y} = $s->x_resource('%.y') // -1;    #positive from top, negativ from bottom

    my $disks = $s->x_resource('%.gauges.disks') // 'sda';    #Can be a list, e.g. 'a,b,c' or 'a b c'
    $disks = [ split( /[[:punct:],[:space:]]/, $disks ) ];
    XR->{gauges_disks} = trc::proc::getDisks;

    my $nics = $s->x_resource('%.gauges.nics') // 'eth0';     #Can be a list, e.g. 'a,b,c' or 'a b c'
    $nics = [ split( /[[:punct:],[:space:]]/, $nics ) ];
    XR->{gauges_nics} = $nics;

    #TODO not yet working
    my $order = $s->x_resource('%.header-labels') // 'DISK,CPU,RAM,NETWORK';
    $order = [ split( /[[:punct:],[:space:]]/, $order ) ];
    XR->{gauges_order} = $order;
    XR->{gauges_background} = $s->x_resource('%.gauges-background') // '5';    #simple | full

    ();
}

sub on_start {
    my ($s) = @_;
    my @argv = $s->argv;

    #TODO maybe just create with 0 and handle everything else in config_notify
    $s->{eterm} = trc::term->new(
        $s, XR, 0, XR->{y} >= 0 ? $s->fheight : 0,
        $s->width, $s->fheight * ( $s->nrow - 1 ),
        4, 1, @argv
    );

    $s->{eterm}->{maximized} = 1 if XR->{caption} eq trc::constants::CAPTION_BAR;
    $s->{eterm2} =
      trc::term->new( $s, XR, $s->width / 2, 0, $s->width / 2 + 1, $s->fheight * ( $s->nrow ), 5, 0, @argv );
    $s->{eterm2}->disableCursor;
    $s->{eterm2}->setContent;
    $s->{eterm2}->hide;
    $s->{eterm}->show;

    $s->{eterm}->hide if ( XR->{caption} eq trc::constants::CAPTION_BLOCK );

    $s->{w_sizse}    = $s->{term}->ncol;
    $s->{caption}[0] = setCaption $s->{eterm}->{term};
    $s->{caption}[1] = setCaption $s;
    $s->{caption}[0]->create;
    $s->{caption}[1]->create;

    $s->cmd_parse("\033[?25l");    #do not show the cursor!
    do { shift @argv; } while @argv && $argv[0] ne "-e";    #urxvt [options] [-e command [ args ]]

    $s->{visuals_updater} = urxvt::timer->new->start( int urxvt::NOW )->interval(1)->cb(
        sub {
            my %r = %{&trc::proc::getCpuUsage};
            while ( my ( $key, $value ) = each %r ) {
                $s->{caption}[0]->set( XR->{label_cpu}, $key, $value ) if ( $key =~ /^cpu[0-9]/ );
                $s->{caption}[1]->set( XR->{label_cpu}, $key, $value ) if ( $key =~ /^cpu[0-9]/ );
            }

            %r = %{&trc::proc::getDiskUsage};
            foreach ( @{ XR->{gauges_disks} } ) {
                $s->{caption}[0]->set( XR->{label_disk}, $_, $r{$_} );
                $s->{caption}[1]->set( XR->{label_disk}, $_, $r{$_} );
            }

            %r = %{&trc::proc::getMemoryUsage};
            while ( my ( $key, $value ) = each %r ) {
                $s->{caption}[0]->set( XR->{label_ram}, $key, $value );
                $s->{caption}[1]->set( XR->{label_ram}, $key, $value );
            }

            %r = %{&trc::proc::getNetworkUsage};
            while ( my ( $key, $value ) = each %r ) {
                $s->{caption}[0]->set( XR->{label_network}, $key, $value );
                $s->{caption}[1]->set( XR->{label_network}, $key, $value );
            }
        }
    );

    ();
}

