#!/usr/bin/perl

# TopRightCorner (TRC) is an extension written for urxvt that shows
# utilizations of different system resoureces like cpu, disk i/o, ram,
# network (and more).

# Copyright (C) 2016 Marcel Lautenbach
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use strict;
use warnings FATAL => 'all';
use autodie;
use 5.22.2;
use List::Util qw(sum max min);
use utf8;

use open ':std', ':encoding(UTF-8)';

my $G_rend = urxvt::OVERLAY_RSTYLE;
$G_rend = urxvt::SET_BGCOLOR $G_rend, 1;
$G_rend = urxvt::SET_FGCOLOR $G_rend, 255;

#$rend = $rend | urxvt::RS_Bold;

my $G_speed =
    `curl -s "http://fritz.box:49000/igd2upnp/control/WANCommonIFC1" -H "Content-Type: text/xml; charset="utf-8"" -H "SoapAction:urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1#GetCommonLinkProperties" -d '<?xml version="1.0" encoding="utf-8"?><s:Envelope s:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" xmlns:s="http://schemas.xmlsoap.org/soap/envelope/"><s:Body><u:GetCommonLinkProperties xmlns:u="urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1" /></s:Body></s:Envelope>'`;
$G_speed =~ /.*(NewLayer1DownstreamMaxBitRate)>([0-9]+)/;
$G_speed = $2 / 8;

use constant {
    RED    => 3,
    GREEN  => 4,
    PINK   => 7,
    YELLOW => 5,
    BLUE   => 6,
    WHITE  => 248,
};

use constant {
    STAT      => '/proc/stat',
    DISKSTATS => '/proc/diskstats',
    MEMINFO   => '/proc/meminfo',
    RX_BYTES  => '/sys/class/net/eth0/statistics/rx_bytes',
};

use constant {
    CPU     => 'cpu',
    MEMORY  => 'memory',
    NETWORK => 'network',
    DISK    => 'disk',
};

use constant {
    ACTION_SHOW        => 'show',
    ACTION_SHOW_LABELS => 'show-labels',
    ACTION_SHOW_HEADER => 'show-header',
};

use constant {
    CAPTION_BLOCK => 'block',
    CAPTION_BAR   => 'bar',
    GAUGES_SIMPLE => 'simple',
    GAUGES_FULL   => 'full',
};

my $R_GAUGES_SIMPLE = qr/${\(GAUGES_SIMPLE)}/;
my $R_GAUGES_FULL   = qr/${\(GAUGES_FULL)}/;
my $R_CAPTION_BAR   = qr/${\(CAPTION_BAR)}/;
my $R_CAPTION_BLOCK = qr/${\(CAPTION_BLOCK)}/;

####################################################
#   UTILITY METHODS
####################################################

sub getColor {
    for (shift) {
        return RED    if $_ > 80;
        return YELLOW if $_ > 60;
        return BLUE   if $_ > 40;
        return GREEN  if $_ > 20;
    }
    WHITE;
}

sub setCaption {
    my $self = shift;

    for ( $self->{X_RESOURCE}->{CAPTION} ) {
        /$R_CAPTION_BAR/
            and $self->{caption} = visuals::container->new(
            $self, $G_rend,
            $self->{X_RESOURCE}->{X},
            $self->{X_RESOURCE}->{Y},
            $self->{X_RESOURCE}->{PADDING},
            CAPTION_BAR, 0
        );
        /$R_CAPTION_BLOCK/
            and $self->{caption} =
            visuals::container->new( $self, $G_rend, -1, $self->{X_RESOURCE}->{Y}, 0, CAPTION_BLOCK, 1 );
    }

    for ( $self->{X_RESOURCE}->{GAUGES} ) {
        /full/ and &{
            sub {
                $self->{caption}->add( CPU,     [qw/cpu0 cpu1 cpu2 cpu3/] );
                $self->{caption}->add( DISK,    [qw/sda sdb/] );
                $self->{caption}->add( MEMORY,  ["MemAvailable:"] );
                $self->{caption}->add( NETWORK, ["eth0"] );
            }
        }();
        /simple/ and &{
            sub {
                $self->{caption}->add( CPU,     ["cpu"] );
                $self->{caption}->add( DISK,    ["sda"] );
                $self->{caption}->add( MEMORY,  ["MemAvailable:"] );
                $self->{caption}->add( NETWORK, ["eth0"] );
            }
        }();
    }
}

sub initFromResources {
    my $self = shift;

    $self->{X_RESOURCE}->{LABELS}->{&NETWORK} = $self->x_resource('%.label.network') // 'NETWORK';
    $self->{X_RESOURCE}->{LABELS}->{&DISK}    = $self->x_resource('%.label.disk')    // 'DISK';
    $self->{X_RESOURCE}->{LABELS}->{&CPU}     = $self->x_resource('%.label.cpu')     // 'CPU';
    $self->{X_RESOURCE}->{LABELS}->{&MEMORY}  = $self->x_resource('%.label.ram')     // 'RAM';

    $self->{X_RESOURCE}->{SHOWING}        = $self->x_resource_boolean('%.showing')        // 1;
    $self->{X_RESOURCE}->{SHOWING_LABELS} = $self->x_resource_boolean('%.showing-labels') // 0;

    $self->{X_RESOURCE}->{CAPTION} = $self->x_resource('%.captioin') // 'bar';    #block | bar | solid-bar
    #$self->{X_RESOURCE}->{CAPTION} = $self->x_resource('%.captioin') // 'block'; #block | bar
    $self->{X_RESOURCE}->{PADDING} = $self->x_resource('%.padding') // 2;        #Padding between visuals
    $self->{X_RESOURCE}->{X}       = $self->x_resource('%.x')       // -1;       #positive from left, negativ from right
    $self->{X_RESOURCE}->{Y}       = $self->x_resource('%.y')       // 0;        #positive from top, negativ from bottom
    $self->{X_RESOURCE}->{GAUGES}  = $self->x_resource('%.gauges')  // 'full';   #simple | full
    #$self->{X_RESOURCE}->{GAUGES} = $self->x_resource('%.gauges') // 'simple';    #simple | full

    $self->{X_RESOURCE}->{GAUGES_ORDER} = $self->x_resource('%.header-labels') // 'CPU,DISK,RAM,NETWORK';
    $self->{X_RESOURCE}->{GAUGES_ORDER} = [ split( /[[:punct:],[:space:]]/, $self->{X_RESOURCE}->{GAUGES_ORDER} ) ];
}

####################################################
#   DATA
####################################################

sub getCpuUsage {
    state %cpus;
    my $diff_usage = 0;
    my %results;

    open( my $f, '<', STAT );
    while (<$f>) {
        if ( !/^cpu[0-9]*\s+[0-9]+/ ) {
            next;
        }

        my @cpu = split /\s+/;
        my $cpu = shift @cpu;

        $cpus{$cpu} = {} if !defined $cpus{$cpu};

        $cpus{$cpu}{prev_idle}  = $cpus{$cpu}{prev_idle}  // 0;
        $cpus{$cpu}{prev_total} = $cpus{$cpu}{prev_total} // 0;
        $cpus{$cpu}{diff_total} = $cpus{$cpu}{diff_total} // 0;

        my $idle  = $cpu[3];
        my $total = sum(@cpu);

        my $diff_idle = $idle - $cpus{$cpu}{prev_idle};
        if ( $total != $cpus{$cpu}{prev_total} ) {
            $cpus{$cpu}{diff_total} = $total - $cpus{$cpu}{prev_total};
        }
        $diff_usage = 100 * ( $cpus{$cpu}{diff_total} - $diff_idle ) / $cpus{$cpu}{diff_total};

        $cpus{$cpu}{prev_idle}  = $idle;
        $cpus{$cpu}{prev_total} = $total;

        $results{$cpu} = $diff_usage;
    }
    return \%results;
}

sub getDiskUsage {

    state %sda;
    my $diff_usage;
    my %results;

    open( my $f, '<', DISKSTATS );
    while (<$f>) {
        if ( !/\bsd(a|b|c)\b/ ) {
            next;
        }
        my @sda = split /\s+/, $_;
        shift @sda;
        shift @sda;
        shift @sda;

        $sda{ $sda[0] } = $sda{ $sda[0] } // 0;

        my $diff_sda = $sda[10] - $sda{ $sda[0] };
        $diff_usage = $diff_sda / 10;

        $sda{ $sda[0] }     = $sda[10];
        $results{ $sda[0] } = $diff_usage;
    }
    return \%results;
}

sub getMemoryUsage {
    my @sda;
    my $total     = 0;
    my $available = 0;
    my %results;

    open( my $f, '<', MEMINFO );
    while (<$f>) {
        if (/^MemTotal:\s+[0-9]+/) {
            @sda = split /\s+/, $_;
            $total = $sda[1];
        }
        if (/^MemAvailable:\s+[0-9]+/) {
            @sda = split /\s+/, $_;
            $available = $sda[1];
        }
    }

    $results{ $sda[0] } = 100 - ( 100 * $available / $total );
    return \%results;
}

sub getNetworkUsage {
    my $rx_bytes = 0;
    state $prev_rx = 0;

    open( my $f, '<', RX_BYTES );
    {
        local $/;
        $rx_bytes = <$f>;
    }

    my $diff_rx    = $rx_bytes - $prev_rx;
    my $diff_usage = 100 * $diff_rx / $G_speed;

    $prev_rx = $rx_bytes;

    return { "eth0", $diff_usage };

    #open(STAT, '/sys/class/net/eth0/speed');
    #{
    #    local $/;
    #    $speed = <STAT>;
    #    $speed = 11 * 1000000 / 8
    #}
    #close STAT;
}

####################################################
#   HANDLERS
####################################################

sub on_action {
    my ( $self, $action ) = @_;

    if ( $action eq ACTION_SHOW ) {
        $self->{X_RESOURCE}->{SHOWING} = !$self->{X_RESOURCE}->{SHOWING};
        while ( my ( $key, $value ) = each( %{ $self->{overlays} } ) ) {
            $value->show if $key !~ /label/i and $self->{X_RESOURCE}->{SHOWING};
            $value->hide if !$self->{X_RESOURCE}->{SHOWING};
            $value->show
                if $key =~ /label/i
                    and $self->{X_RESOURCE}->{SHOWING_LABELS}
                    and $self->{X_RESOURCE}->{SHOWING};
        }
    }

    if ( $action eq ACTION_SHOW_LABELS and $self->{X_RESOURCE}->{SHOWING} ) {
        $self->{X_RESOURCE}->{SHOWING_LABELS} = !$self->{X_RESOURCE}->{SHOWING_LABELS};
        while ( my ( $key, $value ) = each( %{ $self->{overlays} } ) ) {
            $value->show if $key =~ /label/i and $self->{X_RESOURCE}->{SHOWING_LABELS};
            $value->hide if $key =~ /label/i and !$self->{X_RESOURCE}->{SHOWING_LABELS};
        }
    }

    if ( $action eq ACTION_SHOW_HEADER ) {
        $self->{X_RESOURCE}->{SHOWING} = !$self->{X_RESOURCE}->{SHOWING};
        while ( my ( $key, $value ) = each( %{ $self->{overlays} } ) ) {
            $value->show if $key !~ /label/i and $self->{X_RESOURCE}->{SHOWING};
            $value->hide if !$self->{X_RESOURCE}->{SHOWING};
            $value->show
                if $key =~ /label/i
                    and $self->{X_RESOURCE}->{SHOWING_LABELS}
                    and $self->{X_RESOURCE}->{SHOWING};
        }
    }
    ();
}

sub on_refresh_begin {
    my ($self) = @_;
    if ( $self->{w_sizse} != $self->{term}->ncol ) {
        $self->{w_sizse} = $self->{term}->ncol;
        my @stats = ( CPU, DISK, MEMORY, NETWORK );
        $self->{visuals_updater}->stop;
        setCaption $self;
        $self->{caption}->create;
        $self->{visuals_updater}->start;
    }
    my $empty = 1;

    for ( my $i = 1 ; $i < $self->nrow ; $i++ ) {
        $empty = 0 if $self->ROW_t($i) !~ /^\s*$/;
    }

    for ( $self->{X_RESOURCE}->{CAPTION} ) {
        /$R_CAPTION_BAR/ and &{
            sub {
                if ( $self->ROW_t(0) !~ /^\s*$/ and $empty ) {
                    $self->cmd_parse("\e[1T\e[1B");

                    #$self->view_start(-1);
                }
            }
        }();
        /$R_CAPTION_BLOCK/ and &{
            sub {
                #Nothing to do yet!
            }
        }();
    }
}

sub setBG {
    my $self = shift;

    for ( $self->{X_RESOURCE}->{CAPTION} ) {
        /$R_CAPTION_BAR/ and &{
            sub {
                #my $r = urxvt::SET_BGCOLOR $G_rend, 4;
                #$self->{bg} = visuals::overlay->new($self, 0, 0, $self->ncol, 1, $r);
                $self->{bg} = visuals::overlay->new( $self, 0, 0, $self->ncol, 1, $G_rend );
                $self->{bg}->create("show");
            }
        }();
        /$R_CAPTION_BLOCK/ and &{
            sub {
                #Nothin to do yet.
            }
        }();
    }
}

####################################################
#   MAIN
####################################################

sub on_init {
    my ($self) = @_;

    my $hotkey = $self->x_resource("%") || "M-n";
    $self->bind_action( $hotkey, "%:" . ACTION_SHOW ) or warn "unable to register '$hotkey' as hotkey\n";

    $hotkey = $self->x_resource("%") || "M-l";
    $self->bind_action( $hotkey, "%:" . ACTION_SHOW_LABELS ) or warn "unable to register '$hotkey' as hotkey\n";

    $hotkey = $self->x_resource("%") || "M-h";
    $self->bind_action( $hotkey, "%:" . ACTION_SHOW_HEADER ) or warn "unable to register '$hotkey' as hotkey\n";

    initFromResources $self;
    ();
}

sub on_start {
    my ($self) = @_;

    setCaption $self;
    $self->{w_sizse} = $self->{term}->ncol;
    $self->{caption}->create;
    $self->{createTimer} = \&createTimer;

    $self->{visuals_updater} = urxvt::timer->new->start( 1 + int urxvt::NOW )->interval(1)->cb(
        sub {
            my %r = %{&getCpuUsage};
            if ( $self->{X_RESOURCE}->{GAUGES} =~ $R_GAUGES_FULL ) {
                while ( my ( $key, $value ) = each %r ) {
                    $self->{caption}->set( CPU, $key, $value ) if $key =~ /^cpu[0-9]/;
                }
            }
            $self->{caption}->set( CPU, "cpu", $r{cpu} ) if $self->{X_RESOURCE}->{GAUGES} =~ $R_GAUGES_SIMPLE;

            %r = %{&getDiskUsage};
            while ( my ( $key, $value ) = each %r ) {
                $self->{caption}->set( DISK, $key, $value ) if $self->{X_RESOURCE}->{GAUGES} =~ $R_GAUGES_FULL;
            }
            $self->{caption}->set( DISK, "sda", $r{sda} ) if $self->{X_RESOURCE}->{GAUGES} =~ $R_GAUGES_SIMPLE;

            %r = %{&getMemoryUsage};
            while ( my ( $key, $value ) = each %r ) {
                $self->{caption}->set( MEMORY, $key, $value );
            }

            %r = %{&getNetworkUsage};
            while ( my ( $key, $value ) = each %r ) {
                $self->{caption}->set( NETWORK, $key, $value );
            }

            setBG $self;
        }
    );

    ();
}

package visuals::overlay {
    use fields qw(term overlay x y width height rendition caption);

    sub new {
        my $self = shift;
        $self = fields::new($self) unless ref $self;

        @$self{qw(term x y width height rendition caption)} = @_;
        return $self;
    }

    sub create {
        my $self = shift;
        my $show = shift;
        $self->{overlay} =
            $self->{term}->overlay( $self->{x}, $self->{y}, $self->{width}, $self->{height}, $self->{rendition}, 0 );
        $self->set( $self->{caption} ) if defined $self->{caption};
        $self->hide if !$show;
    }

    sub set {
        my $self = shift;
        $self->{caption} = shift;
        $self->{overlay}->set( 0, 0, $self->{caption} );    #TODO
    }

    sub hide {
        my $self = shift;
        $self->{overlay}->hide;
    }

    sub show {
        my $self = shift;
        $self->{overlay}->show;
    }
}

package visuals::container {
    use fields qw(sprites padding term rendition x y align evenGauges);
    my ( $xOff, $yOff, $m ) = ( 0, 0, 0 );

    sub new {
        my $self = shift;
        $self = fields::new($self) unless ref $self;

        @$self{qw/term rendition x y padding align evenGauges/} = @_;
        $xOff                                                   = 0;
        $yOff                                                   = $self->{y};
        return $self;
    }

    sub add {
        my ( $self, $label, $visuals ) = @_;
        my $visual = visuals::visual->new( $self->{term}, $self->{rendition}, $xOff, $yOff, $label, $visuals );

        $self->{sprites}->{"$label"} = $visual;
        if ( @{$visuals} > $m && $self->{evenGauges} ) {
            $m = @{$visuals};
            foreach ( values %{ $self->{sprites} } ) {
                $_->setEvenGauges($m);
                $xOff += $visual->{width} if $self->{align} eq $self->{term}->CAPTION_BAR;
            }
        }
        $visual->setEvenGauges($m) if $self->{evenGauges};
        $xOff += $visual->{width} + $self->{padding}  if $self->{align} eq $self->{term}->CAPTION_BAR;
        $yOff += $visual->{height} + $self->{padding} if $self->{align} eq $self->{term}->CAPTION_BLOCK;
    }

    sub create {
        my $self = shift;

        if ( $self->{x} < 0 ) {
            for ( $self->{term}->{X_RESOURCE}->{CAPTION} ) {
                /${\($self->{term}->CAPTION_BAR)}/ and &{
                    sub {
                        $_->{x} = $self->{term}->ncol - $xOff + $_->{x} + $self->{x} + $self->{padding} + 1
                            foreach ( values %{ $self->{sprites} } );
                    }
                }();
                /${\($self->{term}->CAPTION_BLOCK)}/ and &{
                    sub {
                        $_->{x} = $self->{term}->ncol - $_->{x} - $_->{width} + $self->{x}
                            foreach ( values %{ $self->{sprites} } );
                    }
                }();
            }
        }
        else {
            $_->{x} += $self->{x} foreach values %{ $self->{sprites} };
        }
        $_->create foreach values %{ $self->{sprites} };
    }

    sub set {
        my ( $self, $label, $i, $usage ) = (@_);
        $self->{sprites}->{"$label"}->set( $i, $usage );
    }

    sub setColor {
        my $self  = shift;
        my $label = shift;
        my $i     = shift;
        my $usage = shift;
        $self->{sprites}->{"$label"}->setColor( $i, $usage );
    }
}

package visuals::visual {
    use fields qw(term x y rendition pictorials label count width height);
    use constant BLOCKS => [qw/_ ▁ ▂ ▃ ▄ ▅ ▆ ▇ █/];
    use constant { GAUGE => '▪' };
    use List::Util qw(max);
    my $m = 0;

    use constant {
        RED    => 3,
        GREEN  => 4,
        PINK   => 7,
        YELLOW => 5,
        BLUE   => 6,
        WHITE  => 248,
    };

    sub getColor {
        for (shift) {
            return RED    if $_ > 80;
            return YELLOW if $_ > 60;
            return BLUE   if $_ > 40;
            return GREEN  if $_ > 20;
        }
        WHITE;
    }

    sub new {
        my $self = shift;
        $self = fields::new($self) unless ref $self;

        @$self{qw/term rendition x y label pictorials/} = @_;

        #my $l = max (map { length } @visuals);
        $self->{width}  = ( length $self->{label} ) + 1 + @{ $self->{pictorials} };
        $self->{height} = 1;
        return $self;
    }

    sub setEvenGauges {
        my ( $self, $m ) = @_;
        $self->{width} += ( -@{ $self->{pictorials} } + $m );

    }

    sub show {
        my $self = shift;
        $_->{overlay}->show foreach @{ $self->{pictorials} };
    }

    sub create {
        my $self = shift;
        my $w    = ( length $self->{label} ) + 1;

        my @visuals = @{ $self->{pictorials} };
        $self->{pictorials} = {};
        $self->{x} = -( $w + $m ) if $self->{x} < 0;

        $self->{rendition} = urxvt::SET_FGCOLOR $self->{rendition}, 5;
        my $labelObj =
            visuals::overlay->new( $self->{term}, $self->{x}, $self->{y}, $w, 1, $self->{rendition}, $self->{label} );
        $labelObj->create("show");
        $self->{pictorials}->{ $self->{label} } = $labelObj;

        my $pos   = 0;
        my $width = 1;
        $self->{rendition} = urxvt::SET_BGCOLOR $self->{rendition}, 235;
        for my $i (@visuals) {
            my $x = $self->{x} + $w + $pos++;

            foreach ( &RED, &GREEN, &BLUE, &YELLOW, &WHITE, &PINK ) {
                $self->{rendition} = urxvt::SET_FGCOLOR $self->{rendition}, $_;
                my $gauge;

                for ( $self->{term}->{X_RESOURCE}->{GAUGES} ) {
                    /${\($self->{term}->GAUGES_FULL)}/ and &{
                        sub {
                            $gauge =
                                visuals::overlay->new( $self->{term}, $x, $self->{y}, $width, 1, $self->{rendition},
                                    BLOCKS->[0] );
                        }
                    }();
                    /${\($self->{term}->GAUGES_SIMPLE)}/ and &{
                        sub {
                            $gauge =
                                visuals::overlay->new( $self->{term}, $x, $self->{y}, $width, 1, $self->{rendition},
                                    GAUGE );
                        }
                    }();
                }
                $gauge->create;
                $self->{pictorials}->{"$i"}->{"$_"} = $gauge;
            }
        }
    }

    sub hide {
        my $self = shift;
        $_->{overlay}->hide foreach @{ $self->{pictorials} };
    }

    sub set {
        my ( $self, $i, $usage ) = @_;
        my $barIdx = $usage / 10 * 8 / 10;

        my $color = &getColor($usage);
        for ( values %{ $self->{pictorials}->{"$i"} } ) {
            $_->hide;
        }
        if ( $barIdx <= 8 && $barIdx >= 0 ) {
            $self->{pictorials}->{"$i"}->{"$color"}->show;

            for ( $self->{term}->{X_RESOURCE}->{GAUGES} ) {
                /${\($self->{term}->GAUGES_FULL)}/ and &{
                    sub {
                        $self->{pictorials}->{"$i"}->{"$color"}->set( BLOCKS->[$barIdx] );
                    }
                }();
                /${\($self->{term}->GAUGES_SIMPLE)}/ and &{
                    sub {
                        #Nothing to do yet.
                    }
                }();
            }
        }
    }
}
