#!/usr/bin/perl

# TopRightCorner (TRC) is an extension written for urxvt that shows
# utilizations of different system resoureces like cpu, disk i/o, ram,
# network (and more).

# Copyright (C) 2016 Marcel Lautenbach
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use strict;
use warnings FATAL => 'all';
use autodie;
use 5.22.2;
use List::Util qw(sum max min);
use utf8;

use open ':std', ':encoding(UTF-8)';

my $G_rend = urxvt::OVERLAY_RSTYLE;
$G_rend = urxvt::SET_BGCOLOR $G_rend, 1;
$G_rend = urxvt::SET_FGCOLOR $G_rend, 255;

#$rend = $rend | urxvt::RS_Bold;

my $G_speed =
`curl -s "http://fritz.box:49000/igd2upnp/control/WANCommonIFC1" -H "Content-Type: text/xml; charset="utf-8"" -H "SoapAction:urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1#GetCommonLinkProperties" -d '<?xml version="1.0" encoding="utf-8"?><s:Envelope s:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" xmlns:s="http://schemas.xmlsoap.org/soap/envelope/"><s:Body><u:GetCommonLinkProperties xmlns:u="urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1" /></s:Body></s:Envelope>'`;
$G_speed =~ /.*(NewLayer1DownstreamMaxBitRate)>([0-9]+)/;
$G_speed = $2 / 8;

use constant {
    RED    => 3,
    GREEN  => 4,
    PINK   => 7,
    YELLOW => 5,
    BLUE   => 6,
    WHITE  => 248,
};

use constant {
    STAT      => '/proc/stat',
    DISKSTATS => '/proc/diskstats',
    MEMINFO   => '/proc/meminfo',
    RX_BYTES  => '/sys/class/net/eth0/statistics/rx_bytes',
};

use constant {
    CPU     => 'cpu',
    MEMORY  => 'memory',
    NETWORK => 'network',
    DISK    => 'disk',
};

use constant {
    ACTION_SHOW        => 'show',
    ACTION_SHOW_LABELS => 'show-labels',
    ACTION_SHOW_HEADER => 'show-header',
};

use constant {
    CAPTION_BLOCK => 'block',
    CAPTION_BAR   => 'bar',
    GAUGES_SIMPLE => 'simple',
    GAUGES_FULL   => 'full',
};

my $R_GAUGES_SIMPLE = qr/${\(GAUGES_SIMPLE)}/;
my $R_GAUGES_FULL   = qr/${\(GAUGES_FULL)}/;
my $R_CAPTION_BAR   = qr/${\(CAPTION_BAR)}/;
my $R_CAPTION_BLOCK = qr/${\(CAPTION_BLOCK)}/;

####################################################
#   UTILITY METHODS
####################################################

sub getColor {
    for (shift) {
        return RED    if $_ > 80;
        return YELLOW if $_ > 60;
        return BLUE   if $_ > 40;
        return GREEN  if $_ > 20;
    }
    WHITE;
}

sub setCaption {
    my $self = shift;

    my $cpu     = qr/${\($self->{XR}->{LABELS}->{&CPU})}/;
    my $disk    = qr/${\($self->{XR}->{LABELS}->{&DISK})}/;
    my $memory  = qr/${\($self->{XR}->{LABELS}->{&MEMORY})}/;
    my $network = qr/${\($self->{XR}->{LABELS}->{&NETWORK})}/;

    for ( $self->{XR}->{CAPTION} ) {
        /$R_CAPTION_BAR/
          and $self->{caption} = visuals::container->new(
            $self, $G_rend,
            $self->{XR}->{X},
            $self->{XR}->{Y},
            $self->{XR}->{PADDING},
            CAPTION_BAR, 0
          );
        /$R_CAPTION_BLOCK/
          and $self->{caption} =
          visuals::container->new( $self, $G_rend, -1, $self->{XR}->{Y}, 0, CAPTION_BLOCK, 1 );
    }

    for ( $self->{XR}->{GAUGES} ) {
        /full/ and &{
            sub {
                for ( @{ $self->{XR}->{GAUGES_ORDER} } ) {
                    /$cpu/     and $self->{caption}->add( $_, [qw/cpu0 cpu1 cpu2 cpu3/] );
                    /$disk/    and $self->{caption}->add( $_, [qw/sda sdb/] );
                    /$memory/  and $self->{caption}->add( $_, ["MemAvailable:"] );
                    /$network/ and $self->{caption}->add( $_, ["eth0"] );
                }
              }
        }();
        /simple/ and &{
            sub {
                for ( @{ $self->{XR}->{GAUGES_ORDER} } ) {
                    /$cpu/     and $self->{caption}->add( $_, ["cpu"] );
                    /$disk/    and $self->{caption}->add( $_, ["sda"] );
                    /$memory/  and $self->{caption}->add( $_, ["MemAvailable:"] );
                    /$network/ and $self->{caption}->add( $_, ["eth0"] );
                }
              }
        }();
    }
}

sub initFromResources {
    my $self = shift;

    $self->{XR}->{LABELS}->{&NETWORK} = $self->x_resource('%.label.network') // 'NETWORK';
    $self->{XR}->{LABELS}->{&DISK}    = $self->x_resource('%.label.disk')    // 'DISK';
    $self->{XR}->{LABELS}->{&CPU}     = $self->x_resource('%.label.cpu')     // 'CPU';
    $self->{XR}->{LABELS}->{&MEMORY}  = $self->x_resource('%.label.ram')     // 'RAM';

    $self->{XR}->{SHOWING}            = $self->x_resource('%.showing')            // 1;
    $self->{XR}->{SHOWING_LABELS}     = $self->x_resource('%.showing.labels')     // 1;
    $self->{XR}->{SHOWING_BG} = $self->x_resource('%.showing.background') // 1;

    $self->{XR}->{CAPTION} = $self->x_resource('%.caption') // 'bar';    #block | bar | solid-bar
          #$self->{XR}->{CAPTION}    = $self->x_resource('%.caption')            // 'block';    #block | bar
    $self->{XR}->{CAPTION_BG} = $self->x_resource('%.caption-background') // '235';    #block | bar

    $self->{XR}->{PADDING} = $self->x_resource('%.padding') // 2;        #Padding between visuals
    $self->{XR}->{X}       = $self->x_resource('%.x')       // -1;       #positive from left, negativ from right
    $self->{XR}->{Y}       = $self->x_resource('%.y')       // 0;        #positive from top, negativ from bottom
    $self->{XR}->{GAUGES}  = $self->x_resource('%.gauges')  // 'full';   #simple | full
          #$self->{XR}->{GAUGES} = $self->x_resource('%.gauges') // 'simple';    #simple | full

    #TODO not yet working
    $self->{XR}->{GAUGES_ORDER} = $self->x_resource('%.header-labels') // 'DISK,CPU,RAM,NETWORK';
    $self->{XR}->{GAUGES_ORDER} = [ split( /[[:punct:],[:space:]]/, $self->{XR}->{GAUGES_ORDER} ) ];
    $self->{XR}->{GAUGES_BG} = $self->x_resource('%.gauges-background') // '5';    #simple | full
}

####################################################
#   DATA
####################################################

sub getCpuUsage {
    state %cpus;
    my $diff_usage = 0;
    my %results;

    open( my $f, '<', STAT );
    while (<$f>) {
        if ( !/^cpu[0-9]*\s+[0-9]+/ ) {
            next;
        }

        my @cpu = split /\s+/;
        my $cpu = shift @cpu;

        $cpus{$cpu} = {} if !defined $cpus{$cpu};

        $cpus{$cpu}{prev_idle}  = $cpus{$cpu}{prev_idle}  // 0;
        $cpus{$cpu}{prev_total} = $cpus{$cpu}{prev_total} // 0;
        $cpus{$cpu}{diff_total} = $cpus{$cpu}{diff_total} // 0;

        my $idle  = $cpu[3];
        my $total = sum(@cpu);

        my $diff_idle = $idle - $cpus{$cpu}{prev_idle};
        if ( $total != $cpus{$cpu}{prev_total} ) {
            $cpus{$cpu}{diff_total} = $total - $cpus{$cpu}{prev_total};
        }
        $diff_usage = 100 * ( $cpus{$cpu}{diff_total} - $diff_idle ) / $cpus{$cpu}{diff_total};

        $cpus{$cpu}{prev_idle}  = $idle;
        $cpus{$cpu}{prev_total} = $total;

        $results{$cpu} = $diff_usage;
    }
    return \%results;
}

sub getDiskUsage {

    state %sda;
    my $diff_usage;
    my %results;

    open( my $f, '<', DISKSTATS );
    while (<$f>) {
        if ( !/\bsd(a|b|c)\b/ ) {
            next;
        }
        my @sda = split /\s+/, $_;
        shift @sda;
        shift @sda;
        shift @sda;

        $sda{ $sda[0] } = $sda{ $sda[0] } // 0;

        my $diff_sda = $sda[10] - $sda{ $sda[0] };
        $diff_usage = $diff_sda / 10;

        $sda{ $sda[0] }     = $sda[10];
        $results{ $sda[0] } = $diff_usage;
    }
    return \%results;
}

sub getMemoryUsage {
    my @sda;
    my $total     = 0;
    my $available = 0;
    my %results;

    open( my $f, '<', MEMINFO );
    while (<$f>) {
        if (/^MemTotal:\s+[0-9]+/) {
            @sda = split /\s+/, $_;
            $total = $sda[1];
        }
        if (/^MemAvailable:\s+[0-9]+/) {
            @sda = split /\s+/, $_;
            $available = $sda[1];
        }
    }

    $results{ $sda[0] } = 100 - ( 100 * $available / $total );
    return \%results;
}

sub getNetworkUsage {
    my $rx_bytes = 0;
    state $prev_rx = 0;

    open( my $f, '<', RX_BYTES );
    {
        local $/;
        $rx_bytes = <$f>;
    }

    my $diff_rx    = $rx_bytes - $prev_rx;
    my $diff_usage = 100 * $diff_rx / $G_speed;

    $prev_rx = $rx_bytes;

    return { "eth0", $diff_usage };

    #open(STAT, '/sys/class/net/eth0/speed');
    #{
    #    local $/;
    #    $speed = <STAT>;
    #    $speed = 11 * 1000000 / 8
    #}
    #close STAT;
}

####################################################
#   HANDLERS
####################################################

sub on_action {
    my ( $self, $action ) = @_;

    if ( $action eq ACTION_SHOW ) {
        $self->{caption}->{visible} ? $self->{caption}->hide : $self->{caption}->show;
    }

    if ( $action eq ACTION_SHOW_LABELS and $self->{XR}->{SHOWING} ) {
        $self->{caption}->{labelVisible} ? $self->{caption}->hideLabels : $self->{caption}->showLabels;
    }

    ();
}

sub on_refresh_begin {
    my ($self) = @_;
    if ( $self->{w_sizse} != $self->{term}->ncol ) {
        $self->{w_sizse} = $self->{term}->ncol;
        $self->{visuals_updater}->stop;
        setCaption $self;
        $self->{caption}->create;
        $self->{visuals_updater}->start;
    }
    my $empty = 1;

    for ( my $i = 1 ; $i < $self->nrow ; $i++ ) {
        $empty = 0 if $self->ROW_t($i) !~ /^\s*$/;
    }

    for ( $self->{XR}->{CAPTION} ) {
        /$R_CAPTION_BAR/ and &{
            sub {
                if ( $self->ROW_t(0) !~ /^\s*$/ and $empty ) {
                    $self->cmd_parse("\e[1T\e[1B");
                }
              }
        }();
        /$R_CAPTION_BLOCK/ and &{
            sub {
                #Nothing to do yet!
              }
        }();
    }
}

####################################################
#   MAIN
####################################################

sub on_init {
    my ($self) = @_;

    my $hotkey = $self->x_resource("%") || "M-n";
    $self->bind_action( $hotkey, "%:" . ACTION_SHOW ) or warn "unable to register '$hotkey' as hotkey\n";

    $hotkey = $self->x_resource("%") || "M-l";
    $self->bind_action( $hotkey, "%:" . ACTION_SHOW_LABELS ) or warn "unable to register '$hotkey' as hotkey\n";

    $hotkey = $self->x_resource("%") || "M-h";
    $self->bind_action( $hotkey, "%:" . ACTION_SHOW_HEADER ) or warn "unable to register '$hotkey' as hotkey\n";

    initFromResources $self;
    ();
}

sub on_start {
    my ($self) = @_;

    setCaption $self;
    $self->{w_sizse} = $self->{term}->ncol;
    $self->{caption}->create;
    $self->{createTimer} = \&createTimer;

    $self->{visuals_updater} = urxvt::timer->new->start( 1 + int urxvt::NOW )->interval(1)->cb(
        sub {
            my %r = %{&getCpuUsage};
            if ( $self->{XR}->{GAUGES} =~ $R_GAUGES_FULL ) {
                while ( my ( $key, $value ) = each %r ) {
                    if ( $key =~ /^cpu[0-9]/ ) {
                        $self->{caption}->set( $self->{XR}->{LABELS}->{&CPU}, $key, $value );
                    }
                }
            }
            if ( $self->{XR}->{GAUGES} =~ $R_GAUGES_SIMPLE ) {
                $self->{caption}->set( $self->{XR}->{LABELS}->{&CPU}, "cpu", $r{cpu} );
            }

            %r = %{&getDiskUsage};
            while ( my ( $key, $value ) = each %r ) {
                if ( $self->{XR}->{GAUGES} =~ $R_GAUGES_FULL ) {
                    $self->{caption}->set( $self->{XR}->{LABELS}->{&DISK}, $key, $value );
                }
            }
            if ( $self->{XR}->{GAUGES} =~ $R_GAUGES_SIMPLE ) {
                $self->{caption}->set( $self->{XR}->{LABELS}->{&DISK}, "sda", $r{sda} );
            }

            %r = %{&getMemoryUsage};
            while ( my ( $key, $value ) = each %r ) {
                $self->{caption}->set( $self->{XR}->{LABELS}->{&MEMORY}, $key, $value );
            }

            %r = %{&getNetworkUsage};
            while ( my ( $key, $value ) = each %r ) {
                $self->{caption}->set( $self->{XR}->{LABELS}->{&NETWORK}, $key, $value );
            }
        }
    );

    ();
}

package visuals::overlay {
    use fields qw(term overlay x y width height rendition caption);

    sub new {
        my $self = shift;
        $self = fields::new($self) unless ref $self;

        @$self{qw(term x y width height rendition caption)} = @_;
        return $self;
    }

    sub create {
        my $self = shift;
        my $show = shift;
        $self->{overlay} =
          $self->{term}->overlay( $self->{x}, $self->{y}, $self->{width}, $self->{height}, $self->{rendition}, 0 );

        $self->set( $self->{caption} ) if defined $self->{caption};
        $self->hide if !$show;
    }

    sub set {
        my $self = shift;
        $self->{caption} = shift;
        $self->{overlay}->set( 0, 0, $self->{caption} );    #TODO
    }

    sub hide {
        my $self = shift;
        $self->{overlay}->hide;
    }

    sub show {
        my $self = shift;
        $self->{overlay}->show;
    }
}

package visuals::container {
    use fields qw(
      term
      sprites padding rendition
      x y
      align evenGauges
      visible labelVisible backgroundVisible
      bg type
    );

    my ( $xOff, $yOff, $m ) = ( 0, 0, 0 );

    sub new {
        my $self = shift;
        $self = fields::new($self) unless ref $self;

        @$self{qw/term rendition x y padding align evenGauges/} = @_;
        $xOff                                                   = 0;
        $yOff                                                   = $self->{y};
        return $self;
    }

    sub add {
        my ( $self, $label, $visuals ) = @_;
        my $visual = visuals::visual->new( $self->{term}, $self->{rendition}, $xOff, $yOff, $label, $visuals,
            $self->{term}->{XR}->{CAPTION_BG} );

        $self->{sprites}->{$label} = $visual;
        if ( @{$visuals} > $m && $self->{evenGauges} ) {
            $m = @{$visuals};
            foreach ( values %{ $self->{sprites} } ) {
                $_->setEvenGauges($m);
                $xOff += $visual->{width} if $self->{align} eq $self->{term}->CAPTION_BAR;
            }
        }
        $visual->setEvenGauges($m) if $self->{evenGauges};
        $xOff += $visual->{width} + $self->{padding}  if $self->{align} eq $self->{term}->CAPTION_BAR;
        $yOff += $visual->{height} + $self->{padding} if $self->{align} eq $self->{term}->CAPTION_BLOCK;
    }

    sub create {
        my $self = shift;

        if ( $self->{x} < 0 ) {
            for ( $self->{term}->{XR}->{CAPTION} ) {
                /${\($self->{term}->CAPTION_BAR)}/ and &{
                    sub {
                        $_->{x} = $self->{term}->ncol - $xOff + $_->{x} + $self->{x} + $self->{padding} + 1
                          foreach ( values %{ $self->{sprites} } );
                      }
                }();
                /${\($self->{term}->CAPTION_BLOCK)}/ and &{
                    sub {
                        $_->{x} = $self->{term}->ncol - $_->{x} - $_->{width} + $self->{x}
                          foreach ( values %{ $self->{sprites} } );
                      }
                }();
            }
        }
        else {
            $_->{x} += $self->{x} foreach values %{ $self->{sprites} };
        }
        $_->create foreach values %{ $self->{sprites} };

        #Background
        for ( $self->{term}->{XR}->{CAPTION} ) {
            /$R_CAPTION_BAR/ and &{
                sub {
                    #my $r = urxvt::SET_BGCOLOR $G_rend, 4;
                    #$self->{bg} = visuals::overlay->new( $self->{term}, 0, 0, $self->{term}->ncol, 1, $r );
                    $self->{bg} = visuals::overlay->new( $self->{term}, 0, 0, $self->{term}->ncol, 1, $G_rend );
                    $self->{bg}->create("show");
                    $self->{type} = $self->{term}->CAPTION_BAR;
                  }
            }();
            /$R_CAPTION_BLOCK/ and &{
                sub {
                    $self->{type} = $self->{term}->CAPTION_BLOCK;
                  }
            }();
        }

        $self->{visible}           = $self->{term}->{XR}->{SHOWING};
        $self->{labelVisible}      = $self->{term}->{XR}->{SHOWING_LABELS};
        $self->{backgroundVisible} = $self->{term}->{XR}->{SHOWING_BG};
    }

    sub set {
        my ( $self, $label, $i, $usage ) = (@_);
        if ( $self->{visible} ) {
            $self->{sprites}->{$label}->set( $i, $usage );
            $self->{labelVisible} ? $self->showLabels : $self->hideLabels;
            $self->refreshBackground;
        }
    }

    sub setColor {
        my ( $self, $label, $i, $usage ) = @_;
        $self->{sprites}->{$label}->setColor( $i, $usage );
    }

    sub show {
        my ( $self, $visible ) = @_;
        $visible = $visible // 1;
        foreach ( values %{ $self->{sprites} } ) {
            $visible ? $_->show : $_->hide;
        }
        $visible ? $self->showLabels     : $self->hideLabels;
        $visible ? $self->showBackground : $self->hideBackground;
        $self->{visible} = $visible;
    }

    sub hide {
        my ($self) = @_;
        $self->show(0);
    }

    sub showLabels {
        my ( $self, $visible ) = @_;
        $visible = $visible // 1;
        foreach ( values %{ $self->{sprites} } ) {
            $visible ? $_->showLabel : $_->hideLabel;
        }
        $self->refreshBackground;
        $self->{labelVisible} = $visible;
    }

    sub hideLabels {
        my ($self) = @_;
        $self->showLabels(0);
    }

    sub showBackground {
        my ( $self, $visible ) = @_;
        $visible = $visible // 1;
        if ( $self->{type} eq $self->{term}->CAPTION_BAR ) {
            $visible ? $self->{bg}->show : $self->{bg}->hide;
            $self->{backgroundVisible} = $visible;
        }
    }

    sub refreshBackground {
        my ($self) = @_;
        if ( $self->{backgroundVisible} ) {
            $self->hideBackground;
            $self->showBackground;
        }
    }

    sub hideBackground {
        my ($self) = @_;
        $self->showBackground(0);
    }

}

package visuals::visual {
    use fields qw(term x y rendition pictorials label count width height pictorials_bg);
    use constant BLOCKS => [qw/_ ▁ ▂ ▃ ▄ ▅ ▆ ▇ █/];
    use constant { GAUGE => '▪' };
    use List::Util qw(max);
    my $m = 0;

    use constant {
        RED    => 3,
        GREEN  => 4,
        PINK   => 7,
        YELLOW => 5,
        BLUE   => 6,
        WHITE  => 248,
    };

    sub getColor {
        for (shift) {
            return RED    if $_ > 80;
            return YELLOW if $_ > 60;
            return BLUE   if $_ > 40;
            return GREEN  if $_ > 20;
        }
        WHITE;
    }

    sub new {
        my $self = shift;
        $self = fields::new($self) unless ref $self;

        @$self{qw/term rendition x y label pictorials pictorials_bg/} = @_;

        $self->{width}  = ( length $self->{label} ) + 1 + @{ $self->{pictorials} };
        $self->{height} = 1;
        return $self;
    }

    sub setEvenGauges {
        my ( $self, $m ) = @_;
        $self->{width} += ( -@{ $self->{pictorials} } + $m );
    }

    sub create {
        my $self = shift;
        my $w    = ( length $self->{label} ) + 1;

        my @visuals = @{ $self->{pictorials} };
        $self->{pictorials} = {};
        $self->{x} = -( $w + $m ) if $self->{x} < 0;

        $self->{rendition} = urxvt::SET_FGCOLOR $self->{rendition}, 5;
        my $labelObj =
          visuals::overlay->new( $self->{term}, $self->{x}, $self->{y}, $w, $self->{height}, $self->{rendition},
            $self->{label} );

        $labelObj->create("show");
        $self->{label} = $labelObj;

        my $pos   = 0;
        my $width = 1;
        $self->{rendition} = urxvt::SET_BGCOLOR $self->{rendition}, $self->{pictorials_bg};
        for my $i (@visuals) {
            my $x = $self->{x} + $w + $pos++;

            foreach ( &RED, &GREEN, &BLUE, &YELLOW, &WHITE, &PINK ) {
                $self->{rendition} = urxvt::SET_FGCOLOR $self->{rendition}, $_;
                my $gauge;

                for ( $self->{term}->{XR}->{GAUGES} ) {
                    /${\($self->{term}->GAUGES_FULL)}/ and &{
                        sub {
                            $gauge =
                              visuals::overlay->new( $self->{term}, $x, $self->{y}, $width, 1, $self->{rendition},
                                BLOCKS->[0] );
                          }
                    }();
                    /${\($self->{term}->GAUGES_SIMPLE)}/ and &{
                        sub {
                            $gauge =
                              visuals::overlay->new( $self->{term}, $x, $self->{y}, $width, 1, $self->{rendition},
                                GAUGE );
                          }
                    }();
                }
                $gauge->create;
                $self->{pictorials}->{"$i"}->{"$_"} = $gauge;
            }
        }
    }

    sub show {
        my ( $self, $visible ) = @_;
        $visible = $visible // 1;
        for ( values %{ $self->{pictorials} } ) {
            for ( values %{$_} ) {
                $visible ? $_->show : $_->hide;
            }
        }
    }

    sub hide {
        my ($self) = @_;
        $self->show(0);
    }

    sub showLabel {
        my ( $self, $visible ) = @_;
        $visible = $visible // 1;
        $visible ? $self->{label}->show : $self->{label}->hide;
    }

    sub hideLabel {
        my ($self) = @_;
        $self->showLabel(0);
    }

    sub set {
        my ( $self, $i, $usage ) = @_;
        my $barIdx = $usage / 10 * 8 / 10;

        my $color = &getColor($usage);
        for ( values %{ $self->{pictorials}->{"$i"} } ) {
            $_->hide;
        }
        if ( $barIdx <= 8 && $barIdx >= 0 ) {
            $self->{pictorials}->{"$i"}->{"$color"}->show;

            for ( $self->{term}->{XR}->{GAUGES} ) {
                /${\($self->{term}->GAUGES_FULL)}/ and &{
                    sub {
                        $self->{pictorials}->{"$i"}->{"$color"}->set( BLOCKS->[$barIdx] );
                      }
                }();
                /${\($self->{term}->GAUGES_SIMPLE)}/ and &{
                    sub {
                        #Nothing to do yet.
                      }
                }();
            }
        }
    }
}
