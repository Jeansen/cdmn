#!/usr/bin/perl

# TopRightCorner (TRC) is an extension written for urxvt that shows
# utilizations of different system resoureces like cpu, disk i/o, ram,
# network (and more).

# Copyright (C) 2016 Marcel Lautenbach
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


use strict;
use warnings FATAL => 'all';
use autodie;
use 5.22.2;
use List::Util qw(sum);
use autodie;
use utf8;

use open ':std', ':encoding(UTF-8)';

use constant {
    RED => 3,
    GREEN => 4,
    PINK => 7,
    YELLOW => 5,
    BLUE => 6,
    WHITE => 248,
};

use constant {
    STAT => '/proc/stat',
    DISKSTATS => '/proc/diskstats',
    MEMINFO => '/proc/meminfo',
    RX_BYTES => '/sys/class/net/eth0/statistics/rx_bytes',
};

use constant {
    CPU => 'cpu',
    MEMORY => 'memory',
    NETWORK => 'network',
    DISK => 'disk',
};

use constant {GAUGE => '▪'};

use constant {
    LOWER_ONE_EIGHTH_BLOCK => '▪',
    LOWER_ONE_QUARTER_BLOCK => '▪',
    LOWER_THREE_EIGHTHS_BLOCK => '▪',
    LOWER_HALF_BLOCK => '▪',
    LOWER_FIVE_EIGHTHS_BLOCK => '▪',
    LOWER_THREE_QUARTERS_BLOCK => '▪',
    LOWER_SEVEN_EIGHTH_BLOCK => '▪',
    FULL_BLOCK => '▪',

};




sub getColor {
    for(shift){
        return RED if $_ > 80;
        return YELLOW if $_ > 60;
        return BLUE if $_ > 40;
        return GREEN if $_ > 20;
    }
    WHITE;
}


sub on_init {
    my ($self) = @_;

    my $hotkey = $self->x_resource ("%") || "M-n";
    $self->bind_action ($hotkey, "%:show") or warn "unable to register '$hotkey' as hotkey\n";

    $hotkey = $self->x_resource ("%") || "M-l";
    $self->bind_action ($hotkey, "%:show-labels") or warn "unable to register '$hotkey' as hotkey\n";

    ()
}


sub on_action {
    my ($self, $action) = @_;

    if ( $action eq "show") {
        $self->{showing} = !$self->{showing};
        while ( my($key, $value) = each(%{$self->{overlays}}) ) {
            $value->show if $key !~ /label/i and $self->{showing};
            $value->hide if ! $self->{showing};
            $value->show if $key =~ /label/i and $self->{showingLabels} and $self->{showing};
        }
    }

    if ( $action eq "show-labels" and $self->{showing}) {
        $self->{showingLabels} = !$self->{showingLabels};
        while ( my($key, $value) = each(%{$self->{overlays}}) ) {
            $value->show if $key =~ /label/i and $self->{showingLabels};
            $value->hide if $key =~ /label/i and ! $self->{showingLabels} ;
        }
    }
    ()
}

use constant BLOCKS => [ qw/▁ ▂ ▃ ▄ ▅ ▆ ▇ █/ ];

sub on_refresh_begin {
    my ($self) = @_;
    my $empty = 1;

    for(my $i = 1; $i < $self->nrow; $i++) {
        $empty = 0 if $self->ROW_t($i) !~ /^\s*$/;
    }

    if ($self->ROW_t(0) !~ /^\s*$/ and $empty ) {
        #if ($self->ROW_t(0) =~ /.*d/){
        $self->cmd_parse("\e[1T\e[1B");
        #$self->view_start(-1);
    }
}


sub on_start {
    my ($self) = @_;



    # $visibility{"cpu"} = true if ($self->x_resource('trc.cpu'));
    # $visibility{"disk"} = true if ($self->x_resource('trc.disk'));
    #$visibility{"ram"} = true if ($self->x_resource('trc.ram'));
    # $visibility{"network"} = true if ($self->x_resource('trc.network'));

    #$colors{"network"} = true if ($self->x_resource('trc.color.1'));
    #$colors{"network"} = true if ($self->x_resource('trc.color.2'));
    #$colors{"network"} = true if ($self->x_resource('trc.color.3'));
    #$colors{"network"} = true if ($self->x_resource('trc.color.5'));

    $self->{labels}->{net} = $self->x_resource('%.label.network') // 'NETWORK';
    $self->{labels}->{disk} = $self->x_resource('%.label.disk') // 'DISK';
    $self->{labels}->{cpu} = $self->x_resource('%.label.cpu') // 'CPU';
    $self->{labels}->{mem} = $self->x_resource('%.label.ram') // 'RAM';

    $self->{showing} = $self->x_resource_boolean('%.showing') // 1;
    $self->{showingLabels} = $self->x_resource_boolean('%.showing-labels') // 0;

    my $rend = urxvt::OVERLAY_RSTYLE;
    $rend = urxvt::SET_BGCOLOR $rend, 1;
    $rend = urxvt::SET_FGCOLOR $rend, 255;
    #$rend = $rend | urxvt::RS_Bold;

    my $speed = `curl -s "http://fritz.box:49000/igd2upnp/control/WANCommonIFC1" -H "Content-Type: text/xml; charset="utf-8"" -H "SoapAction:urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1#GetCommonLinkProperties" -d '<?xml version="1.0" encoding="utf-8"?><s:Envelope s:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" xmlns:s="http://schemas.xmlsoap.org/soap/envelope/"><s:Body><u:GetCommonLinkProperties xmlns:u="urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1" /></s:Body></s:Envelope>'`;
    $speed =~ /.*(NewLayer1DownstreamMaxBitRate)>([0-9]+)/;
    $speed = $2 / 8;

    #open(STAT, '/sys/class/net/eth0/speed');
    #{
    #    local $/;
    #    $speed = <STAT>;
    #    $speed = 11 * 1000000 / 8
    #}
    #close STAT;


    $self->{createTimer} = sub {
        my $p = shift;
        $self->{$p} = urxvt::timer
            ->new
            ->start ( 1 + int urxvt::NOW )
            ->interval ( 1 )
            ->cb ( $self->{"sub_$p"} );
    };

    $self->{createOverlay} = sub {
        my($designation, $rend, $diff_usage, $y) = @_;
        my $len = length $self->{labels}->{$designation};

        $rend = urxvt::SET_FGCOLOR $rend, getColor( $diff_usage );
        $self->{overlays}->{$designation."Label"} = $self->overlay ( -($len + 2), $y, $len, 1, $rend, 0 );
        $self->{overlays}->{$designation."Label"}->set ( 0, 0, $self->{labels}->{$designation} );
        ( $self->{showingLabels} and $self->{showing} )? $self->{overlays}->{$designation."Label"}->show : $self->{overlays}->{$designation."Label"}->hide;

        $self->{overlays}->{$designation} = $self->overlay ( -1, $y, 1, 1, $rend, 0 );
        $self->{overlays}->{$designation}->set ( 0, 0, GAUGE );
        $self->{showing} ? $self->{overlays}->{$designation}->show : $self->{overlays}->{$designation}->hide;
    };

    $self->{sub_cpu} = sub {
        my $diff_usage = 0;
        my $count = 0;

        open( my $f, '<', STAT );
        while (<$f>) {
            if (! /^cpu[0-9]*\s+[0-9]+/) {
                next;
            }

            my @cpu = split /\s+/;
            my $cpu = shift @cpu;


            $self->{$cpu}{prev_idle} = $self->{$cpu}{prev_idle} // 0;
            $self->{$cpu}{prev_total} = $self->{$cpu}{prev_total} // 0;
            $self->{$cpu}{diff_total} = $self->{$cpu}{diff_total} // 0;

            my $idle = $cpu[3];
            my $total = sum( @cpu );

            my $diff_idle = $idle - $self->{$cpu}{prev_idle};
            if ($total != $self->{$cpu}{prev_total}) {
                $self->{$cpu}{diff_total} = $total - $self->{$cpu}{prev_total};
            }
            $diff_usage = 100 * ($self->{$cpu}{diff_total} - $diff_idle) / $self->{$cpu}{diff_total};

            $self->{$cpu}{prev_idle} = $idle;
            $self->{$cpu}{prev_total} = $total;

            if ($cpu =~ /^cpu$/) {
                $self->{createOverlay}($cpu, $rend, $diff_usage, 0);
            }

            if ($cpu =~ /^cpu[0-9]+/) {
                $self->{createHeaderOverlay}($cpu, $rend, $diff_usage, ++$count);
            }
        }
    };

    $self->{sub_disk} = sub {
        my $diff_usage;
        my $count = 0;

        open( my $f, '<', DISKSTATS );
        while (<$f>) {
            if (! /\bsd(a|b|c)\b/) {
              next;
            }
            my @sda = split /\s+/, $_;
            shift @sda;
            shift @sda;
            shift @sda;

            $self->{$sda[0]}{prev_sda} = $self->{$sda[0]}{prev_sda} // 0;

            my $diff_sda = $sda[10] - $self->{$sda[0]}{prev_sda};
            $diff_usage = $diff_sda / 7;

            $self->{$sda[0]}{prev_sda} = $sda[10];
        }

        #$self->{createOverlay}("disk", $rend, $diff_usage, 1);
        $self->{createHeaderOverlay}($self->{$sda[0]}{prev_sda}, $rend, $diff_usage, ++$count);
    };

    $self->{sub_mem} = sub {
        my @sda;
        my $total = 0;
        my $available = 0;

        open( my $f, '<', MEMINFO );
        while (<$f>) {
            if (/^MemTotal:\s+[0-9]+/) {
                @sda = split /\s+/, $_;
                $total = $sda[1];
            }
            if (/^MemAvailable:\s+[0-9]+/) {
                @sda = split /\s+/, $_;
                $available = $sda[1];
            }
        }

        my $diff_usage = 100 - (100 * $available / $total);

        $self->{createOverlay}("mem", $rend, $diff_usage, 2);
    };

    $self->{sub_net} = sub {
        my $rx_bytes = 0;
        state $prev_rx = 0;

        open( my $f, '<', RX_BYTES );
        {
            local $/;
            $rx_bytes = <$f>;
        }

        my $diff_rx = $rx_bytes - $prev_rx;
        my $diff_usage = 100 * $diff_rx / $speed;

        $prev_rx = $rx_bytes;

        $self->{createOverlay}("net", $rend, $diff_usage, 3);
    };

    my @stats = qw(cpu disk mem net);
    foreach (@stats) {
        $self->{createTimer}($_);
    }


    $self->{createHeaderOverlay} = sub {
        my($designation, $rend, $diff_usage, $x) = @_;
        my $usage = $diff_usage / 10 * 7 / 10;
        my $w = (length $self->{labels}->{cpu}) + 2;

        $rend = urxvt::SET_FGCOLOR $rend, 5;
        $rend = urxvt::SET_BGCOLOR $rend, 19;

        $self->{overlays}->{header}->{x1} = $self->overlay( 0, 0, $w, 1, $rend, 0 );
        $self->{overlays}->{header}->{x1}->set ( 0, 0, $self->{labels}->{cpu} );
        $self->{overlays}->{header}->{x1}->show;

        $self->{overlays}->{header}->{$x} = $self->overlay( $w+$x-1, 0, 1, 1, $rend, 0 );
        $self->{overlays}->{header}->{$x}->set ( 0, 0, BLOCKS->[$usage] );
        $self->{overlays}->{header}->{$x}->show;


       # $self->{overlays}->{x2} = $self->overlay( $w+$x, 0, $self->ncol-$w-$x-1, 1, $rend, 0 );
       # $self->{overlays}->{x2}->show;
    };

    # $self->{createHeaderOverlay}();
    ()
}

